"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps = (a, b2) => __defProps(a, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod3) => function __require2() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k2, v, yes, no) => {
    try {
      var x2 = generator[k2](v), isAwait = (v = x2.value) instanceof __await, done = x2.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k2 === "return" ? k2 : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k2) => it2[k2] = (x2) => new Promise((yes, no) => resume(k2, x2, yes, no)), it2 = {};
  return generator = generator.apply(__this, __arguments), it2[__knownSymbol("asyncIterator")] = () => it2, method("next"), method("throw"), method("return"), it2;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it2 = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k2) => it2[k2] = (x2) => obj[k2](x2);
  } else {
    obj = obj.call(value);
    method = (k2) => it2[k2] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k2 === "throw") throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x2 = obj[k2](v);
          if (!(x2 instanceof Object)) __typeError("Object expected");
          resolve(x2);
        }), 1)
      };
    };
  }
  return it2[__knownSymbol("iterator")] = () => it2, method("next"), "throw" in obj ? method("throw") : it2.throw = (x2) => {
    throw x2;
  }, "return" in obj && method("return"), it2;
};
var __forAwait = (obj, it2, method) => (it2 = obj[__knownSymbol("asyncIterator")]) ? it2.call(obj) : (obj = obj[__knownSymbol("iterator")](), it2 = {}, method = (key, fn3) => (fn3 = obj[key]) && (it2[key] = (arg) => new Promise((yes, no, done) => (arg = fn3.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it2);

// ../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react.production.js
var require_react_production = __commonJS({
  "../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react.production.js"(exports2) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    };
    var assign = Object.assign;
    var emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    var ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null };
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function ReactElement(type, key, self2, source, owner, props) {
      self2 = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== self2 ? self2 : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(
        oldElement.type,
        newKey,
        void 0,
        void 0,
        void 0,
        oldElement.props
      );
    }
    function isValidElement2(object2) {
      return "object" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
    }
    function noop$1() {
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array2,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array2, escapedPrefix, "", function(c) {
          return c;
        })) : null != callback && (isValidElement2(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array2.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
            nameSoFar,
            array2,
            escapedPrefix,
            type,
            callback
          );
      else if (i = getIteratorFn(children), "function" === typeof i)
        for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
            nameSoFar,
            array2,
            escapedPrefix,
            type,
            callback
          );
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array2,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array2 = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array2 ? "object with keys {" + Object.keys(children).join(", ") + "}" : array2) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    function noop2() {
    }
    exports2.Children = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement2(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    exports2.Component = Component;
    exports2.Fragment = REACT_FRAGMENT_TYPE;
    exports2.Profiler = REACT_PROFILER_TYPE;
    exports2.PureComponent = PureComponent;
    exports2.StrictMode = REACT_STRICT_MODE_TYPE;
    exports2.Suspense = REACT_SUSPENSE_TYPE;
    exports2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports2.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(size) {
        return ReactSharedInternals.H.useMemoCache(size);
      }
    };
    exports2.cache = function(fn3) {
      return function() {
        return fn3.apply(null, arguments);
      };
    };
    exports2.cloneElement = function(element, config3, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign({}, element.props), key = element.key, owner = void 0;
      if (null != config3)
        for (propName in void 0 !== config3.ref && (owner = void 0), void 0 !== config3.key && (key = "" + config3.key), config3)
          !hasOwnProperty2.call(config3, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config3.ref || (props[propName] = config3[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i = 0; i < propName; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, void 0, void 0, owner, props);
    };
    exports2.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    exports2.createElement = function(type, config3, children) {
      var propName, props = {}, key = null;
      if (null != config3)
        for (propName in void 0 !== config3.key && (key = "" + config3.key), config3)
          hasOwnProperty2.call(config3, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config3[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type, key, void 0, void 0, null, props);
    };
    exports2.createRef = function() {
      return { current: null };
    };
    exports2.forwardRef = function(render) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render };
    };
    exports2.isValidElement = isValidElement2;
    exports2.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports2.memo = function(type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: void 0 === compare ? null : compare
      };
    };
    exports2.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        ReactSharedInternals.T = prevTransition;
      }
    };
    exports2.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    exports2.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    exports2.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    exports2.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    exports2.useContext = function(Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    exports2.useDebugValue = function() {
    };
    exports2.useDeferredValue = function(value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    exports2.useEffect = function(create2, createDeps, update) {
      var dispatcher = ReactSharedInternals.H;
      if ("function" === typeof update)
        throw Error(
          "useEffect CRUD overload is not enabled in this build of React."
        );
      return dispatcher.useEffect(create2, createDeps);
    };
    exports2.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    exports2.useImperativeHandle = function(ref, create2, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create2, deps);
    };
    exports2.useInsertionEffect = function(create2, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create2, deps);
    };
    exports2.useLayoutEffect = function(create2, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create2, deps);
    };
    exports2.useMemo = function(create2, deps) {
      return ReactSharedInternals.H.useMemo(create2, deps);
    };
    exports2.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    exports2.useReducer = function(reducer, initialArg, init) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
    };
    exports2.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    exports2.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    exports2.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports2.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    exports2.version = "19.1.0";
  }
});

// ../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react.development.js"(exports2, module2) {
    "use strict";
    "production" !== process.env.NODE_ENV && function() {
      function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              info[0],
              info[1]
            );
          }
        });
      }
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
      }
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function ComponentDummy() {
      }
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x2) {
              }
          }
        return null;
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type);
          return name ? "<" + name + ">" : "<...>";
        } catch (x2) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config3) {
        if (hasOwnProperty2.call(config3, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config3, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config3.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, self2, source, owner, props, debugStack, debugTask) {
        self2 = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          oldElement._owner,
          oldElement.props,
          oldElement._debugStack,
          oldElement._debugTask
        );
        oldElement._store && (newKey._store.validated = oldElement._store.validated);
        return newKey;
      }
      function isValidElement2(object2) {
        return "object" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
      }
      function noop$1() {
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array2,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback) {
          invokeCallback = children;
          callback = callback(invokeCallback);
          var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
          isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array2, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement2(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + childKey
          ), "" !== nameSoFar && null != invokeCallback && isValidElement2(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array2.push(callback));
          return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array2,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (i === children.entries && (didWarnAboutMaps || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array2,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array2,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array2 = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array2 ? "object with keys {" + Object.keys(children).join(", ") + "}" : array2) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status)
          return ctor = payload._result, void 0 === ctor && console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
            ctor
          ), "default" in ctor || console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
            ctor
          ), ctor.default;
        throw payload._result;
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      function noop2() {
      }
      function enqueueTask(task) {
        if (null === enqueueTaskImpl)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module2 && module2[requireString]).call(
              module2,
              "timers"
            ).setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback;
              channel.port2.postMessage(void 0);
            };
          }
        return enqueueTaskImpl(task);
      }
      function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
      }
      function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
        actScopeDepth = prevActScopeDepth;
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue)
          if (0 !== queue.length)
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
              return;
            } catch (error) {
              ReactSharedInternals.thrownErrors.push(error);
            }
          else ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
      }
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = true;
          var i = 0;
          try {
            for (; i < queue.length; i++) {
              var callback = queue[i];
              do {
                ReactSharedInternals.didUsePromise = false;
                var continuation = callback(false);
                if (null !== continuation) {
                  if (ReactSharedInternals.didUsePromise) {
                    queue[i] = callback;
                    queue.splice(0, i);
                    return;
                  }
                  callback = continuation;
                } else break;
              } while (1);
            }
            queue.length = 0;
          } catch (error) {
            queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
          } finally {
            isFlushing = false;
          }
        }
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function(publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, fnName;
      for (fnName in deprecatedAPIs)
        deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      ComponentDummy.prototype = Component.prototype;
      deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
      deprecatedAPIs.constructor = PureComponent;
      assign(deprecatedAPIs, Component.prototype);
      deprecatedAPIs.isPureReactComponent = true;
      var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false,
        didUsePromise: false,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, hasOwnProperty2 = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      deprecatedAPIs = {
        "react-stack-bottom-frame": function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = deprecatedAPIs["react-stack-bottom-frame"].bind(deprecatedAPIs, UnknownOwner)();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
      deprecatedAPIs = Object.freeze({
        __proto__: null,
        c: function(size) {
          return resolveDispatcher().useMemoCache(size);
        }
      });
      exports2.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement2(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports2.Component = Component;
      exports2.Fragment = REACT_FRAGMENT_TYPE;
      exports2.Profiler = REACT_PROFILER_TYPE;
      exports2.PureComponent = PureComponent;
      exports2.StrictMode = REACT_STRICT_MODE_TYPE;
      exports2.Suspense = REACT_SUSPENSE_TYPE;
      exports2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports2.__COMPILER_RUNTIME = deprecatedAPIs;
      exports2.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
        try {
          var result = callback();
        } catch (error) {
          ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
          var thenable = result;
          queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          });
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              thenable.then(
                function(returnValue) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  if (0 === prevActScopeDepth) {
                    try {
                      flushActQueue(queue), enqueueTask(function() {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                    } catch (error$0) {
                      ReactSharedInternals.thrownErrors.push(error$0);
                    }
                    if (0 < ReactSharedInternals.thrownErrors.length) {
                      var _thrownError = aggregateErrors(
                        ReactSharedInternals.thrownErrors
                      );
                      ReactSharedInternals.thrownErrors.length = 0;
                      reject(_thrownError);
                    }
                  } else resolve(returnValue);
                },
                function(error) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                    ReactSharedInternals.thrownErrors
                  ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                }
              );
            }
          };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
              return recursivelyFlushAsyncActWork(
                returnValue$jscomp$0,
                resolve,
                reject
              );
            })) : resolve(returnValue$jscomp$0);
          }
        };
      };
      exports2.cache = function(fn3) {
        return function() {
          return fn3.apply(null, arguments);
        };
      };
      exports2.captureOwnerStack = function() {
        var getCurrentStack = ReactSharedInternals.getCurrentStack;
        return null === getCurrentStack ? null : getCurrentStack();
      };
      exports2.cloneElement = function(element, config3, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config3) {
          var JSCompiler_inline_result;
          a: {
            if (hasOwnProperty2.call(config3, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config3,
              "ref"
            ).get) && JSCompiler_inline_result.isReactWarning) {
              JSCompiler_inline_result = false;
              break a;
            }
            JSCompiler_inline_result = void 0 !== config3.ref;
          }
          JSCompiler_inline_result && (owner = getOwner());
          hasValidKey(config3) && (checkKeyStringCoercion(config3.key), key = "" + config3.key);
          for (propName in config3)
            !hasOwnProperty2.call(config3, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config3.ref || (props[propName] = config3[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          JSCompiler_inline_result = Array(propName);
          for (var i = 0; i < propName; i++)
            JSCompiler_inline_result[i] = arguments[i + 2];
          props.children = JSCompiler_inline_result;
        }
        props = ReactElement(
          element.type,
          key,
          void 0,
          void 0,
          owner,
          props,
          element._debugStack,
          element._debugTask
        );
        for (key = 2; key < arguments.length; key++)
          owner = arguments[key], isValidElement2(owner) && owner._store && (owner._store.validated = 1);
        return props;
      };
      exports2.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
      };
      exports2.createElement = function(type, config3, children) {
        for (var i = 2; i < arguments.length; i++) {
          var node = arguments[i];
          isValidElement2(node) && node._store && (node._store.validated = 1);
        }
        i = {};
        node = null;
        if (null != config3)
          for (propName in didWarnAboutOldJSXRuntime || !("__self" in config3) || "key" in config3 || (didWarnAboutOldJSXRuntime = true, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), hasValidKey(config3) && (checkKeyStringCoercion(config3.key), node = "" + config3.key), config3)
            hasOwnProperty2.call(config3, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config3[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), _i2 = 0; _i2 < childrenLength; _i2++)
            childArray[_i2] = arguments[_i2 + 2];
          Object.freeze && Object.freeze(childArray);
          i.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === i[propName] && (i[propName] = childrenLength[propName]);
        node && defineKeyPropWarningGetter(
          i,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return ReactElement(
          type,
          node,
          void 0,
          void 0,
          getOwner(),
          i,
          propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports2.createRef = function() {
        var refObject = { current: null };
        Object.seal(refObject);
        return refObject;
      };
      exports2.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : "function" !== typeof render ? console.error(
          "forwardRef requires a render function but was given %s.",
          null === render ? "null" : typeof render
        ) : 0 !== render.length && 2 !== render.length && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        );
        null != render && null != render.defaultProps && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
        Object.defineProperty(elementType, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
          }
        });
        return elementType;
      };
      exports2.isValidElement = isValidElement2;
      exports2.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports2.memo = function(type, compare) {
        null == type && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
        compare = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
          }
        });
        return compare;
      };
      exports2.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), ReactSharedInternals.T = prevTransition;
        }
      };
      exports2.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
      };
      exports2.use = function(usable) {
        return resolveDispatcher().use(usable);
      };
      exports2.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(
          action,
          initialState,
          permalink
        );
      };
      exports2.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
      };
      exports2.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
        return dispatcher.useContext(Context);
      };
      exports2.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
      };
      exports2.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
      };
      exports2.useEffect = function(create2, createDeps, update) {
        null == create2 && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        var dispatcher = resolveDispatcher();
        if ("function" === typeof update)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create2, createDeps);
      };
      exports2.useId = function() {
        return resolveDispatcher().useId();
      };
      exports2.useImperativeHandle = function(ref, create2, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create2, deps);
      };
      exports2.useInsertionEffect = function(create2, deps) {
        null == create2 && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useInsertionEffect(create2, deps);
      };
      exports2.useLayoutEffect = function(create2, deps) {
        null == create2 && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useLayoutEffect(create2, deps);
      };
      exports2.useMemo = function(create2, deps) {
        return resolveDispatcher().useMemo(create2, deps);
      };
      exports2.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
      };
      exports2.useReducer = function(reducer, initialArg, init) {
        return resolveDispatcher().useReducer(reducer, initialArg, init);
      };
      exports2.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
      };
      exports2.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
      };
      exports2.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports2.useTransition = function() {
        return resolveDispatcher().useTransition();
      };
      exports2.version = "19.1.0";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }
});

// ../../node_modules/.pnpm/react@19.1.0/node_modules/react/index.js
var require_react = __commonJS({
  "../../node_modules/.pnpm/react@19.1.0/node_modules/react/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_production();
    } else {
      module2.exports = require_react_development();
    }
  }
});

// ../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react-jsx-runtime.production.js
var require_react_jsx_runtime_production = __commonJS({
  "../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react-jsx-runtime.production.js"(exports2) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config3, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config3.key && (key = "" + config3.key);
      if ("key" in config3) {
        maybeKey = {};
        for (var propName in config3)
          "key" !== propName && (maybeKey[propName] = config3[propName]);
      } else maybeKey = config3;
      config3 = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== config3 ? config3 : null,
        props: maybeKey
      };
    }
    exports2.Fragment = REACT_FRAGMENT_TYPE;
    exports2.jsx = jsxProd;
    exports2.jsxs = jsxProd;
  }
});

// ../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react-jsx-runtime.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && function() {
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x2) {
              }
          }
        return null;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type);
          return name ? "<" + name + ">" : "<...>";
        } catch (x2) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config3) {
        if (hasOwnProperty2.call(config3, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config3, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config3.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, self2, source, owner, props, debugStack, debugTask) {
        self2 = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function jsxDEVImpl(type, config3, maybeKey, isStaticChildren, source, self2, debugStack, debugTask) {
        var children = config3.children;
        if (void 0 !== children)
          if (isStaticChildren)
            if (isArrayImpl(children)) {
              for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                validateChildKeys(children[isStaticChildren]);
              Object.freeze && Object.freeze(children);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else validateChildKeys(children);
        if (hasOwnProperty2.call(config3, "key")) {
          children = getComponentNameFromType(type);
          var keys = Object.keys(config3).filter(function(k2) {
            return "key" !== k2;
          });
          isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
          didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ), didWarnAboutKeySpread[children + isStaticChildren] = true);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config3) && (checkKeyStringCoercion(config3.key), children = "" + config3.key);
        if ("key" in config3) {
          maybeKey = {};
          for (var propName in config3)
            "key" !== propName && (maybeKey[propName] = config3[propName]);
        } else maybeKey = config3;
        children && defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        return ReactElement(
          type,
          children,
          self2,
          source,
          getOwner(),
          maybeKey,
          debugStack,
          debugTask
        );
      }
      function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
      }
      var React10 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React10.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty2 = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      React10 = {
        "react-stack-bottom-frame": function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = React10["react-stack-bottom-frame"].bind(
        React10,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutKeySpread = {};
      exports2.Fragment = REACT_FRAGMENT_TYPE;
      exports2.jsx = function(type, config3, maybeKey, source, self2) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config3,
          maybeKey,
          false,
          source,
          self2,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports2.jsxs = function(type, config3, maybeKey, source, self2) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config3,
          maybeKey,
          true,
          source,
          self2,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
    }();
  }
});

// ../../node_modules/.pnpm/react@19.1.0/node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "../../node_modules/.pnpm/react@19.1.0/node_modules/react/jsx-runtime.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_jsx_runtime_production();
    } else {
      module2.exports = require_react_jsx_runtime_development();
    }
  }
});

// ../../node_modules/.pnpm/react-dom@19.1.0_react@19.1.0/node_modules/react-dom/cjs/react-dom.production.js
var require_react_dom_production = __commonJS({
  "../../node_modules/.pnpm/react-dom@19.1.0_react@19.1.0/node_modules/react-dom/cjs/react-dom.production.js"(exports2) {
    "use strict";
    var React10 = require_react();
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function noop2() {
    }
    var Internals = {
      d: {
        f: noop2,
        r: function() {
          throw Error(formatProdErrorMessage(522));
        },
        D: noop2,
        C: noop2,
        L: noop2,
        m: noop2,
        X: noop2,
        S: noop2,
        M: noop2
      },
      p: 0,
      findDOMNode: null
    };
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    var ReactSharedInternals = React10.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function getCrossOriginStringAs(as2, input) {
      if ("font" === as2) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    exports2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports2.createPortal = function(children, container2) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container2 || 1 !== container2.nodeType && 9 !== container2.nodeType && 11 !== container2.nodeType)
        throw Error(formatProdErrorMessage(299));
      return createPortal$1(children, container2, null, key);
    };
    exports2.flushSync = function(fn3) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn3) return fn3();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
      }
    };
    exports2.preconnect = function(href, options) {
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    exports2.prefetchDNS = function(href) {
      "string" === typeof href && Internals.d.D(href);
    };
    exports2.preinit = function(href, options) {
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as2 ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin,
            integrity,
            fetchPriority
          }
        ) : "script" === as2 && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    exports2.preinitModule = function(href, options) {
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as) {
            var crossOrigin = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            );
            Internals.d.M(href, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        } else null == options && Internals.d.M(href);
    };
    exports2.preload = function(href, options) {
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin);
        Internals.d.L(href, as2, {
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    exports2.preloadModule = function(href, options) {
      if ("string" === typeof href)
        if (options) {
          var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
          Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          });
        } else Internals.d.m(href);
    };
    exports2.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    exports2.unstable_batchedUpdates = function(fn3, a) {
      return fn3(a);
    };
    exports2.useFormState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useFormState(action, initialState, permalink);
    };
    exports2.useFormStatus = function() {
      return ReactSharedInternals.H.useHostTransitionStatus();
    };
    exports2.version = "19.1.0";
  }
});

// ../../node_modules/.pnpm/react-dom@19.1.0_react@19.1.0/node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "../../node_modules/.pnpm/react-dom@19.1.0_react@19.1.0/node_modules/react-dom/cjs/react-dom.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && function() {
      function noop2() {
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        try {
          testStringCoercion(key);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        JSCompiler_inline_result && (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
        ), testStringCoercion(key));
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      function getCrossOriginStringAs(as2, input) {
        if ("font" === as2) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      function getValueDescriptorExpectingObjectForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
      }
      function getValueDescriptorExpectingEnumForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React10 = require_react(), Internals = {
        d: {
          f: noop2,
          r: function() {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          },
          D: noop2,
          C: noop2,
          L: noop2,
          m: noop2,
          X: noop2,
          S: noop2,
          M: noop2
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React10.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
      exports2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports2.createPortal = function(children, container2) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container2 || 1 !== container2.nodeType && 9 !== container2.nodeType && 11 !== container2.nodeType)
          throw Error("Target container is not a DOM element.");
        return createPortal$1(children, container2, null, key);
      };
      exports2.flushSync = function(fn3) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn3)
            return fn3();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
            "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
          );
        }
      };
      exports2.preconnect = function(href, options) {
        "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
          "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : null != options && "string" !== typeof options.crossOrigin && console.error(
          "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
          getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
        ) : console.error(
          "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports2.prefetchDNS = function(href) {
        if ("string" !== typeof href || !href)
          console.error(
            "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
        else if (1 < arguments.length) {
          var options = arguments[1];
          "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          );
        }
        "string" === typeof href && Internals.d.D(href);
      };
      exports2.preinit = function(href, options) {
        "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
          "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : "style" !== options.as && "script" !== options.as && console.error(
          'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
          getValueDescriptorExpectingEnumForWarning(options.as)
        ) : console.error(
          "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as2 ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as2 && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports2.preinitModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
        if (encountered)
          console.error(
            "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
            encountered
          );
        else
          switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
            case "script":
              break;
            default:
              encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
          }
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as)
              encountered = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              ), Internals.d.M(href, {
                crossOrigin: encountered,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
          } else null == options && Internals.d.M(href);
      };
      exports2.preload = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          encountered = options.as;
          var crossOrigin = getCrossOriginStringAs(
            encountered,
            options.crossOrigin
          );
          Internals.d.L(href, encountered, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports2.preloadModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
        "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        ), Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin: encountered,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        })) : Internals.d.m(href));
      };
      exports2.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports2.unstable_batchedUpdates = function(fn3, a) {
        return fn3(a);
      };
      exports2.useFormState = function(action, initialState, permalink) {
        return resolveDispatcher().useFormState(action, initialState, permalink);
      };
      exports2.useFormStatus = function() {
        return resolveDispatcher().useHostTransitionStatus();
      };
      exports2.version = "19.1.0";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }
});

// ../../node_modules/.pnpm/react-dom@19.1.0_react@19.1.0/node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "../../node_modules/.pnpm/react-dom@19.1.0_react@19.1.0/node_modules/react-dom/index.js"(exports2, module2) {
    "use strict";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (process.env.NODE_ENV !== "production") {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    if (process.env.NODE_ENV === "production") {
      checkDCE();
      module2.exports = require_react_dom_production();
    } else {
      module2.exports = require_react_dom_development();
    }
  }
});

// ../../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js"(exports2, module2) {
    "use strict";
    !function(t, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports2, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r2 = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $3 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r3 = String(t2);
        return !r3 || r3.length >= e2 ? t2 : "" + Array(e2 + 1 - r3.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r3 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date()) return -t2(n2, e2);
        var r3 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r3, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r3 + (s2 ? -1 : 1), c);
        return +(-(r3 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r2, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M2;
      var p = "$isDayjsObject", S2 = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w2 = function t2(e2, n2, r3) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r3 && i2 && (g = i2), i2 || !r3 && g;
      }, O2 = function(t2, e2) {
        if (S2(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b2 = v;
      b2.l = w2, b2.i = S2, b2.w = function(t2, e2) {
        return O2(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M3(t2) {
          this.$L = w2(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M3.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b2.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r3 = e2.match($3);
              if (r3) {
                var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b2;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O2(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O2(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O2(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b2.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r3 = !!b2.u(e2) || e2, f2 = b2.p(t2), l2 = function(t3, e3) {
            var i2 = b2.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r3 ? i2 : i2.endOf(a);
          }, $4 = function(t3, e3) {
            return b2.w(n2.toDate()[t3].apply(n2.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M4 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r3 ? l2(1, 0) : l2(31, 11);
            case c:
              return r3 ? l2(1, M4) : l2(0, M4 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r3 ? m3 - D2 : m3 + (6 - D2), M4);
            case a:
            case d:
              return $4(v2 + "Hours", 0);
            case u:
              return $4(v2 + "Minutes", 1);
            case s:
              return $4(v2 + "Seconds", 2);
            case i:
              return $4(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b2.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r2] = f2 + "Milliseconds", n2)[o2], $4 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($4), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($4);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b2.p(t2)]();
        }, m2.add = function(r3, f2) {
          var d2, l2 = this;
          r3 = Number(r3);
          var $4 = b2.p(f2), y2 = function(t2) {
            var e2 = O2(l2);
            return b2.w(e2.date(e2.date() + Math.round(t2 * r3)), l2);
          };
          if ($4 === c) return this.set(c, this.$M + r3);
          if ($4 === h) return this.set(h, this.$y + r3);
          if ($4 === a) return y2(1);
          if ($4 === o) return y2(7);
          var M4 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$4] || 1, m3 = this.$d.getTime() + r3 * M4;
          return b2.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r3 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b2.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r3)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b2.s(s2 % 12 || 12, t3, "0");
          }, $4 = f2 || function(t3, e3, n3) {
            var r4 = t3 < 12 ? "AM" : "PM";
            return n3 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y, function(t3, r4) {
            return r4 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b2.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b2.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b2.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b2.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $4(s2, u2, true);
                case "A":
                  return $4(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b2.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b2.s(e2.$s, 2, "0");
                case "SSS":
                  return b2.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r3, d2, l2) {
          var $4, y2 = this, M4 = b2.p(d2), m3 = O2(r3), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b2.m(y2, m3);
          };
          switch (M4) {
            case h:
              $4 = D2() / 12;
              break;
            case c:
              $4 = D2();
              break;
            case f:
              $4 = D2() / 3;
              break;
            case o:
              $4 = (g2 - v2) / 6048e5;
              break;
            case a:
              $4 = (g2 - v2) / 864e5;
              break;
            case u:
              $4 = g2 / n;
              break;
            case s:
              $4 = g2 / e;
              break;
            case i:
              $4 = g2 / t;
              break;
            default:
              $4 = g2;
          }
          return l2 ? $4 : b2.a($4);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r3 = w2(t2, e2, true);
          return r3 && (n2.$L = r3), n2;
        }, m2.clone = function() {
          return b2.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), k2 = _.prototype;
      return O2.prototype = k2, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k2[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O2.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O2), t2.$i = true), O2;
      }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t2) {
        return O2(1e3 * t2);
      }, O2.en = D[g], O2.Ls = D, O2.p = {}, O2;
    });
  }
});

// ../../node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js
var require_cssesc = __commonJS({
  "../../node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js"(exports2, module2) {
    "use strict";
    var object2 = {};
    var hasOwnProperty2 = object2.hasOwnProperty;
    var merge = function merge2(options, defaults) {
      if (!options) {
        return defaults;
      }
      var result = {};
      for (var key in defaults) {
        result[key] = hasOwnProperty2.call(options, key) ? options[key] : defaults[key];
      }
      return result;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc3 = function cssesc4(string2, options) {
      options = merge(options, cssesc4.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier = options.isIdentifier;
      var firstChar = string2.charAt(0);
      var output = "";
      var counter = 0;
      var length = string2.length;
      while (counter < length) {
        var character = string2.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string2.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = character;
          }
        }
        output += value;
      }
      if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $22) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $22;
      });
      if (!isIdentifier && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc3.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc3.version = "3.0.0";
    module2.exports = cssesc3;
  }
});

// ../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js"(exports2, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object2, property) {
      try {
        return property in object2;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array2, options) {
      if (!Array.isArray(array2)) {
        throw new Error("first argument should be an array");
      }
      return array2.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module2.exports = deepmerge_1;
  }
});

// ../../node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "../../node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    "use strict";
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number2, base2, endian) {
        if (BN.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max3(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min3(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN.prototype._initArray = function _initArray(number2, base2, endian) {
        assert(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j2, w2;
        var off = 0;
        if (endian === "be") {
          for (i = number2.length - 1, j2 = 0; i >= 0; i -= 3) {
            w2 = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j2 = 0; i < number2.length; i += 3) {
            w2 = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c = string2.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r2 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r2;
      }
      BN.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j2 = 0;
        var w2;
        if (endian === "be") {
          for (i = number2.length - 1; i >= start; i -= 2) {
            w2 = parseHexByte(number2, start, i) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
            w2 = parseHexByte(number2, start, i) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r2 = 0;
        var b2 = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r2 *= mul3;
          if (c >= 49) {
            b2 = c - 49 + 10;
          } else if (c >= 17) {
            b2 = c - 17 + 10;
          } else {
            b2 = c;
          }
          assert(c >= 0 && b2 < mul3, "Invalid character");
          r2 += b2;
        }
        return r2;
      }
      BN.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod3 = total % limbLen;
        var end = Math.min(total, total - mod3) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number2, i, i + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod3 !== 0) {
          var pow3 = 1;
          word = parseBase(number2, i, number2.length, base2);
          for (i = 0; i < mod3; i++) {
            pow3 *= base2;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone3() {
        var r2 = new BN(null);
        this.copy(r2);
        return r2;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w2 = this.words[i];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r2 = c.modrn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w2) {
          return 32 - Math.clz32(w2);
        };
      } else {
        BN.prototype._countBits = function _countBits(w2) {
          var t = w2;
          var r2 = 0;
          if (t >= 4096) {
            r2 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r2 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r2 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r2 += 2;
            t >>>= 2;
          }
          return r2 + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w2) {
        if (w2 === 0) return 26;
        var t = w2;
        var r2 = 0;
        if ((t & 8191) === 0) {
          r2 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r2 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r2 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r2 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN.prototype.bitLength = function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi3 = this._countBits(w2);
        return (this.length - 1) * 26 + hi3;
      };
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = num.words[off] >>> wbit & 1;
        }
        return w2;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r2 = 0;
        for (var i = 0; i < this.length; i++) {
          var b2 = this._zeroBits(this.words[i]);
          r2 += b2;
          if (b2 !== 26) break;
        }
        return r2;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or2(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b2.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = a.words[i] ^ b2.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a, b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r2 = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add4(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b2;
        if (cmp > 0) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r2 = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub3(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a * b2;
        var lo2 = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i = k2 - j2 | 0;
            a = self2.words[i] | 0;
            b2 = num.words[j2] | 0;
            r2 = a * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b2 = num.words;
        var o = out.words;
        var c = 0;
        var lo2;
        var mid;
        var hi3;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi3 = Math.imul(ah0, bh0);
        var w0 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi3 = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi3 = hi3 + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi3 = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi3 = hi3 + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi3 = hi3 + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi3 = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi3 = hi3 + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi3 = hi3 + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi3 = hi3 + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi3 = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi3 = hi3 + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi3 = hi3 + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi3 = hi3 + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi3 = hi3 + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi3 = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi3 = hi3 + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi3 = hi3 + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi3 = hi3 + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi3 = hi3 + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi3 = hi3 + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi3 = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi3 = hi3 + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi3 = hi3 + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi3 = hi3 + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi3 = hi3 + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi3 = hi3 + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi3 = hi3 + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi3 = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi3 = hi3 + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi3 = hi3 + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi3 = hi3 + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi3 = hi3 + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi3 = hi3 + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi3 = hi3 + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi3 = hi3 + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi3 = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi3 = hi3 + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi3 = hi3 + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi3 = hi3 + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi3 = hi3 + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi3 = hi3 + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi3 = hi3 + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi3 = hi3 + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi3 = hi3 + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi3 = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi3 = hi3 + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi3 = hi3 + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi3 = hi3 + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi3 = hi3 + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi3 = hi3 + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi3 = hi3 + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi3 = hi3 + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi3 = hi3 + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi3 = hi3 + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi3 = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi3 = hi3 + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi3 = hi3 + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi3 = hi3 + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi3 = hi3 + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi3 = hi3 + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi3 = hi3 + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi3 = hi3 + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi3 = hi3 + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi3 = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi3 = hi3 + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi3 = hi3 + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi3 = hi3 + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi3 = hi3 + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi3 = hi3 + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi3 = hi3 + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi3 = hi3 + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi3 = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi3 = hi3 + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi3 = hi3 + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi3 = hi3 + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi3 = hi3 + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi3 = hi3 + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi3 = hi3 + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi3 = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi3 = hi3 + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi3 = hi3 + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi3 = hi3 + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi3 = hi3 + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi3 = hi3 + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi3 = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi3 = hi3 + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi3 = hi3 + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi3 = hi3 + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi3 = hi3 + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi3 = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi3 = hi3 + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi3 = hi3 + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi3 = hi3 + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi3 = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi3 = hi3 + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi3 = hi3 + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi3 = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi3 = hi3 + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi3 = Math.imul(ah9, bh9);
        var w18 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i = k2 - j2;
            var a = self2.words[i] | 0;
            var b2 = num.words[j2] | 0;
            var r2 = a * b2;
            var lo2 = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x2, y) {
        this.x = x2;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x2, l, N) {
        if (x2 === 0 || x2 === N - 1) return x2;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x2 & 1) << l - i - 1;
          x2 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform2(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j2 = 0; j2 < s; j2++) {
              var re3 = rtws[p + j2];
              var ie3 = itws[p + j2];
              var ro2 = rtws[p + j2 + s];
              var io2 = itws[p + j2 + s];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p + j2] = re3 + ro2;
              itws[p + j2] = ie3 + io2;
              rtws[p + j2 + s] = re3 - ro2;
              itws[p + j2 + s] = ie3 - io2;
              if (j2 !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w2 = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w2 & 67108863;
          if (w2 < 67108864) {
            carry = 0;
          } else {
            carry = w2 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x2, y, out) {
        var N = 2 * this.guessLen13b(x2.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x2.words, x2.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x2.negative ^ y.negative;
        out.length = x2.length + y.length;
        return out._strip();
      };
      BN.prototype.mul = function mul3(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w2 = (this.words[i] | 0) * num;
          var lo2 = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow3(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w2.length; i++, res = res.sqr()) {
          if (w2[i] !== 0) break;
        }
        if (++i < w2.length) {
          for (var q3 = res.sqr(); i < w2.length; i++, q3 = q3.sqr()) {
            if (w2[i] === 0) continue;
            res = res.mul(q3);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i;
        if (r2 !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r2;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r2 = bits % 26;
        var s = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q3 = 1 << r2;
        if (this.length <= s) return false;
        var w2 = this.words[s];
        return !!(w2 & q3);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r2 !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs3() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w2 = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul3;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w2 & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w2 = (this.words[i + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i + shift] = w2 & 67108863;
        }
        if (carry === 0) return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w2 = -(this.words[i] | 0) + carry;
          carry = w2 >> 26;
          this.words[i] = w2 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m = a.length - b2.length;
        var q3;
        if (mode !== "mod") {
          q3 = new BN(null);
          q3.length = m + 1;
          q3.words = new Array(q3.length);
          for (var i = 0; i < q3.length; i++) {
            q3.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b2, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q3) {
            q3.words[m] = 1;
          }
        }
        for (var j2 = m - 1; j2 >= 0; j2--) {
          var qj = (a.words[b2.length + j2] | 0) * 67108864 + (a.words[b2.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b2, qj, j2);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b2, 1, j2);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q3) {
            q3.words[j2] = qj;
          }
        }
        if (q3) {
          q3._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q3 || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div3, mod3, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div3 = res.div.neg();
          }
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.iadd(num);
            }
          }
          return {
            div: div3,
            mod: mod3
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div3 = res.div.neg();
          }
          return {
            div: div3,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod3
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div3(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod3(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod3.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w2 = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w2 / num | 0;
          carry = w2 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x2 = this;
        var y = p.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p);
        } else {
          x2 = x2.clone();
        }
        var A = new BN(1);
        var B2 = new BN(0);
        var C2 = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x2.isEven() && y.isEven()) {
          x2.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i = 0, im = 1; (x2.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x2.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B2.isOdd()) {
                A.iadd(yp);
                B2.isub(xp);
              }
              A.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            y.iushrn(j2);
            while (j2-- > 0) {
              if (C2.isOdd() || D.isOdd()) {
                C2.iadd(yp);
                D.isub(xp);
              }
              C2.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x2.cmp(y) >= 0) {
            x2.isub(y);
            A.isub(C2);
            B2.isub(D);
          } else {
            y.isub(x2);
            C2.isub(A);
            D.isub(B2);
          }
        }
        return {
          a: C2,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b2 = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b2.clone();
        while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            b2.iushrn(j2);
            while (j2-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b2) >= 0) {
            a.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b2 = num.clone();
        a.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a.isEven() && b2.isEven(); shift++) {
          a.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a.cmp(b2);
          if (r2 < 0) {
            var t = a;
            a = b2;
            b2 = t;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd3() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q3 = 1 << r2;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q3;
          return this;
        }
        var carry = q3;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w2 = this.words[i] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i] = w2;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b2 = num.words[i] | 0;
          if (a === b2) continue;
          if (a < b2) {
            res = -1;
          } else if (a > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt2(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i = 0; i < num.length; i++) {
          var w2 = num.words[i] | 0;
          lo2 += w2 * 977;
          num.words[i] = lo2 & 67108863;
          lo2 = w2 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi3 = (num.words[i] | 0) * 19 + carry;
          var lo2 = hi3 & 67108863;
          hi3 >>>= 26;
          num.words[i] = lo2;
          carry = hi3;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b2) {
        assert((a.negative | b2.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add4(a, b2) {
        this._verify2(a, b2);
        var res = a.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b2) {
        this._verify2(a, b2);
        var res = a.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub3(a, b2) {
        this._verify2(a, b2);
        var res = a.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b2) {
        this._verify2(a, b2);
        var res = a.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.imul(b2));
      };
      Red.prototype.mul = function mul3(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.mul(b2));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt3(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q3 = this.m.subn(1);
        var s = 0;
        while (!q3.isZero() && q3.andln(1) === 0) {
          s++;
          q3.iushrn(1);
        }
        assert(!q3.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q3);
        var r2 = this.pow(a, q3.addn(1).iushrn(1));
        var t = this.pow(a, q3);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b2 = this.pow(c, new BN(1).iushln(m - i - 1));
          r2 = r2.redMul(b2);
          c = b2.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j2 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b2) {
        if (a.isZero() || b2.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a, b2) {
        if (a.isZero() || b2.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// ../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r2 = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r2;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// ../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_db();
  }
});

// ../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports2, module2) {
    "use strict";
    module2.exports = defer;
    function defer(fn3) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn3);
      } else {
        setTimeout(fn3, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports2, module2) {
    "use strict";
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports2, module2) {
    "use strict";
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean2.bind(state));
      state.jobs = {};
    }
    function clean2(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    "use strict";
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b2) {
          return sortMethod(list[a], list[b2]);
        });
      }
      return initState;
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    "use strict";
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b2) {
      return a < b2 ? -1 : a > b2 ? 1 : 0;
    }
    function descending(a, b2) {
      return -1 * ascending(a, b2);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports2, module2) {
    "use strict";
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// ../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign3(number2) {
      if ($isNaN(number2) || number2 === 0) {
        return number2;
      }
      return number2 < 0 ? -1 : 1;
    };
  }
});

// ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// ../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max3 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b2) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j2 = 0; j2 < b2.length; j2 += 1) {
        arr[j2 + a.length] = b2[j2];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j2 = 0; i < arrLike.length; i += 1, j2 += 1) {
        arr[j2] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max3(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// ../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O2) {
      return reflectGetProto(O2);
    } : originalGetProto ? function getProto(O2) {
      if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O2);
    } : getDunderProto ? function getProto(O2) {
      return getDunderProto(O2);
    } : null;
  }
});

// ../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs3 = require_abs();
    var floor3 = require_floor();
    var max3 = require_max();
    var min3 = require_min();
    var pow3 = require_pow();
    var round3 = require_round();
    var sign3 = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs3,
      "%Math.floor%": floor3,
      "%Math.max%": max3,
      "%Math.min%": min3,
      "%Math.pow%": pow3,
      "%Math.round%": round3,
      "%Math.sign%": sign3,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn3 = doEval2("%AsyncGeneratorFunction%");
        if (fn3) {
          value = fn3.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string2) {
      var first = $strSlice(string2, 0, 1);
      var last = $strSlice(string2, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string2, rePropName, function(match, number2, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// ../../node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "../../node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module2.exports = function setToStringTag(object2, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag && (overrideIfSet || !hasOwn(object2, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object2, toStringTag, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object2[toStringTag] = value;
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/form-data@4.0.2/node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "../../node_modules/.pnpm/form-data@4.0.2/node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// ../../node_modules/.pnpm/form-data@4.0.2/node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "../../node_modules/.pnpm/form-data@4.0.2/node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs2 = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var populate = require_populate();
    module2.exports = FormData2;
    util.inherits(FormData2, CombinedStream);
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (Object.prototype.hasOwnProperty.call(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs2.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (Object.prototype.hasOwnProperty.call(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (Object.prototype.hasOwnProperty.call(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData2, "FormData");
  }
});

// ../../node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "../../node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w2 = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w2;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns2 of split) {
          if (ns2[0] === "-") {
            createDebug.skips.push(ns2.slice(1));
          } else {
            createDebug.names.push(ns2);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns2 of createDebug.names) {
          if (matchesTemplate(name, ns2)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min3 = forceColor || 0;
      if (env.TERM === "dumb") {
        return min3;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign3) => sign3 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min3;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min3;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log4;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k2) => {
        return k2.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log4(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../node_modules/.pnpm/follow-redirects@1.15.9/node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../node_modules/.pnpm/follow-redirects@1.15.9/node_modules/follow-redirects/debug.js"(exports2, module2) {
    "use strict";
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../../node_modules/.pnpm/follow-redirects@1.15.9/node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../node_modules/.pnpm/follow-redirects@1.15.9/node_modules/follow-redirects/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop2;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b2) {
        return this._currentRequest[method](a, b2);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get2(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get2, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop2() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base2) {
      return useNativeURL ? new URL2(relative, base2) : parseUrl(url.resolve(base2, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop2);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// ../../node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/schemas/PriceFeed.js
var require_PriceFeed = __commonJS({
  "../../node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/schemas/PriceFeed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Convert = void 0;
    var Convert = class {
      static toPriceFeed(json) {
        return cast(json, r2("PriceFeed"));
      }
      static priceFeedToJson(value) {
        return uncast(value, r2("PriceFeed"));
      }
      static toPrice(json) {
        return cast(json, r2("Price"));
      }
      static priceToJson(value) {
        return uncast(value, r2("Price"));
      }
      static toPriceFeedMetadata(json) {
        return cast(json, r2("PriceFeedMetadata"));
      }
      static priceFeedMetadataToJson(value) {
        return uncast(value, r2("PriceFeedMetadata"));
      }
    };
    exports2.Convert = Convert;
    function invalidValue(typ, val, key = "") {
      if (key) {
        throw Error(`Invalid value for key "${key}". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
      }
      throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
    }
    function jsonToJSProps(typ) {
      if (typ.jsonToJS === void 0) {
        const map = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
      }
      return typ.jsonToJS;
    }
    function jsToJSONProps(typ) {
      if (typ.jsToJSON === void 0) {
        const map = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
      }
      return typ.jsToJSON;
    }
    function transform2(val, typ, getProps, key = "") {
      function transformPrimitive(typ2, val2) {
        if (typeof typ2 === typeof val2)
          return val2;
        return invalidValue(typ2, val2, key);
      }
      function transformUnion(typs, val2) {
        const l = typs.length;
        for (let i = 0; i < l; i++) {
          const typ2 = typs[i];
          try {
            return transform2(val2, typ2, getProps);
          } catch (_) {
          }
        }
        return invalidValue(typs, val2);
      }
      function transformEnum(cases, val2) {
        if (cases.indexOf(val2) !== -1)
          return val2;
        return invalidValue(cases, val2);
      }
      function transformArray(typ2, val2) {
        if (!Array.isArray(val2))
          return invalidValue("array", val2);
        return val2.map((el2) => transform2(el2, typ2, getProps));
      }
      function transformDate(val2) {
        if (val2 === null) {
          return null;
        }
        const d = new Date(val2);
        if (isNaN(d.valueOf())) {
          return invalidValue("Date", val2);
        }
        return d;
      }
      function transformObject(props, additional, val2) {
        if (val2 === null || typeof val2 !== "object" || Array.isArray(val2)) {
          return invalidValue("object", val2);
        }
        const result = {};
        Object.getOwnPropertyNames(props).forEach((key2) => {
          const prop = props[key2];
          const v = Object.prototype.hasOwnProperty.call(val2, key2) ? val2[key2] : void 0;
          result[prop.key] = transform2(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val2).forEach((key2) => {
          if (!Object.prototype.hasOwnProperty.call(props, key2)) {
            result[key2] = transform2(val2[key2], additional, getProps, key2);
          }
        });
        return result;
      }
      if (typ === "any")
        return val;
      if (typ === null) {
        if (val === null)
          return val;
        return invalidValue(typ, val);
      }
      if (typ === false)
        return invalidValue(typ, val);
      while (typeof typ === "object" && typ.ref !== void 0) {
        typ = typeMap[typ.ref];
      }
      if (Array.isArray(typ))
        return transformEnum(typ, val);
      if (typeof typ === "object") {
        return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val) : typ.hasOwnProperty("arrayItems") ? transformArray(typ.arrayItems, val) : typ.hasOwnProperty("props") ? transformObject(getProps(typ), typ.additional, val) : invalidValue(typ, val);
      }
      if (typ === Date && typeof val !== "number")
        return transformDate(val);
      return transformPrimitive(typ, val);
    }
    function cast(val, typ) {
      return transform2(val, typ, jsonToJSProps);
    }
    function uncast(val, typ) {
      return transform2(val, typ, jsToJSONProps);
    }
    function u(...typs) {
      return { unionMembers: typs };
    }
    function o(props, additional) {
      return { props, additional };
    }
    function r2(name) {
      return { ref: name };
    }
    var typeMap = {
      PriceFeed: o([
        { json: "ema_price", js: "ema_price", typ: r2("Price") },
        { json: "id", js: "id", typ: "" },
        {
          json: "metadata",
          js: "metadata",
          typ: u(void 0, r2("PriceFeedMetadata"))
        },
        { json: "price", js: "price", typ: r2("Price") },
        { json: "vaa", js: "vaa", typ: u(void 0, "") }
      ], "any"),
      Price: o([
        { json: "conf", js: "conf", typ: "" },
        { json: "expo", js: "expo", typ: 0 },
        { json: "price", js: "price", typ: "" },
        { json: "publish_time", js: "publish_time", typ: 0 }
      ], "any"),
      PriceFeedMetadata: o([
        {
          json: "attestation_time",
          js: "attestation_time",
          typ: u(void 0, 0)
        },
        { json: "emitter_chain", js: "emitter_chain", typ: 0 },
        {
          json: "prev_publish_time",
          js: "prev_publish_time",
          typ: u(void 0, 0)
        },
        {
          json: "price_service_receive_time",
          js: "price_service_receive_time",
          typ: u(void 0, 0)
        },
        { json: "sequence_number", js: "sequence_number", typ: u(void 0, 0) },
        { json: "slot", js: "slot", typ: u(void 0, 0) }
      ], "any")
    };
  }
});

// ../../node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/AccumulatorUpdateData.js
var require_AccumulatorUpdateData = __commonJS({
  "../../node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/AccumulatorUpdateData.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAccumulatorUpdateData = exports2.sliceAccumulatorUpdateData = exports2.parseTwapMessage = exports2.parsePriceFeedMessage = exports2.isAccumulatorUpdateData = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var ACCUMULATOR_MAGIC = "504e4155";
    var MAJOR_VERSION = 1;
    var MINOR_VERSION = 0;
    var KECCAK160_HASH_SIZE = 20;
    var PRICE_FEED_MESSAGE_VARIANT = 0;
    var TWAP_MESSAGE_VARIANT = 1;
    function isAccumulatorUpdateData(updateBytes) {
      return updateBytes.toString("hex").slice(0, 8) === ACCUMULATOR_MAGIC && updateBytes[4] === MAJOR_VERSION && updateBytes[5] === MINOR_VERSION;
    }
    exports2.isAccumulatorUpdateData = isAccumulatorUpdateData;
    function parsePriceFeedMessage(message) {
      let cursor = 0;
      const variant = message.readUInt8(cursor);
      if (variant !== PRICE_FEED_MESSAGE_VARIANT) {
        throw new Error("Not a price feed message");
      }
      cursor += 1;
      const feedId = message.subarray(cursor, cursor + 32);
      cursor += 32;
      const price = new bn_js_1.default(message.subarray(cursor, cursor + 8), "be");
      cursor += 8;
      const confidence = new bn_js_1.default(message.subarray(cursor, cursor + 8), "be");
      cursor += 8;
      const exponent = message.readInt32BE(cursor);
      cursor += 4;
      const publishTime = new bn_js_1.default(message.subarray(cursor, cursor + 8), "be");
      cursor += 8;
      const prevPublishTime = new bn_js_1.default(message.subarray(cursor, cursor + 8), "be");
      cursor += 8;
      const emaPrice = new bn_js_1.default(message.subarray(cursor, cursor + 8), "be");
      cursor += 8;
      const emaConf = new bn_js_1.default(message.subarray(cursor, cursor + 8), "be");
      cursor += 8;
      return {
        feedId,
        price,
        confidence,
        exponent,
        publishTime,
        prevPublishTime,
        emaPrice,
        emaConf
      };
    }
    exports2.parsePriceFeedMessage = parsePriceFeedMessage;
    function parseTwapMessage(message) {
      let cursor = 0;
      const variant = message.readUInt8(cursor);
      if (variant !== TWAP_MESSAGE_VARIANT) {
        throw new Error("Not a twap message");
      }
      cursor += 1;
      const feedId = message.subarray(cursor, cursor + 32);
      cursor += 32;
      const cumulativePrice = new bn_js_1.default(message.subarray(cursor, cursor + 16), "be");
      cursor += 16;
      const cumulativeConf = new bn_js_1.default(message.subarray(cursor, cursor + 16), "be");
      cursor += 16;
      const numDownSlots = new bn_js_1.default(message.subarray(cursor, cursor + 8), "be");
      cursor += 8;
      const exponent = message.readInt32BE(cursor);
      cursor += 4;
      const publishTime = new bn_js_1.default(message.subarray(cursor, cursor + 8), "be");
      cursor += 8;
      const prevPublishTime = new bn_js_1.default(message.subarray(cursor, cursor + 8), "be");
      cursor += 8;
      const publishSlot = new bn_js_1.default(message.subarray(cursor, cursor + 8), "be");
      cursor += 8;
      return {
        feedId,
        cumulativePrice,
        cumulativeConf,
        numDownSlots,
        exponent,
        publishTime,
        prevPublishTime,
        publishSlot
      };
    }
    exports2.parseTwapMessage = parseTwapMessage;
    function sliceAccumulatorUpdateData(data, start, end) {
      if (!isAccumulatorUpdateData(data)) {
        throw new Error("Invalid accumulator message");
      }
      let cursor = 6;
      const trailingPayloadSize = data.readUint8(cursor);
      cursor += 1 + trailingPayloadSize;
      cursor += 1;
      const vaaSize = data.readUint16BE(cursor);
      cursor += 2;
      cursor += vaaSize;
      const endOfVaa = cursor;
      const updates = [];
      const numUpdates = data.readUInt8(cursor);
      cursor += 1;
      for (let i = 0; i < numUpdates; i++) {
        const updateStart = cursor;
        const messageSize = data.readUint16BE(cursor);
        cursor += 2;
        cursor += messageSize;
        const numProofs = data.readUInt8(cursor);
        cursor += 1;
        cursor += KECCAK160_HASH_SIZE * numProofs;
        updates.push(data.subarray(updateStart, cursor));
      }
      if (cursor !== data.length) {
        throw new Error("Didn't reach the end of the message");
      }
      const sliceUpdates = updates.slice(start, end);
      return Buffer.concat([
        data.subarray(0, endOfVaa),
        Buffer.from([sliceUpdates.length]),
        ...updates.slice(start, end)
      ]);
    }
    exports2.sliceAccumulatorUpdateData = sliceAccumulatorUpdateData;
    function parseAccumulatorUpdateData(data) {
      if (!isAccumulatorUpdateData(data)) {
        throw new Error("Invalid accumulator message");
      }
      let cursor = 6;
      const trailingPayloadSize = data.readUint8(cursor);
      cursor += 1 + trailingPayloadSize;
      cursor += 1;
      const vaaSize = data.readUint16BE(cursor);
      cursor += 2;
      const vaa = data.subarray(cursor, cursor + vaaSize);
      cursor += vaaSize;
      const numUpdates = data.readUInt8(cursor);
      const updates = [];
      cursor += 1;
      for (let i = 0; i < numUpdates; i++) {
        const messageSize = data.readUint16BE(cursor);
        cursor += 2;
        const message = data.subarray(cursor, cursor + messageSize);
        cursor += messageSize;
        const numProofs = data.readUInt8(cursor);
        cursor += 1;
        const proof = [];
        for (let j2 = 0; j2 < numProofs; j2++) {
          proof.push(Array.from(data.subarray(cursor, cursor + KECCAK160_HASH_SIZE)));
          cursor += KECCAK160_HASH_SIZE;
        }
        updates.push({ message, proof });
      }
      if (cursor !== data.length) {
        throw new Error("Didn't reach the end of the message");
      }
      return { vaa, updates };
    }
    exports2.parseAccumulatorUpdateData = parseAccumulatorUpdateData;
  }
});

// ../../node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PriceFeed = exports2.PriceFeedMetadata = exports2.Price = exports2.parseTwapMessage = exports2.parsePriceFeedMessage = exports2.parseAccumulatorUpdateData = exports2.sliceAccumulatorUpdateData = exports2.isAccumulatorUpdateData = void 0;
    var PriceFeed_1 = require_PriceFeed();
    var AccumulatorUpdateData_1 = require_AccumulatorUpdateData();
    Object.defineProperty(exports2, "isAccumulatorUpdateData", { enumerable: true, get: function() {
      return AccumulatorUpdateData_1.isAccumulatorUpdateData;
    } });
    Object.defineProperty(exports2, "sliceAccumulatorUpdateData", { enumerable: true, get: function() {
      return AccumulatorUpdateData_1.sliceAccumulatorUpdateData;
    } });
    Object.defineProperty(exports2, "parseAccumulatorUpdateData", { enumerable: true, get: function() {
      return AccumulatorUpdateData_1.parseAccumulatorUpdateData;
    } });
    Object.defineProperty(exports2, "parsePriceFeedMessage", { enumerable: true, get: function() {
      return AccumulatorUpdateData_1.parsePriceFeedMessage;
    } });
    Object.defineProperty(exports2, "parseTwapMessage", { enumerable: true, get: function() {
      return AccumulatorUpdateData_1.parseTwapMessage;
    } });
    var Price = class _Price {
      constructor(rawPrice) {
        __publicField(this, "conf");
        __publicField(this, "expo");
        __publicField(this, "price");
        __publicField(this, "publishTime");
        this.conf = rawPrice.conf;
        this.expo = rawPrice.expo;
        this.price = rawPrice.price;
        this.publishTime = rawPrice.publishTime;
      }
      /**
       * Get price as number. Warning: this conversion might result in an inaccurate number.
       * We store price and confidence values in our Oracle at 64-bit precision, but the JavaScript
       * number type can only represent numbers with 52-bit precision. So if a price or confidence
       * is larger than 52-bits, the conversion will lose the most insignificant bits.
       *
       * @returns a floating point number representing the price
       */
      getPriceAsNumberUnchecked() {
        return Number(this.price) * 10 ** this.expo;
      }
      /**
       * Get price as number. Warning: this conversion might result in an inaccurate number.
       * Explanation is the same as `priceAsNumberUnchecked()` documentation.
       *
       * @returns a floating point number representing the price
       */
      getConfAsNumberUnchecked() {
        return Number(this.conf) * 10 ** this.expo;
      }
      static fromJson(json) {
        const jsonPrice = PriceFeed_1.Convert.toPrice(json);
        return new _Price({
          conf: jsonPrice.conf,
          expo: jsonPrice.expo,
          price: jsonPrice.price,
          publishTime: jsonPrice.publish_time
        });
      }
      toJson() {
        const jsonPrice = {
          conf: this.conf,
          expo: this.expo,
          price: this.price,
          publish_time: this.publishTime
        };
        return PriceFeed_1.Convert.priceToJson(jsonPrice);
      }
    };
    exports2.Price = Price;
    var PriceFeedMetadata = class _PriceFeedMetadata {
      constructor(metadata) {
        /**
         * Attestation time of the price
         */
        __publicField(this, "attestationTime");
        /**
         * Chain of the emitter
         */
        __publicField(this, "emitterChain");
        /**
         * The time that the price service received the price
         */
        __publicField(this, "priceServiceReceiveTime");
        /**
         * Sequence number of the price
         */
        __publicField(this, "sequenceNumber");
        /**
         * Pythnet slot number of the price
         */
        __publicField(this, "slot");
        /**
         * The time that the previous price was published
         */
        __publicField(this, "prevPublishTime");
        this.attestationTime = metadata.attestationTime;
        this.emitterChain = metadata.emitterChain;
        this.priceServiceReceiveTime = metadata.receiveTime;
        this.sequenceNumber = metadata.sequenceNumber;
        this.slot = metadata.slot;
        this.prevPublishTime = metadata.prevPublishTime;
      }
      static fromJson(json) {
        if (json === void 0) {
          return void 0;
        }
        const jsonFeed = PriceFeed_1.Convert.toPriceFeedMetadata(json);
        return new _PriceFeedMetadata({
          attestationTime: jsonFeed.attestation_time,
          emitterChain: jsonFeed.emitter_chain,
          receiveTime: jsonFeed.price_service_receive_time,
          sequenceNumber: jsonFeed.sequence_number,
          slot: jsonFeed.slot,
          prevPublishTime: jsonFeed.prev_publish_time
        });
      }
      toJson() {
        const jsonFeed = {
          attestation_time: this.attestationTime,
          emitter_chain: this.emitterChain,
          price_service_receive_time: this.priceServiceReceiveTime,
          sequence_number: this.sequenceNumber,
          slot: this.slot,
          prev_publish_time: this.prevPublishTime
        };
        return PriceFeed_1.Convert.priceFeedMetadataToJson(jsonFeed);
      }
    };
    exports2.PriceFeedMetadata = PriceFeedMetadata;
    var PriceFeed = class _PriceFeed {
      constructor(rawFeed) {
        /**
         * Exponentially-weighted moving average Price
         */
        __publicField(this, "emaPrice");
        /**
         * Unique identifier for this price.
         */
        __publicField(this, "id");
        /**
         * Metadata of the price
         */
        __publicField(this, "metadata");
        /**
         * VAA of the price
         */
        __publicField(this, "vaa");
        /**
         * Price
         */
        __publicField(this, "price");
        this.emaPrice = rawFeed.emaPrice;
        this.id = rawFeed.id;
        this.metadata = rawFeed.metadata;
        this.vaa = rawFeed.vaa;
        this.price = rawFeed.price;
      }
      static fromJson(json) {
        const jsonFeed = PriceFeed_1.Convert.toPriceFeed(json);
        return new _PriceFeed({
          emaPrice: Price.fromJson(jsonFeed.ema_price),
          id: jsonFeed.id,
          metadata: PriceFeedMetadata.fromJson(jsonFeed.metadata),
          vaa: jsonFeed.vaa,
          price: Price.fromJson(jsonFeed.price)
        });
      }
      toJson() {
        var _a7;
        const jsonFeed = {
          ema_price: this.emaPrice.toJson(),
          id: this.id,
          metadata: (_a7 = this.metadata) == null ? void 0 : _a7.toJson(),
          price: this.price.toJson()
        };
        return PriceFeed_1.Convert.priceFeedToJson(jsonFeed);
      }
      /**
       * Get the price and confidence interval as fixed-point numbers of the form a * 10^e.
       * This function returns the current best estimate of the price at the time that this `PriceFeed` was
       * published (`publishTime`). The returned price can be from arbitrarily far in the past; this function
       * makes no guarantees that the returned price is recent or useful for any particular application.
       *
       * Users of this function should check the returned `publishTime` to ensure that the returned price is
       * sufficiently recent for their application. If you are considering using this function, it may be
       * safer / easier to use `getPriceNoOlderThan` method.
       *
       * @returns a Price that contains the price and confidence interval along with
       * the exponent for them, and publish time of the price.
       */
      getPriceUnchecked() {
        return this.price;
      }
      /**
       * Get the exponentially-weighted moving average (EMA) price and confidence interval.
       *
       * This function returns the current best estimate of the price at the time that this `PriceFeed` was
       * published (`publishTime`). The returned price can be from arbitrarily far in the past; this function
       * makes no guarantees that the returned price is recent or useful for any particular application.
       *
       * Users of this function should check the returned `publishTime` to ensure that the returned price is
       * sufficiently recent for their application. If you are considering using this function, it may be
       * safer / easier to use `getEmaPriceNoOlderThan` method.
       *
       * At the moment, the confidence interval returned by this method is computed in
       * a somewhat questionable way, so we do not recommend using it for high-value applications.
       *
       * @returns a Price that contains the EMA price and confidence interval along with
       * the exponent for them, and publish time of the price.
       */
      getEmaPriceUnchecked() {
        return this.emaPrice;
      }
      /**
       * Get the price if it was updated no older than `age` seconds of the current time.
       *
       * This function is a sanity-checked version of `getPriceUnchecked` which is useful in
       * applications that require a sufficiently-recent price. Returns `undefined` if the price
       * is not recent enough.
       *
       * @param age return a price as long as it has been updated within this number of seconds
       * @returns a Price struct containing the price, confidence interval along with the exponent for
       * both numbers, and its publish time, or `undefined` if no price update occurred within `age` seconds of the current time.
       */
      getPriceNoOlderThan(age) {
        const price = this.getPriceUnchecked();
        const currentTime = Math.floor(Date.now() / 1e3);
        if (Math.abs(currentTime - price.publishTime) > age) {
          return void 0;
        }
        return price;
      }
      /**
       * Get the exponentially-weighted moving average (EMA) price if it was updated no older than
       * `age` seconds of the current time.
       *
       * This function is a sanity-checked version of `getEmaPriceUnchecked` which is useful in
       * applications that require a sufficiently-recent price. Returns `undefined` if the price
       * is not recent enough.
       *
       * At the moment, the confidence interval returned by this method is computed in
       * a somewhat questionable way, so we do not recommend using it for high-value applications.
       *
       * @param age return a price as long as it has been updated within this number of seconds
       * @returns a Price struct containing the EMA price, confidence interval along with the exponent for
       * both numbers, and its publish time, or `undefined` if no price update occurred within `age` seconds of the current time.
       */
      getEmaPriceNoOlderThan(age) {
        const emaPrice = this.getEmaPriceUnchecked();
        const currentTime = Math.floor(Date.now() / 1e3);
        if (Math.abs(currentTime - emaPrice.publishTime) > age) {
          return void 0;
        }
        return emaPrice;
      }
      /**
       * Get the price feed metadata.
       *
       * @returns a struct containing the attestation time, emitter chain, and the sequence number.
       * Returns `undefined` if metadata is currently unavailable.
       */
      getMetadata() {
        return this.metadata;
      }
      /**
       * Get the price feed vaa.
       *
       * @returns vaa in base64.
       * Returns `undefined` if vaa is unavailable.
       */
      getVAA() {
        return this.vaa;
      }
    };
    exports2.PriceFeed = PriceFeed;
  }
});

// ../../node_modules/.pnpm/axios@1.9.0/node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS({
  "../../node_modules/.pnpm/axios@1.9.0/node_modules/axios/dist/node/axios.cjs"(exports2, module2) {
    "use strict";
    var FormData$1 = require_form_data();
    var crypto2 = require("crypto");
    var url = require("url");
    var proxyFromEnv = require_proxy_from_env();
    var http = require("http");
    var https = require("https");
    var util = require("util");
    var followRedirects = require_follow_redirects();
    var zlib = require("zlib");
    var stream = require("stream");
    var events = require("events");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto2);
    var url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
    var proxyFromEnv__default = /* @__PURE__ */ _interopDefaultLegacy(proxyFromEnv);
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
    function bind(fn3, thisArg) {
      return function wrap() {
        return fn3.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var { iterator, toStringTag } = Symbol;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber2 = typeOfTest("number");
    var isObject2 = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject2 = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    var isDate2 = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject2(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach2(obj, fn3, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn3.call(null, obj[i], i, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn3.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject2(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach2(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
      forEach2(b2, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber2(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn3) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn3.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty2 = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach2(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop2 = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject2(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach2(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction(_global.postMessage)
    );
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber: isNumber2,
      isBoolean,
      isObject: isObject2,
      isPlainObject: isPlainObject2,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate: isDate2,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach: forEach2,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty: hasOwnProperty2,
      hasOwnProp: hasOwnProperty2,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop: noop2,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    function AxiosError(message, code, config3, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config3 && (this.config = config3);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config3, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config3, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path) return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData__default["default"] || FormData)();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el2, index) {
              !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el2)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el2, key) {
          const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
            formData,
            el2,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el2, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      }
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn3) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn3(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams2 = url__default["default"].URLSearchParams;
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET2 = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET2.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      const randomValues = new Uint32Array(size);
      crypto__default["default"].randomFillSync(randomValues);
      for (let i = 0; i < size; i++) {
        str += alphabet[randomValues[i] % length];
      }
      return str;
    };
    var platform$1 = {
      isNode: true,
      classes: {
        URLSearchParams: URLSearchParams2,
        FormData: FormData__default["default"],
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      ALPHABET: ALPHABET2,
      generateString,
      protocols: ["http", "https", "file", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = __spreadValues(__spreadValues({}, utils), platform$1);
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value)) return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config3 = this || defaults$1;
      const context = response || config3;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform2(fn3) {
        data = fn3.call(config3, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config3, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config3, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var VERSION = "1.9.0";
    function parseProtocol(url2) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match && match[1] || "";
    }
    var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
    function fromDataURI(uri, asBlob, options) {
      const _Blob = options && options.Blob || platform.classes.Blob;
      const protocol = parseProtocol(uri);
      if (asBlob === void 0 && _Blob) {
        asBlob = true;
      }
      if (protocol === "data") {
        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
        const match = DATA_URL_PATTERN.exec(uri);
        if (!match) {
          throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
        }
        const mime = match[1];
        const isBase64 = match[2];
        const body = match[3];
        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
        if (asBlob) {
          if (!_Blob) {
            throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
          }
          return new _Blob([buffer], { type: mime });
        }
        return buffer;
      }
      throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
    }
    var kInternals = Symbol("internals");
    var AxiosTransformStream = class extends stream__default["default"].Transform {
      constructor(options) {
        options = utils$1.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils$1.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const internals = this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk2, encoding, callback) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit("progress", internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk2, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
    };
    var AxiosTransformStream$1 = AxiosTransformStream;
    var { asyncIterator } = Symbol;
    var readBlob = function(blob) {
      return __asyncGenerator(this, null, function* () {
        if (blob.stream) {
          yield* __yieldStar(blob.stream());
        } else if (blob.arrayBuffer) {
          yield yield new __await(blob.arrayBuffer());
        } else if (blob[asyncIterator]) {
          yield* __yieldStar(blob[asyncIterator]());
        } else {
          yield blob;
        }
      });
    };
    var readBlob$1 = readBlob;
    var BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
    var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util__default["default"].TextEncoder();
    var CRLF = "\r\n";
    var CRLF_BYTES = textEncoder.encode(CRLF);
    var CRLF_BYTES_COUNT = 2;
    var FormDataPart = class {
      constructor(name, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils$1.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name;
        this.value = value;
      }
      encode() {
        return __asyncGenerator(this, null, function* () {
          yield this.headers;
          const { value } = this;
          if (utils$1.isTypedArray(value)) {
            yield value;
          } else {
            yield* __yieldStar(readBlob$1(value));
          }
          yield CRLF_BYTES;
        });
      }
      static escapeName(name) {
        return String(name).replace(/[\r\n"]/g, (match) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match]);
      }
    };
    var formDataToStream = (form, headersHandler, options) => {
      const {
        tag: tag3 = "form-data-boundary",
        size = 25,
        boundary = tag3 + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils$1.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary.length < 1 || boundary.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name, value]) => {
        const part = new FormDataPart(name, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils$1.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return stream.Readable.from(function() {
        return __asyncGenerator(this, null, function* () {
          for (const part of parts) {
            yield boundaryBytes;
            yield* __yieldStar(part.encode());
          }
          yield footerBytes;
        });
      }());
    };
    var formDataToStream$1 = formDataToStream;
    var ZlibHeaderTransformStream = class extends stream__default["default"].Transform {
      __transform(chunk2, encoding, callback) {
        this.push(chunk2);
        callback();
      }
      _transform(chunk2, encoding, callback) {
        if (chunk2.length !== 0) {
          this._transform = this.__transform;
          if (chunk2[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk2, encoding, callback);
      }
    };
    var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
    var callbackify = (fn3, reducer) => {
      return utils$1.isAsyncFn(fn3) ? function(...args) {
        const cb = args.pop();
        fn3.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn3;
    };
    var callbackify$1 = callbackify;
    function speedometer(samplesCount, min3) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min3 = min3 !== void 0 ? min3 : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min3) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn3, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn3.apply(null, args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn3) => (...args) => utils$1.asap(() => fn3(...args));
    var zlibOptions = {
      flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
      finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
    };
    var brotliOptions = {
      flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
    };
    var isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
    var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
    var isHttps = /https:?/;
    var supportedProtocols = platform.protocols.map((protocol) => {
      return protocol + ":";
    });
    var flushOnFinish = (stream2, [throttled, flush]) => {
      stream2.on("end", flush).on("error", flush);
      return throttled;
    };
    function dispatchBeforeRedirect(options, responseDetails) {
      if (options.beforeRedirects.proxy) {
        options.beforeRedirects.proxy(options);
      }
      if (options.beforeRedirects.config) {
        options.beforeRedirects.config(options, responseDetails);
      }
    }
    function setProxy(options, configProxy, location) {
      let proxy = configProxy;
      if (!proxy && proxy !== false) {
        const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
        if (proxyUrl) {
          proxy = new URL(proxyUrl);
        }
      }
      if (proxy) {
        if (proxy.username) {
          proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
        }
        if (proxy.auth) {
          if (proxy.auth.username || proxy.auth.password) {
            proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
          }
          const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
          options.headers["Proxy-Authorization"] = "Basic " + base64;
        }
        options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
        const proxyHost = proxy.hostname || proxy.host;
        options.hostname = proxyHost;
        options.host = proxyHost;
        options.port = proxy.port;
        options.path = location;
        if (proxy.protocol) {
          options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
        }
      }
      options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
        setProxy(redirectOptions, configProxy, redirectOptions.href);
      };
    }
    var isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
    var wrapAsync = (asyncExecutor) => {
      return new Promise((resolve, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone) return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    var resolveFamily = ({ address, family }) => {
      if (!utils$1.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    var buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
    var httpAdapter = isHttpAdapterSupported && function httpAdapter2(config3) {
      return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
        let { data, lookup, family } = config3;
        const { responseType, responseEncoding } = config3;
        const method = config3.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        if (lookup) {
          const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
          lookup = (hostname, opt, cb) => {
            _lookup(hostname, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const emitter = new events.EventEmitter();
        const onFinished = () => {
          if (config3.cancelToken) {
            config3.cancelToken.unsubscribe(abort);
          }
          if (config3.signal) {
            config3.signal.removeEventListener("abort", abort);
          }
          emitter.removeAllListeners();
        };
        onDone((value, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
          }
        });
        function abort(reason) {
          emitter.emit("abort", !reason || reason.type ? new CanceledError(null, config3, req) : reason);
        }
        emitter.once("abort", reject);
        if (config3.cancelToken || config3.signal) {
          config3.cancelToken && config3.cancelToken.subscribe(abort);
          if (config3.signal) {
            config3.signal.aborted ? abort() : config3.signal.addEventListener("abort", abort);
          }
        }
        const fullPath = buildFullPath(config3.baseURL, config3.url, config3.allowAbsoluteUrls);
        const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          let convertedData;
          if (method !== "GET") {
            return settle(resolve, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config: config3
            });
          }
          try {
            convertedData = fromDataURI(config3.url, responseType === "blob", {
              Blob: config3.env && config3.env.Blob
            });
          } catch (err) {
            throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config3);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils$1.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream__default["default"].Readable.from(convertedData);
          }
          return settle(resolve, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders$1(),
            config: config3
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config3
          ));
        }
        const headers = AxiosHeaders$1.from(config3.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const { onUploadProgress, onDownloadProgress } = config3;
        const maxRate = config3.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils$1.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream$1(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await util__default["default"].promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = stream__default["default"].Readable.from(readBlob$1(data));
        } else if (data && !utils$1.isStream(data)) {
          if (Buffer.isBuffer(data)) ;
          else if (utils$1.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils$1.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config3
            ));
          }
          headers.setContentLength(data.length, false);
          if (config3.maxBodyLength > -1 && data.length > config3.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config3
            ));
          }
        }
        const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
        if (utils$1.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils$1.isStream(data)) {
            data = stream__default["default"].Readable.from(data, { objectMode: false });
          }
          data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
            maxRate: utils$1.toFiniteNumber(maxUploadRate)
          })], utils$1.noop);
          onUploadProgress && data.on("progress", flushOnFinish(
            data,
            progressEventDecorator(
              contentLength,
              progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
            )
          ));
        }
        let auth = void 0;
        if (config3.auth) {
          const username = config3.auth.username || "";
          const password = config3.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path;
        try {
          path = buildURL(
            parsed.pathname + parsed.search,
            config3.params,
            config3.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config3;
          customErr.url = config3.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path,
          method,
          headers: headers.toJSON(),
          agents: { http: config3.httpAgent, https: config3.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {}
        };
        !utils$1.isUndefined(lookup) && (options.lookup = lookup);
        if (config3.socketPath) {
          options.socketPath = config3.socketPath;
        } else {
          options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config3.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config3.httpsAgent : config3.httpAgent;
        if (config3.transport) {
          transport = config3.transport;
        } else if (config3.maxRedirects === 0) {
          transport = isHttpsRequest ? https__default["default"] : http__default["default"];
        } else {
          if (config3.maxRedirects) {
            options.maxRedirects = config3.maxRedirects;
          }
          if (config3.beforeRedirect) {
            options.beforeRedirects.config = config3.beforeRedirect;
          }
          transport = isHttpsRequest ? httpsFollow : httpFollow;
        }
        if (config3.maxBodyLength > -1) {
          options.maxBodyLength = config3.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config3.insecureHTTPParser) {
          options.insecureHTTPParser = config3.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed) return;
          const streams = [res];
          const responseLength = +res.headers["content-length"];
          if (onDownloadProgress || maxDownloadRate) {
            const transformStream = new AxiosTransformStream$1({
              maxRate: utils$1.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", flushOnFinish(
              transformStream,
              progressEventDecorator(
                responseLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
              )
            ));
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config3.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              /*eslint default-case:0*/
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream$1());
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
          const offListeners = stream__default["default"].finished(responseStream, () => {
            offListeners();
            onFinished();
          });
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders$1(res.headers),
            config: config3,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk2) {
              responseBuffer.push(chunk2);
              totalResponseBytes += chunk2.length;
              if (config3.maxContentLength > -1 && totalResponseBytes > config3.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                reject(new AxiosError(
                  "maxContentLength size of " + config3.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config3,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError(
                "stream has been aborted",
                AxiosError.ERR_BAD_RESPONSE,
                config3,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed) return;
              reject(AxiosError.from(err, null, config3, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils$1.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError.from(err, null, config3, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
          emitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        emitter.once("abort", (err) => {
          reject(err);
          req.destroy(err);
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config3, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config3.timeout) {
          const timeout = parseInt(config3.timeout, 10);
          if (Number.isNaN(timeout)) {
            reject(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config3,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone) return;
            let timeoutErrorMessage = config3.timeout ? "timeout of " + config3.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config3.transitional || transitionalDefaults;
            if (config3.timeoutErrorMessage) {
              timeoutErrorMessage = config3.timeoutErrorMessage;
            }
            reject(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config3,
              req
            ));
            abort();
          });
        }
        if (utils$1.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError("Request stream has been aborted", config3, req));
            }
          });
          data.pipe(req);
        } else {
          req.end(data);
        }
      });
    };
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
      url2 = new URL(url2, platform.origin);
      return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? __spreadValues({}, thing) : thing;
    function mergeConfig(config1, config22) {
      config22 = config22 || {};
      const config3 = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b2, prop, caseless) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(a, b2, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b2) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        }
      }
      function defaultToConfig2(a, b2) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b2, prop) {
        if (prop in config22) {
          return getMergedValue(a, b2);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b2, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b2), prop, true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config22)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config22[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    }
    var resolveConfig = (config3) => {
      const newConfig = mergeConfig({}, config3);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config3.params, config3.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      let contentType;
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if ((contentType = headers.getContentType()) !== false) {
          const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
          headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config3) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config3);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config3,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config3, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config3, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config3,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config3, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config3));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk2, chunkSize) {
      let len = chunk2.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk2;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk2.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = function(iterable, chunkSize) {
      return __asyncGenerator(this, null, function* () {
        try {
          for (var iter = __forAwait(readStream(iterable)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const chunk2 = temp.value;
            yield* __yieldStar(streamChunk(chunk2, chunkSize));
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      });
    };
    var readStream = function(stream2) {
      return __asyncGenerator(this, null, function* () {
        if (stream2[Symbol.asyncIterator]) {
          yield* __yieldStar(stream2);
          return;
        }
        const reader = stream2.getReader();
        try {
          for (; ; ) {
            const { done, value } = yield new __await(reader.read());
            if (done) {
              break;
            }
            yield value;
          }
        } finally {
          yield new __await(reader.cancel());
        }
      });
    };
    var trackStream = (stream2, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream2, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
    var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
    var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
    var test = (fn3, ...args) => {
      try {
        return !!fn3(...args);
      } catch (e) {
        return false;
      }
    };
    var supportsRequestStream = isReadableStreamSupported && test(() => {
      let duplexAccessed = false;
      const hasContentType = new Request(platform.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
      return duplexAccessed && !hasContentType;
    });
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
    var resolvers = {
      stream: supportsResponseStream && ((res) => res.body)
    };
    isFetchSupported && ((res) => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
        !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config3) => {
          throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config3);
        });
      });
    })(new Response());
    var getBodyLength = async (body) => {
      if (body == null) {
        return 0;
      }
      if (utils$1.isBlob(body)) {
        return body.size;
      }
      if (utils$1.isSpecCompliantForm(body)) {
        const _request = new Request(platform.origin, {
          method: "POST",
          body
        });
        return (await _request.arrayBuffer()).byteLength;
      }
      if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
        return body.byteLength;
      }
      if (utils$1.isURLSearchParams(body)) {
        body = body + "";
      }
      if (utils$1.isString(body)) {
        return (await encodeText(body)).byteLength;
      }
    };
    var resolveBodyLength = async (headers, body) => {
      const length = utils$1.toFiniteNumber(headers.getContentLength());
      return length == null ? getBodyLength(body) : length;
    };
    var fetchAdapter = isFetchSupported && (async (config3) => {
      let {
        url: url2,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions
      } = resolveConfig(config3);
      responseType = responseType ? (responseType + "").toLowerCase() : "text";
      let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
      let request;
      const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
        composedSignal.unsubscribe();
      });
      let requestContentLength;
      try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
          let _request = new Request(url2, {
            method: "POST",
            body: data,
            duplex: "half"
          });
          let contentTypeHeader;
          if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            const [onProgress, flush] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress))
            );
            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
          }
        }
        if (!utils$1.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }
        const isCredentialsSupported = "credentials" in Request.prototype;
        request = new Request(url2, __spreadProps(__spreadValues({}, fetchOptions), {
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: isCredentialsSupported ? withCredentials : void 0
        }));
        let response = await fetch(request);
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
          const options = {};
          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });
          const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
          const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
            responseContentLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true)
          ) || [];
          response = new Response(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush && flush();
              unsubscribe && unsubscribe();
            }),
            options
          );
        }
        responseType = responseType || "text";
        let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config3);
        !isStreamResponse && unsubscribe && unsubscribe();
        return await new Promise((resolve, reject) => {
          settle(resolve, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config: config3,
            request
          });
        });
      } catch (err) {
        unsubscribe && unsubscribe();
        if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
          throw Object.assign(
            new AxiosError("Network Error", AxiosError.ERR_NETWORK, config3, request),
            {
              cause: err.cause || err
            }
          );
        }
        throw AxiosError.from(err, err && err.code, config3, request);
      }
    });
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: fetchAdapter
    };
    utils$1.forEach(knownAdapters, (fn3, value) => {
      if (fn3) {
        try {
          Object.defineProperty(fn3, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn3, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config3) {
      if (config3.cancelToken) {
        config3.cancelToken.throwIfRequested();
      }
      if (config3.signal && config3.signal.aborted) {
        throw new CanceledError(null, config3);
      }
    }
    function dispatchRequest(config3) {
      throwIfCancellationRequested(config3);
      config3.headers = AxiosHeaders$1.from(config3.headers);
      config3.data = transformData.call(
        config3,
        config3.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config3.method) !== -1) {
        config3.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config3.adapter || defaults$1.adapter);
      return adapter(config3).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config3);
        response.data = transformData.call(
          config3,
          config3.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config3);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config3,
              config3.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config3) {
        try {
          return await this._request(configOrUrl, config3);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config3) {
        if (typeof configOrUrl === "string") {
          config3 = config3 || {};
          config3.url = configOrUrl;
        } else {
          config3 = configOrUrl || {};
        }
        config3 = mergeConfig(this.defaults, config3);
        const { transitional, paramsSerializer, headers } = config3;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config3.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config3.allowAbsoluteUrls !== void 0) ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config3.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config3.allowAbsoluteUrls = true;
        }
        validator.assertOptions(config3, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config3.method = (config3.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config3.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config3.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config3) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config3);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config3;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config3) {
        config3 = mergeConfig(this.defaults, config3);
        const fullPath = buildFullPath(config3.baseURL, config3.url, config3.allowAbsoluteUrls);
        return buildURL(fullPath, config3.params, config3.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config3) {
        return this.request(mergeConfig(config3 || {}, {
          method,
          url: url2,
          data: (config3 || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config3) {
          return this.request(mergeConfig(config3 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config3, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config3, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create2(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module2.exports = axios;
  }
});

// ../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports2, module2) {
    "use strict";
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : {
        "default": e
      };
    }
    module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/typeof.js"(exports2, module2) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return module2.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof(o);
    }
    module2.exports = _typeof, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports2, module2) {
    "use strict";
    var _typeof = require_typeof()["default"];
    function _regeneratorRuntime() {
      "use strict";
      module2.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return r2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      var t, r2 = {}, e = Object.prototype, n = e.hasOwnProperty, o = "function" == typeof Symbol ? Symbol : {}, i = o.iterator || "@@iterator", a = o.asyncIterator || "@@asyncIterator", u = o.toStringTag || "@@toStringTag";
      function c(t2, r3, e2, n2) {
        return Object.defineProperty(t2, r3, {
          value: e2,
          enumerable: !n2,
          configurable: !n2,
          writable: !n2
        });
      }
      try {
        c({}, "");
      } catch (t2) {
        c = function c2(t3, r3, e2) {
          return t3[r3] = e2;
        };
      }
      function h(r3, e2, n2, o2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype);
        return c(a2, "_invoke", /* @__PURE__ */ function(r4, e3, n3) {
          var o3 = 1;
          return function(i3, a3) {
            if (3 === o3) throw Error("Generator is already running");
            if (4 === o3) {
              if ("throw" === i3) throw a3;
              return {
                value: t,
                done: true
              };
            }
            for (n3.method = i3, n3.arg = a3; ; ) {
              var u2 = n3.delegate;
              if (u2) {
                var c2 = d(u2, n3);
                if (c2) {
                  if (c2 === f) continue;
                  return c2;
                }
              }
              if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
              else if ("throw" === n3.method) {
                if (1 === o3) throw o3 = 4, n3.arg;
                n3.dispatchException(n3.arg);
              } else "return" === n3.method && n3.abrupt("return", n3.arg);
              o3 = 3;
              var h2 = s(r4, e3, n3);
              if ("normal" === h2.type) {
                if (o3 = n3.done ? 4 : 2, h2.arg === f) continue;
                return {
                  value: h2.arg,
                  done: n3.done
                };
              }
              "throw" === h2.type && (o3 = 4, n3.method = "throw", n3.arg = h2.arg);
            }
          };
        }(r3, n2, new Context(o2 || [])), true), a2;
      }
      function s(t2, r3, e2) {
        try {
          return {
            type: "normal",
            arg: t2.call(r3, e2)
          };
        } catch (t3) {
          return {
            type: "throw",
            arg: t3
          };
        }
      }
      r2.wrap = h;
      var f = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var l = {};
      c(l, i, function() {
        return this;
      });
      var p = Object.getPrototypeOf, y = p && p(p(x2([])));
      y && y !== e && n.call(y, i) && (l = y);
      var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l);
      function g(t2) {
        ["next", "throw", "return"].forEach(function(r3) {
          c(t2, r3, function(t3) {
            return this._invoke(r3, t3);
          });
        });
      }
      function AsyncIterator(t2, r3) {
        function e2(o3, i2, a2, u2) {
          var c2 = s(t2[o3], t2, i2);
          if ("throw" !== c2.type) {
            var h2 = c2.arg, f2 = h2.value;
            return f2 && "object" == _typeof(f2) && n.call(f2, "__await") ? r3.resolve(f2.__await).then(function(t3) {
              e2("next", t3, a2, u2);
            }, function(t3) {
              e2("throw", t3, a2, u2);
            }) : r3.resolve(f2).then(function(t3) {
              h2.value = t3, a2(h2);
            }, function(t3) {
              return e2("throw", t3, a2, u2);
            });
          }
          u2(c2.arg);
        }
        var o2;
        c(this, "_invoke", function(t3, n2) {
          function i2() {
            return new r3(function(r4, o3) {
              e2(t3, n2, r4, o3);
            });
          }
          return o2 = o2 ? o2.then(i2, i2) : i2();
        }, true);
      }
      function d(r3, e2) {
        var n2 = e2.method, o2 = r3.i[n2];
        if (o2 === t) return e2.delegate = null, "throw" === n2 && r3.i["return"] && (e2.method = "return", e2.arg = t, d(r3, e2), "throw" === e2.method) || "return" !== n2 && (e2.method = "throw", e2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), f;
        var i2 = s(o2, r3.i, e2.arg);
        if ("throw" === i2.type) return e2.method = "throw", e2.arg = i2.arg, e2.delegate = null, f;
        var a2 = i2.arg;
        return a2 ? a2.done ? (e2[r3.r] = a2.value, e2.next = r3.n, "return" !== e2.method && (e2.method = "next", e2.arg = t), e2.delegate = null, f) : a2 : (e2.method = "throw", e2.arg = new TypeError("iterator result is not an object"), e2.delegate = null, f);
      }
      function w2(t2) {
        this.tryEntries.push(t2);
      }
      function m(r3) {
        var e2 = r3[4] || {};
        e2.type = "normal", e2.arg = t, r3[4] = e2;
      }
      function Context(t2) {
        this.tryEntries = [[-1]], t2.forEach(w2, this), this.reset(true);
      }
      function x2(r3) {
        if (null != r3) {
          var e2 = r3[i];
          if (e2) return e2.call(r3);
          if ("function" == typeof r3.next) return r3;
          if (!isNaN(r3.length)) {
            var o2 = -1, a2 = function e3() {
              for (; ++o2 < r3.length; ) if (n.call(r3, o2)) return e3.value = r3[o2], e3.done = false, e3;
              return e3.value = t, e3.done = true, e3;
            };
            return a2.next = a2;
          }
        }
        throw new TypeError(_typeof(r3) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = c(GeneratorFunctionPrototype, u, "GeneratorFunction"), r2.isGeneratorFunction = function(t2) {
        var r3 = "function" == typeof t2 && t2.constructor;
        return !!r3 && (r3 === GeneratorFunction || "GeneratorFunction" === (r3.displayName || r3.name));
      }, r2.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, c(t2, u, "GeneratorFunction")), t2.prototype = Object.create(v), t2;
      }, r2.awrap = function(t2) {
        return {
          __await: t2
        };
      }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function() {
        return this;
      }), r2.AsyncIterator = AsyncIterator, r2.async = function(t2, e2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(h(t2, e2, n2, o2), i2);
        return r2.isGeneratorFunction(e2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, g(v), c(v, u, "Generator"), c(v, i, function() {
        return this;
      }), c(v, "toString", function() {
        return "[object Generator]";
      }), r2.keys = function(t2) {
        var r3 = Object(t2), e2 = [];
        for (var n2 in r3) e2.unshift(n2);
        return function t3() {
          for (; e2.length; ) if ((n2 = e2.pop()) in r3) return t3.value = n2, t3.done = false, t3;
          return t3.done = true, t3;
        };
      }, r2.values = x2, Context.prototype = {
        constructor: Context,
        reset: function reset(r3) {
          if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r3) for (var e2 in this) "t" === e2.charAt(0) && n.call(this, e2) && !isNaN(+e2.slice(1)) && (this[e2] = t);
        },
        stop: function stop() {
          this.done = true;
          var t2 = this.tryEntries[0][4];
          if ("throw" === t2.type) throw t2.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(r3) {
          if (this.done) throw r3;
          var e2 = this;
          function n2(t2) {
            a2.type = "throw", a2.arg = r3, e2.next = t2;
          }
          for (var o2 = e2.tryEntries.length - 1; o2 >= 0; --o2) {
            var i2 = this.tryEntries[o2], a2 = i2[4], u2 = this.prev, c2 = i2[1], h2 = i2[2];
            if (-1 === i2[0]) return n2("end"), false;
            if (!c2 && !h2) throw Error("try statement without catch or finally");
            if (null != i2[0] && i2[0] <= u2) {
              if (u2 < c2) return this.method = "next", this.arg = t, n2(c2), true;
              if (u2 < h2) return n2(h2), false;
            }
          }
        },
        abrupt: function abrupt(t2, r3) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var n2 = this.tryEntries[e2];
            if (n2[0] > -1 && n2[0] <= this.prev && this.prev < n2[2]) {
              var o2 = n2;
              break;
            }
          }
          o2 && ("break" === t2 || "continue" === t2) && o2[0] <= r3 && r3 <= o2[2] && (o2 = null);
          var i2 = o2 ? o2[4] : {};
          return i2.type = t2, i2.arg = r3, o2 ? (this.method = "next", this.next = o2[2], f) : this.complete(i2);
        },
        complete: function complete(t2, r3) {
          if ("throw" === t2.type) throw t2.arg;
          return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && r3 && (this.next = r3), f;
        },
        finish: function finish(t2) {
          for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
            var e2 = this.tryEntries[r3];
            if (e2[2] === t2) return this.complete(e2[4], e2[3]), m(e2), f;
          }
        },
        "catch": function _catch(t2) {
          for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
            var e2 = this.tryEntries[r3];
            if (e2[0] === t2) {
              var n2 = e2[4];
              if ("throw" === n2.type) {
                var o2 = n2.arg;
                m(e2);
              }
              return o2;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(r3, e2, n2) {
          return this.delegate = {
            i: x2(r3),
            r: e2,
            n: n2
          }, "next" === this.method && (this.arg = t), f;
        }
      }, r2;
    }
    module2.exports = _regeneratorRuntime, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/regenerator/index.js"(exports2, module2) {
    "use strict";
    var runtime = require_regeneratorRuntime()();
    module2.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// ../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(n, t, e, r2, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r2, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r2, o) {
          var a = n.apply(t, e);
          function _next2(n2) {
            asyncGeneratorStep(a, r2, o, _next2, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r2, o, _next2, _throw, "throw", n2);
          }
          _next2(void 0);
        });
      };
    }
    module2.exports = _asyncToGenerator, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/toPrimitive.js"(exports2, module2) {
    "use strict";
    var _typeof = require_typeof()["default"];
    function toPrimitive3(t, r2) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r2 || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t);
    }
    module2.exports = toPrimitive3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports2, module2) {
    "use strict";
    var _typeof = require_typeof()["default"];
    var toPrimitive3 = require_toPrimitive();
    function toPropertyKey3(t) {
      var i = toPrimitive3(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    module2.exports = toPropertyKey3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/defineProperty.js"(exports2, module2) {
    "use strict";
    var toPropertyKey3 = require_toPropertyKey();
    function _defineProperty4(e, r2, t) {
      return (r2 = toPropertyKey3(r2)) in e ? Object.defineProperty(e, r2, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r2] = t, e;
    }
    module2.exports = _defineProperty4, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/.pnpm/is-retry-allowed@2.2.0/node_modules/is-retry-allowed/index.js
var require_is_retry_allowed = __commonJS({
  "../../node_modules/.pnpm/is-retry-allowed@2.2.0/node_modules/is-retry-allowed/index.js"(exports2, module2) {
    "use strict";
    var denyList = /* @__PURE__ */ new Set([
      "ENOTFOUND",
      "ENETUNREACH",
      // SSL errors from https://github.com/nodejs/node/blob/fc8e3e2cdc521978351de257030db0076d79e0ab/src/crypto/crypto_common.cc#L301-L328
      "UNABLE_TO_GET_ISSUER_CERT",
      "UNABLE_TO_GET_CRL",
      "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
      "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
      "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
      "CERT_SIGNATURE_FAILURE",
      "CRL_SIGNATURE_FAILURE",
      "CERT_NOT_YET_VALID",
      "CERT_HAS_EXPIRED",
      "CRL_NOT_YET_VALID",
      "CRL_HAS_EXPIRED",
      "ERROR_IN_CERT_NOT_BEFORE_FIELD",
      "ERROR_IN_CERT_NOT_AFTER_FIELD",
      "ERROR_IN_CRL_LAST_UPDATE_FIELD",
      "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
      "OUT_OF_MEM",
      "DEPTH_ZERO_SELF_SIGNED_CERT",
      "SELF_SIGNED_CERT_IN_CHAIN",
      "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
      "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
      "CERT_CHAIN_TOO_LONG",
      "CERT_REVOKED",
      "INVALID_CA",
      "PATH_LENGTH_EXCEEDED",
      "INVALID_PURPOSE",
      "CERT_UNTRUSTED",
      "CERT_REJECTED",
      "HOSTNAME_MISMATCH"
    ]);
    module2.exports = (error) => !denyList.has(error && error.code);
  }
});

// ../../node_modules/.pnpm/axios-retry@3.9.1/node_modules/axios-retry/lib/cjs/index.js
var require_cjs2 = __commonJS({
  "../../node_modules/.pnpm/axios-retry@3.9.1/node_modules/axios-retry/lib/cjs/index.js"(exports2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isNetworkError = isNetworkError;
    exports2.isRetryableError = isRetryableError;
    exports2.isSafeRequestError = isSafeRequestError;
    exports2.isIdempotentRequestError = isIdempotentRequestError;
    exports2.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
    exports2.exponentialDelay = exponentialDelay;
    exports2.default = axiosRetry;
    exports2.DEFAULT_OPTIONS = exports2.namespace = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _defineProperty22 = _interopRequireDefault(require_defineProperty());
    var _isRetryAllowed = _interopRequireDefault(require_is_retry_allowed());
    function ownKeys4(object2, enumerableOnly) {
      var keys = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys4(Object(source), true).forEach(function(key) {
            (0, _defineProperty22.default)(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys4(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    var namespace = "axios-retry";
    exports2.namespace = namespace;
    function isNetworkError(error) {
      var CODE_EXCLUDE_LIST = ["ERR_CANCELED", "ECONNABORTED"];
      return !error.response && Boolean(error.code) && // Prevents retrying cancelled requests
      !CODE_EXCLUDE_LIST.includes(error.code) && // Prevents retrying timed out & cancelled requests
      (0, _isRetryAllowed.default)(error);
    }
    var SAFE_HTTP_METHODS = ["get", "head", "options"];
    var IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(["put", "delete"]);
    function isRetryableError(error) {
      return error.code !== "ECONNABORTED" && (!error.response || error.response.status >= 500 && error.response.status <= 599);
    }
    function isSafeRequestError(error) {
      if (!error.config) {
        return false;
      }
      return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;
    }
    function isIdempotentRequestError(error) {
      if (!error.config) {
        return false;
      }
      return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;
    }
    function isNetworkOrIdempotentRequestError(error) {
      return isNetworkError(error) || isIdempotentRequestError(error);
    }
    function noDelay() {
      return 0;
    }
    function exponentialDelay() {
      var retryNumber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var error = arguments.length > 1 ? arguments[1] : void 0;
      var delayFactor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 100;
      var delay = Math.pow(2, retryNumber) * delayFactor;
      var randomSum = delay * 0.2 * Math.random();
      return delay + randomSum;
    }
    var DEFAULT_OPTIONS = {
      retries: 3,
      retryCondition: isNetworkOrIdempotentRequestError,
      retryDelay: noDelay,
      shouldResetTimeout: false,
      onRetry: function onRetry() {
      }
    };
    exports2.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
    function getRequestOptions(config3, defaultOptions) {
      return _objectSpread3(_objectSpread3(_objectSpread3({}, DEFAULT_OPTIONS), defaultOptions), config3[namespace]);
    }
    function getCurrentState(config3, defaultOptions) {
      var currentState = getRequestOptions(config3, defaultOptions);
      currentState.retryCount = currentState.retryCount || 0;
      config3[namespace] = currentState;
      return currentState;
    }
    function fixConfig(axios, config3) {
      if (axios.defaults.agent === config3.agent) {
        delete config3.agent;
      }
      if (axios.defaults.httpAgent === config3.httpAgent) {
        delete config3.httpAgent;
      }
      if (axios.defaults.httpsAgent === config3.httpsAgent) {
        delete config3.httpsAgent;
      }
    }
    function shouldRetry(_x, _x2) {
      return _shouldRetry.apply(this, arguments);
    }
    function _shouldRetry() {
      _shouldRetry = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(currentState, error) {
        var retries, retryCondition, shouldRetryOrPromise, shouldRetryPromiseResult;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                retries = currentState.retries, retryCondition = currentState.retryCondition;
                shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error);
                if (!((0, _typeof2.default)(shouldRetryOrPromise) === "object")) {
                  _context2.next = 13;
                  break;
                }
                _context2.prev = 3;
                _context2.next = 6;
                return shouldRetryOrPromise;
              case 6:
                shouldRetryPromiseResult = _context2.sent;
                return _context2.abrupt("return", shouldRetryPromiseResult !== false);
              case 10:
                _context2.prev = 10;
                _context2.t0 = _context2["catch"](3);
                return _context2.abrupt("return", false);
              case 13:
                return _context2.abrupt("return", shouldRetryOrPromise);
              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[3, 10]]);
      }));
      return _shouldRetry.apply(this, arguments);
    }
    function axiosRetry(axios, defaultOptions) {
      var requestInterceptorId = axios.interceptors.request.use(function(config3) {
        var currentState = getCurrentState(config3, defaultOptions);
        currentState.lastRequestTime = Date.now();
        return config3;
      });
      var responseInterceptorId = axios.interceptors.response.use(null, /* @__PURE__ */ function() {
        var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(error) {
          var config3, currentState, retryDelay, shouldResetTimeout, onRetry, delay, lastRequestDuration, timeout;
          return _regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  config3 = error.config;
                  if (config3) {
                    _context.next = 3;
                    break;
                  }
                  return _context.abrupt("return", Promise.reject(error));
                case 3:
                  currentState = getCurrentState(config3, defaultOptions);
                  _context.next = 6;
                  return shouldRetry(currentState, error);
                case 6:
                  if (!_context.sent) {
                    _context.next = 21;
                    break;
                  }
                  currentState.retryCount += 1;
                  retryDelay = currentState.retryDelay, shouldResetTimeout = currentState.shouldResetTimeout, onRetry = currentState.onRetry;
                  delay = retryDelay(currentState.retryCount, error);
                  fixConfig(axios, config3);
                  if (!(!shouldResetTimeout && config3.timeout && currentState.lastRequestTime)) {
                    _context.next = 17;
                    break;
                  }
                  lastRequestDuration = Date.now() - currentState.lastRequestTime;
                  timeout = config3.timeout - lastRequestDuration - delay;
                  if (!(timeout <= 0)) {
                    _context.next = 16;
                    break;
                  }
                  return _context.abrupt("return", Promise.reject(error));
                case 16:
                  config3.timeout = timeout;
                case 17:
                  config3.transformRequest = [function(data) {
                    return data;
                  }];
                  _context.next = 20;
                  return onRetry(currentState.retryCount, error, config3);
                case 20:
                  return _context.abrupt("return", new Promise(function(resolve) {
                    return setTimeout(function() {
                      return resolve(axios(config3));
                    }, delay);
                  }));
                case 21:
                  return _context.abrupt("return", Promise.reject(error));
                case 22:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return function(_x3) {
          return _ref.apply(this, arguments);
        };
      }());
      return {
        requestInterceptorId,
        responseInterceptorId
      };
    }
    axiosRetry.isNetworkError = isNetworkError;
    axiosRetry.isSafeRequestError = isSafeRequestError;
    axiosRetry.isIdempotentRequestError = isIdempotentRequestError;
    axiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
    axiosRetry.exponentialDelay = exponentialDelay;
    axiosRetry.isRetryableError = isRetryableError;
  }
});

// ../../node_modules/.pnpm/axios-retry@3.9.1/node_modules/axios-retry/index.js
var require_axios_retry = __commonJS({
  "../../node_modules/.pnpm/axios-retry@3.9.1/node_modules/axios-retry/index.js"(exports2, module2) {
    "use strict";
    var axiosRetry = require_cjs2().default;
    module2.exports = axiosRetry;
    module2.exports.default = axiosRetry;
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob) BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer2, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer2;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw(__spreadProps(__spreadValues({}, this._options.zlibInflateOptions), {
            windowBits
          }));
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw(__spreadProps(__spreadValues({}, this._options.zlibDeflateOptions), {
            windowBits
          }));
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk2) {
      this[kBuffers].push(chunk2);
      this[kTotalLength] += chunk2.length;
    }
    function inflateOnData(chunk2) {
      this[kTotalLength] += chunk2.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk2);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      if (this[kError]) {
        this[kCallback](this[kError]);
        return;
      }
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk2, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk2.length;
        this._buffers.push(chunk2);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver;
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
    var { isBlob, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(_Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {(Buffer | String)[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function") cb(err);
      for (let i = 0; i < sender._queue.length; i++) {
        const params = sender._queue[i];
        const callback = params[params.length - 1];
        if (typeof callback === "function") callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event2 = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event2.prototype, "target", { enumerable: true });
    Object.defineProperty(Event2.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event2 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event2 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event2 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary3) {
            const event = new MessageEvent("message", {
              data: isBinary3 ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event2("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event: Event2,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse3(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1) start = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k2) => {
              let values = params[k2];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k2 : `${k2}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse: parse3 };
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var { isBlob } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse: parse3 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = __spreadValues({
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true
        }, options);
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = __spreadProps(__spreadValues({
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10
      }, options), {
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      });
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = __spreadProps(__spreadValues({}, opts.headers), {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      });
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = __spreadProps(__spreadValues({}, options), { headers: {} });
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse3(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob(data) ? data.size : toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary3) {
      this[kWebSocket].emit("message", data, isBinary3);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket2.CLOSED) return;
      if (websocket.readyState === WebSocket2.OPEN) {
        websocket._readyState = WebSocket2.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk2;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk2 = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk2);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk2) {
      if (!this[kWebSocket]._receiver.write(chunk2)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex(__spreadProps(__spreadValues({}, options), {
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      }));
      ws.on("message", function message(msg, isBinary3) {
        const data = !isBinary3 && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk2, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk2, encoding, callback);
          });
          return;
        }
        ws.send(chunk2, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse3(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse: parse3 };
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = __spreadValues({
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2
        }, options);
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = __spreadValues({
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message)
      }, headers);
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// ../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/index.js
var require_ws = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.2/node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    WebSocket2.createWebSocketStream = require_stream();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module2.exports = WebSocket2;
  }
});

// ../../node_modules/.pnpm/isomorphic-ws@4.0.1_ws@8.18.2/node_modules/isomorphic-ws/node.js
var require_node2 = __commonJS({
  "../../node_modules/.pnpm/isomorphic-ws@4.0.1_ws@8.18.2/node_modules/isomorphic-ws/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_ws();
  }
});

// ../../node_modules/.pnpm/@pythnetwork+price-service-client@1.9.0/node_modules/@pythnetwork/price-service-client/lib/ResillientWebSocket.js
var require_ResillientWebSocket = __commonJS({
  "../../node_modules/.pnpm/@pythnetwork+price-service-client@1.9.0/node_modules/@pythnetwork/price-service-client/lib/ResillientWebSocket.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResilientWebSocket = void 0;
    var isomorphic_ws_1 = __importDefault(require_node2());
    var PING_TIMEOUT_DURATION = 3e4 + 3e3;
    var ResilientWebSocket = class {
      constructor(endpoint, logger) {
        __publicField(this, "endpoint");
        __publicField(this, "wsClient");
        __publicField(this, "wsUserClosed");
        __publicField(this, "wsFailedAttempts");
        __publicField(this, "pingTimeout");
        __publicField(this, "logger");
        __publicField(this, "onError");
        __publicField(this, "onMessage");
        __publicField(this, "onReconnect");
        this.endpoint = endpoint;
        this.logger = logger;
        this.wsFailedAttempts = 0;
        this.onError = (error) => {
          var _a7;
          (_a7 = this.logger) == null ? void 0 : _a7.error(error);
        };
        this.wsUserClosed = true;
        this.onMessage = () => {
        };
        this.onReconnect = () => {
        };
      }
      async send(data) {
        var _a7, _b3, _c;
        (_a7 = this.logger) == null ? void 0 : _a7.info(`Sending ${data}`);
        await this.waitForMaybeReadyWebSocket();
        if (this.wsClient === void 0) {
          (_b3 = this.logger) == null ? void 0 : _b3.error("Couldn't connect to the websocket server. Error callback is called.");
        } else {
          (_c = this.wsClient) == null ? void 0 : _c.send(data);
        }
      }
      async startWebSocket() {
        var _a7;
        if (this.wsClient !== void 0) {
          return;
        }
        (_a7 = this.logger) == null ? void 0 : _a7.info(`Creating Web Socket client`);
        this.wsClient = new isomorphic_ws_1.default(this.endpoint);
        this.wsUserClosed = false;
        this.wsClient.onopen = () => {
          this.wsFailedAttempts = 0;
          if (this.wsClient.on !== void 0) {
            this.heartbeat();
          }
        };
        this.wsClient.onerror = (event) => {
          this.onError(event.error);
        };
        this.wsClient.onmessage = (event) => {
          this.onMessage(event.data);
        };
        this.wsClient.onclose = async () => {
          var _a8, _b3;
          if (this.pingTimeout !== void 0) {
            clearInterval(this.pingTimeout);
          }
          if (this.wsUserClosed === false) {
            this.wsFailedAttempts += 1;
            this.wsClient = void 0;
            const waitTime = expoBackoff(this.wsFailedAttempts);
            (_a8 = this.logger) == null ? void 0 : _a8.error(`Connection closed unexpectedly or because of timeout. Reconnecting after ${waitTime}ms.`);
            await sleep(waitTime);
            this.restartUnexpectedClosedWebsocket();
          } else {
            (_b3 = this.logger) == null ? void 0 : _b3.info("The connection has been closed successfully.");
          }
        };
        if (this.wsClient.on !== void 0) {
          this.wsClient.on("ping", this.heartbeat.bind(this));
        }
      }
      /**
       * Heartbeat is only enabled in node clients because they support handling
       * ping-pong events.
       *
       * This approach only works when server constantly pings the clients which.
       * Otherwise you might consider sending ping and acting on pong responses
       * yourself.
       */
      heartbeat() {
        var _a7;
        (_a7 = this.logger) == null ? void 0 : _a7.info("Heartbeat");
        if (this.pingTimeout !== void 0) {
          clearTimeout(this.pingTimeout);
        }
        this.pingTimeout = setTimeout(() => {
          var _a8, _b3;
          (_a8 = this.logger) == null ? void 0 : _a8.warn(`Connection timed out. Reconnecting...`);
          (_b3 = this.wsClient) == null ? void 0 : _b3.terminate();
          this.restartUnexpectedClosedWebsocket();
        }, PING_TIMEOUT_DURATION);
      }
      async waitForMaybeReadyWebSocket() {
        let waitedTime = 0;
        while (this.wsClient !== void 0 && this.wsClient.readyState !== this.wsClient.OPEN) {
          if (waitedTime > 5e3) {
            this.wsClient.close();
            return;
          } else {
            waitedTime += 10;
            await sleep(10);
          }
        }
      }
      async restartUnexpectedClosedWebsocket() {
        var _a7;
        if (this.wsUserClosed === true) {
          return;
        }
        await this.startWebSocket();
        await this.waitForMaybeReadyWebSocket();
        if (this.wsClient === void 0) {
          (_a7 = this.logger) == null ? void 0 : _a7.error("Couldn't reconnect to websocket. Error callback is called.");
          return;
        }
        this.onReconnect();
      }
      closeWebSocket() {
        if (this.wsClient !== void 0) {
          const client = this.wsClient;
          this.wsClient = void 0;
          client.close();
        }
        this.wsUserClosed = true;
      }
    };
    exports2.ResilientWebSocket = ResilientWebSocket;
    async function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    function expoBackoff(attempts) {
      return 2 ** attempts * 100;
    }
  }
});

// ../../node_modules/.pnpm/@pythnetwork+price-service-client@1.9.0/node_modules/@pythnetwork/price-service-client/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/@pythnetwork+price-service-client@1.9.0/node_modules/@pythnetwork/price-service-client/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeLeading0xIfExists = exports2.makeWebsocketUrl = void 0;
    function makeWebsocketUrl(endpoint) {
      const url = new URL("ws", endpoint);
      const useHttps = url.protocol === "https:";
      url.protocol = useHttps ? "wss:" : "ws:";
      return url.toString();
    }
    exports2.makeWebsocketUrl = makeWebsocketUrl;
    function removeLeading0xIfExists(id) {
      if (id.startsWith("0x")) {
        return id.substring(2);
      } else {
        return id;
      }
    }
    exports2.removeLeading0xIfExists = removeLeading0xIfExists;
  }
});

// ../../node_modules/.pnpm/@pythnetwork+price-service-client@1.9.0/node_modules/@pythnetwork/price-service-client/lib/PriceServiceConnection.js
var require_PriceServiceConnection = __commonJS({
  "../../node_modules/.pnpm/@pythnetwork+price-service-client@1.9.0/node_modules/@pythnetwork/price-service-client/lib/PriceServiceConnection.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PriceServiceConnection = void 0;
    var price_service_sdk_1 = require_lib();
    var axios_1 = __importDefault(require_axios());
    var axios_retry_1 = __importDefault(require_axios_retry());
    var ResillientWebSocket_1 = require_ResillientWebSocket();
    var utils_1 = require_utils();
    var PriceServiceConnection = class {
      /**
       * Constructs a new Connection.
       *
       * @param endpoint endpoint URL to the price service. Example: https://website/example/
       * @param config Optional PriceServiceConnectionConfig for custom configurations.
       */
      constructor(endpoint, config3) {
        __publicField(this, "httpClient");
        __publicField(this, "priceFeedCallbacks");
        __publicField(this, "wsClient");
        __publicField(this, "wsEndpoint");
        __publicField(this, "logger");
        __publicField(this, "priceFeedRequestConfig");
        /**
         * Custom handler for web socket errors (connection and message parsing).
         *
         * Default handler only logs the errors.
         */
        __publicField(this, "onWsError");
        var _a7, _b3, _c, _d;
        this.httpClient = axios_1.default.create({
          baseURL: endpoint,
          timeout: (config3 == null ? void 0 : config3.timeout) || 5e3
        });
        (0, axios_retry_1.default)(this.httpClient, {
          retries: (config3 == null ? void 0 : config3.httpRetries) || 3,
          retryDelay: axios_retry_1.default.exponentialDelay
        });
        this.priceFeedRequestConfig = {
          binary: (_a7 = config3 == null ? void 0 : config3.priceFeedRequestConfig) == null ? void 0 : _a7.binary,
          verbose: (_c = (_b3 = config3 == null ? void 0 : config3.priceFeedRequestConfig) == null ? void 0 : _b3.verbose) != null ? _c : config3 == null ? void 0 : config3.verbose,
          allowOutOfOrder: (_d = config3 == null ? void 0 : config3.priceFeedRequestConfig) == null ? void 0 : _d.allowOutOfOrder
        };
        this.priceFeedCallbacks = /* @__PURE__ */ new Map();
        this.logger = (config3 == null ? void 0 : config3.logger) || {
          trace: () => {
          },
          debug: () => {
          },
          info: () => {
          },
          warn: console.warn,
          error: console.error
        };
        this.onWsError = (error) => {
          this.logger.error(error);
          if (typeof process !== "undefined" && typeof process.exit === "function") {
            this.logger.error("Halting the process due to the websocket error");
            process.exit(1);
          } else {
            this.logger.error("Cannot halt process. Please handle the websocket error.");
          }
        };
        this.wsEndpoint = (0, utils_1.makeWebsocketUrl)(endpoint);
      }
      /**
       * Fetch Latest PriceFeeds of given price ids.
       * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price ids)
       *
       * @param priceIds Array of hex-encoded price ids.
       * @returns Array of PriceFeeds
       */
      async getLatestPriceFeeds(priceIds) {
        if (priceIds.length === 0) {
          return [];
        }
        const response = await this.httpClient.get("/api/latest_price_feeds", {
          params: {
            ids: priceIds,
            verbose: this.priceFeedRequestConfig.verbose,
            binary: this.priceFeedRequestConfig.binary
          }
        });
        const priceFeedsJson = response.data;
        return priceFeedsJson.map((priceFeedJson) => price_service_sdk_1.PriceFeed.fromJson(priceFeedJson));
      }
      /**
       * Fetch latest VAA of given price ids.
       * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price ids)
       *
       * This function is coupled to wormhole implemntation.
       *
       * @param priceIds Array of hex-encoded price ids.
       * @returns Array of base64 encoded VAAs.
       */
      async getLatestVaas(priceIds) {
        const response = await this.httpClient.get("/api/latest_vaas", {
          params: {
            ids: priceIds
          }
        });
        return response.data;
      }
      /**
       * Fetch the earliest VAA of the given price id that is published since the given publish time.
       * This will throw an error if the given publish time is in the future, or if the publish time
       * is old and the price service endpoint does not have a db backend for historical requests.
       * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price id)
       *
       * This function is coupled to wormhole implemntation.
       *
       * @param priceId Hex-encoded price id.
       * @param publishTime Epoch timestamp in seconds.
       * @returns Tuple of VAA and publishTime.
       */
      async getVaa(priceId, publishTime) {
        const response = await this.httpClient.get("/api/get_vaa", {
          params: {
            id: priceId,
            publish_time: publishTime
          }
        });
        return [response.data.vaa, response.data.publishTime];
      }
      /**
       * Fetch the PriceFeed of the given price id that is published since the given publish time.
       * This will throw an error if the given publish time is in the future, or if the publish time
       * is old and the price service endpoint does not have a db backend for historical requests.
       * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price id)
       *
       * @param priceId Hex-encoded price id.
       * @param publishTime Epoch timestamp in seconds.
       * @returns PriceFeed
       */
      async getPriceFeed(priceId, publishTime) {
        const response = await this.httpClient.get("/api/get_price_feed", {
          params: {
            id: priceId,
            publish_time: publishTime,
            verbose: this.priceFeedRequestConfig.verbose,
            binary: this.priceFeedRequestConfig.binary
          }
        });
        return price_service_sdk_1.PriceFeed.fromJson(response.data);
      }
      /**
       * Fetch the list of available price feed ids.
       * This will throw an axios error if there is a network problem or the price service returns a non-ok response.
       *
       * @returns Array of hex-encoded price ids.
       */
      async getPriceFeedIds() {
        const response = await this.httpClient.get("/api/price_feed_ids");
        return response.data;
      }
      /**
       * Subscribe to updates for given price ids.
       *
       * It will start a websocket connection if it's not started yet.
       * Also, it won't throw any exception if given price ids are invalid or connection errors. Instead,
       * it calls `connection.onWsError`. If you want to handle the errors you should set the
       * `onWsError` function to your custom error handler.
       *
       * @param priceIds Array of hex-encoded price ids.
       * @param cb Callback function that is called with a PriceFeed upon updates to given price ids.
       */
      async subscribePriceFeedUpdates(priceIds, cb) {
        var _a7;
        if (this.wsClient === void 0) {
          await this.startWebSocket();
        }
        priceIds = priceIds.map((priceId) => (0, utils_1.removeLeading0xIfExists)(priceId));
        const newPriceIds = [];
        for (const id of priceIds) {
          if (!this.priceFeedCallbacks.has(id)) {
            this.priceFeedCallbacks.set(id, /* @__PURE__ */ new Set());
            newPriceIds.push(id);
          }
          this.priceFeedCallbacks.get(id).add(cb);
        }
        const message = {
          ids: newPriceIds,
          type: "subscribe",
          verbose: this.priceFeedRequestConfig.verbose,
          binary: this.priceFeedRequestConfig.binary,
          allow_out_of_order: this.priceFeedRequestConfig.allowOutOfOrder
        };
        await ((_a7 = this.wsClient) == null ? void 0 : _a7.send(JSON.stringify(message)));
      }
      /**
       * Unsubscribe from updates for given price ids.
       *
       * It will close the websocket connection if it's not subscribed to any price feed updates anymore.
       * Also, it won't throw any exception if given price ids are invalid or connection errors. Instead,
       * it calls `connection.onWsError`. If you want to handle the errors you should set the
       * `onWsError` function to your custom error handler.
       *
       * @param priceIds Array of hex-encoded price ids.
       * @param cb Optional callback, if set it will only unsubscribe this callback from updates for given price ids.
       */
      async unsubscribePriceFeedUpdates(priceIds, cb) {
        var _a7;
        if (this.wsClient === void 0) {
          await this.startWebSocket();
        }
        priceIds = priceIds.map((priceId) => (0, utils_1.removeLeading0xIfExists)(priceId));
        const removedPriceIds = [];
        for (const id of priceIds) {
          if (this.priceFeedCallbacks.has(id)) {
            let idRemoved = false;
            if (cb === void 0) {
              this.priceFeedCallbacks.delete(id);
              idRemoved = true;
            } else {
              this.priceFeedCallbacks.get(id).delete(cb);
              if (this.priceFeedCallbacks.get(id).size === 0) {
                this.priceFeedCallbacks.delete(id);
                idRemoved = true;
              }
            }
            if (idRemoved) {
              removedPriceIds.push(id);
            }
          }
        }
        const message = {
          ids: removedPriceIds,
          type: "unsubscribe"
        };
        await ((_a7 = this.wsClient) == null ? void 0 : _a7.send(JSON.stringify(message)));
        if (this.priceFeedCallbacks.size === 0) {
          this.closeWebSocket();
        }
      }
      /**
       * Starts connection websocket.
       *
       * This function is called automatically upon subscribing to price feed updates.
       */
      async startWebSocket() {
        if (this.wsEndpoint === void 0) {
          throw new Error("Websocket endpoint is undefined.");
        }
        this.wsClient = new ResillientWebSocket_1.ResilientWebSocket(this.wsEndpoint, this.logger);
        this.wsClient.onError = this.onWsError;
        this.wsClient.onReconnect = () => {
          var _a7;
          if (this.priceFeedCallbacks.size > 0) {
            const message = {
              ids: Array.from(this.priceFeedCallbacks.keys()),
              type: "subscribe",
              verbose: this.priceFeedRequestConfig.verbose,
              binary: this.priceFeedRequestConfig.binary,
              allow_out_of_order: this.priceFeedRequestConfig.allowOutOfOrder
            };
            this.logger.info("Resubscribing to existing price feeds.");
            (_a7 = this.wsClient) == null ? void 0 : _a7.send(JSON.stringify(message));
          }
        };
        this.wsClient.onMessage = (data) => {
          this.logger.info(`Received message ${data.toString()}`);
          let message;
          try {
            message = JSON.parse(data.toString());
          } catch (e) {
            this.logger.error(`Error parsing message ${data.toString()} as JSON.`);
            this.logger.error(e);
            this.onWsError(e);
            return;
          }
          if (message.type === "response") {
            if (message.status === "error") {
              this.logger.error(`Error response from the websocket server ${message.error}.`);
              this.onWsError(new Error(message.error));
            }
          } else if (message.type === "price_update") {
            let priceFeed;
            try {
              priceFeed = price_service_sdk_1.PriceFeed.fromJson(message.price_feed);
            } catch (e) {
              this.logger.error(`Error parsing price feeds from message ${data.toString()}.`);
              this.logger.error(e);
              this.onWsError(e);
              return;
            }
            if (this.priceFeedCallbacks.has(priceFeed.id)) {
              for (const cb of this.priceFeedCallbacks.get(priceFeed.id)) {
                cb(priceFeed);
              }
            }
          } else {
            this.logger.warn(`Ignoring unsupported server response ${data.toString()}.`);
          }
        };
        await this.wsClient.startWebSocket();
      }
      /**
       * Closes connection websocket.
       *
       * At termination, the websocket should be closed to finish the
       * process elegantly. It will automatically close when the connection
       * is subscribed to no price feeds.
       */
      closeWebSocket() {
        var _a7;
        (_a7 = this.wsClient) == null ? void 0 : _a7.closeWebSocket();
        this.wsClient = void 0;
        this.priceFeedCallbacks.clear();
      }
    };
    exports2.PriceServiceConnection = PriceServiceConnection;
  }
});

// ../../node_modules/.pnpm/@pythnetwork+price-service-client@1.9.0/node_modules/@pythnetwork/price-service-client/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/@pythnetwork+price-service-client@1.9.0/node_modules/@pythnetwork/price-service-client/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAccumulatorUpdateData = exports2.isAccumulatorUpdateData = exports2.Price = exports2.PriceFeed = exports2.PriceFeedMetadata = exports2.PriceServiceConnection = void 0;
    var PriceServiceConnection_1 = require_PriceServiceConnection();
    Object.defineProperty(exports2, "PriceServiceConnection", { enumerable: true, get: function() {
      return PriceServiceConnection_1.PriceServiceConnection;
    } });
    var price_service_sdk_1 = require_lib();
    Object.defineProperty(exports2, "PriceFeedMetadata", { enumerable: true, get: function() {
      return price_service_sdk_1.PriceFeedMetadata;
    } });
    Object.defineProperty(exports2, "PriceFeed", { enumerable: true, get: function() {
      return price_service_sdk_1.PriceFeed;
    } });
    Object.defineProperty(exports2, "Price", { enumerable: true, get: function() {
      return price_service_sdk_1.Price;
    } });
    Object.defineProperty(exports2, "isAccumulatorUpdateData", { enumerable: true, get: function() {
      return price_service_sdk_1.isAccumulatorUpdateData;
    } });
    Object.defineProperty(exports2, "parseAccumulatorUpdateData", { enumerable: true, get: function() {
      return price_service_sdk_1.parseAccumulatorUpdateData;
    } });
  }
});

// ../../node_modules/.pnpm/@pythnetwork+pyth-sui-js@2.1.0_typescript@5.8.3/node_modules/@pythnetwork/pyth-sui-js/lib/SuiPriceServiceConnection.js
var require_SuiPriceServiceConnection = __commonJS({
  "../../node_modules/.pnpm/@pythnetwork+pyth-sui-js@2.1.0_typescript@5.8.3/node_modules/@pythnetwork/pyth-sui-js/lib/SuiPriceServiceConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SuiPriceServiceConnection = void 0;
    var price_service_client_1 = require_lib2();
    var buffer_1 = require("buffer");
    var SuiPriceServiceConnection2 = class extends price_service_client_1.PriceServiceConnection {
      /**
       * Gets price update data (either batch price attestation VAAs or accumulator messages, depending on the chosen endpoint), which then
       * can be submitted to the Pyth contract to update the prices. This will throw an axios error if there is a network problem or
       * the price service returns a non-ok response (e.g: Invalid price ids)
       *
       * @param priceIds Array of hex-encoded price ids.
       * @returns Array of buffers containing the price update data.
       */
      async getPriceFeedsUpdateData(priceIds) {
        const latestVaas = await this.getLatestVaas(priceIds);
        return latestVaas.map((vaa) => buffer_1.Buffer.from(vaa, "base64"));
      }
    };
    exports2.SuiPriceServiceConnection = SuiPriceServiceConnection2;
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/format.js
var require_format = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/format.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var format_exports = {};
    __export2(format_exports, {
      formatAddress: () => formatAddress,
      formatDigest: () => formatDigest
    });
    module2.exports = __toCommonJS2(format_exports);
    var ELLIPSIS = "\u2026";
    function formatAddress(address) {
      if (address.length <= 6) {
        return address;
      }
      const offset = address.startsWith("0x") ? 2 : 0;
      return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(-4)}`;
    }
    function formatDigest(digest) {
      return `${digest.slice(0, 10)}${ELLIPSIS}`;
    }
  }
});

// ../../node_modules/.pnpm/base-x@5.0.1/node_modules/base-x/src/cjs/index.cjs
var require_cjs3 = __commonJS({
  "../../node_modules/.pnpm/base-x@5.0.1/node_modules/base-x/src/cjs/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function base2(ALPHABET2) {
      if (ALPHABET2.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      const BASE_MAP = new Uint8Array(256);
      for (let j2 = 0; j2 < BASE_MAP.length; j2++) {
        BASE_MAP[j2] = 255;
      }
      for (let i = 0; i < ALPHABET2.length; i++) {
        const x2 = ALPHABET2.charAt(i);
        const xc = x2.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x2 + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      const BASE3 = ALPHABET2.length;
      const LEADER = ALPHABET2.charAt(0);
      const FACTOR = Math.log(BASE3) / Math.log(256);
      const iFACTOR = Math.log(256) / Math.log(BASE3);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        let zeroes = 0;
        let length = 0;
        let pbegin = 0;
        const pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        const b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          let carry = source[pbegin];
          let i = 0;
          for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE3 >>> 0;
            carry = carry / BASE3 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i;
          pbegin++;
        }
        let it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        let str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET2.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        let psz = 0;
        let zeroes = 0;
        let length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        const size = (source.length - psz) * FACTOR + 1 >>> 0;
        const b256 = new Uint8Array(size);
        while (psz < source.length) {
          const charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          let carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          let i = 0;
          for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
            carry += BASE3 * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i;
          psz++;
        }
        let it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        const vch = new Uint8Array(zeroes + (size - it4));
        let j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string2) {
        const buffer = decodeUnsafe(string2);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE3 + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    exports2.default = base2;
  }
});

// ../../node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/cjs/index.cjs
var require_cjs4 = __commonJS({
  "../../node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/cjs/index.cjs"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_x_1 = __importDefault(require_cjs3());
    var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    exports2.default = (0, base_x_1.default)(ALPHABET2);
  }
});

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/b58.js
var require_b58 = __commonJS({
  "../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/b58.js"(exports2, module2) {
    "use strict";
    var __create4 = Object.create;
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __getProtoOf4 = Object.getPrototypeOf;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM4 = (mod3, isNodeMode, target) => (target = mod3 != null ? __create4(__getProtoOf4(mod3)) : {}, __copyProps4(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod3 || !mod3.__esModule ? __defProp4(target, "default", { value: mod3, enumerable: true }) : target,
      mod3
    ));
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var b58_exports = {};
    __export2(b58_exports, {
      fromB58: () => fromB582,
      fromBase58: () => fromBase582,
      toB58: () => toB582,
      toBase58: () => toBase582
    });
    module2.exports = __toCommonJS2(b58_exports);
    var import_bs582 = __toESM4(require_cjs4());
    var toBase582 = (buffer) => import_bs582.default.encode(buffer);
    var fromBase582 = (str) => import_bs582.default.decode(str);
    var toB582 = toBase582;
    var fromB582 = fromBase582;
  }
});

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/b64.js
var require_b64 = __commonJS({
  "../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/b64.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var b64_exports = {};
    __export2(b64_exports, {
      fromB64: () => fromB642,
      fromBase64: () => fromBase642,
      toB64: () => toB642,
      toBase64: () => toBase642
    });
    module2.exports = __toCommonJS2(b64_exports);
    function fromBase642(base64String2) {
      return Uint8Array.from(atob(base64String2), (char) => char.charCodeAt(0));
    }
    var CHUNK_SIZE2 = 8192;
    function toBase642(bytes) {
      if (bytes.length < CHUNK_SIZE2) {
        return btoa(String.fromCharCode(...bytes));
      }
      let output = "";
      for (var i = 0; i < bytes.length; i += CHUNK_SIZE2) {
        const chunk2 = bytes.slice(i, i + CHUNK_SIZE2);
        output += String.fromCharCode(...chunk2);
      }
      return btoa(output);
    }
    var toB642 = toBase642;
    var fromB642 = fromBase642;
  }
});

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/hex.js
var require_hex = __commonJS({
  "../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/hex.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var hex_exports = {};
    __export2(hex_exports, {
      fromHEX: () => fromHEX2,
      fromHex: () => fromHex2,
      toHEX: () => toHEX2,
      toHex: () => toHex2
    });
    module2.exports = __toCommonJS2(hex_exports);
    function fromHex2(hexStr) {
      var _a7, _b3;
      const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
      const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;
      const intArr = (_b3 = (_a7 = padded.match(/[0-9a-fA-F]{2}/g)) == null ? void 0 : _a7.map((byte) => parseInt(byte, 16))) != null ? _b3 : [];
      if (intArr.length !== padded.length / 2) {
        throw new Error(`Invalid hex string ${hexStr}`);
      }
      return Uint8Array.from(intArr);
    }
    function toHex2(bytes) {
      return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    }
    var toHEX2 = toHex2;
    var fromHEX2 = fromHex2;
  }
});

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/uleb.js
var require_uleb = __commonJS({
  "../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/uleb.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var uleb_exports = {};
    __export2(uleb_exports, {
      ulebDecode: () => ulebDecode2,
      ulebEncode: () => ulebEncode2
    });
    module2.exports = __toCommonJS2(uleb_exports);
    function ulebEncode2(num) {
      let arr = [];
      let len = 0;
      if (num === 0) {
        return [0];
      }
      while (num > 0) {
        arr[len] = num & 127;
        if (num >>= 7) {
          arr[len] |= 128;
        }
        len += 1;
      }
      return arr;
    }
    function ulebDecode2(arr) {
      let total = 0;
      let shift = 0;
      let len = 0;
      while (true) {
        let byte = arr[len];
        len += 1;
        total |= (byte & 127) << shift;
        if ((byte & 128) === 0) {
          break;
        }
        shift += 7;
      }
      return {
        value: total,
        length: len
      };
    }
  }
});

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/reader.js
var require_reader = __commonJS({
  "../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/reader.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var reader_exports = {};
    __export2(reader_exports, {
      BcsReader: () => BcsReader2
    });
    module2.exports = __toCommonJS2(reader_exports);
    var import_uleb5 = require_uleb();
    var BcsReader2 = class {
      /**
       * @param {Uint8Array} data Data to use as a buffer.
       */
      constructor(data) {
        this.bytePosition = 0;
        this.dataView = new DataView(data.buffer);
      }
      /**
       * Shift current cursor position by `bytes`.
       *
       * @param {Number} bytes Number of bytes to
       * @returns {this} Self for possible chaining.
       */
      shift(bytes) {
        this.bytePosition += bytes;
        return this;
      }
      /**
       * Read U8 value from the buffer and shift cursor by 1.
       * @returns
       */
      read8() {
        let value = this.dataView.getUint8(this.bytePosition);
        this.shift(1);
        return value;
      }
      /**
       * Read U16 value from the buffer and shift cursor by 2.
       * @returns
       */
      read16() {
        let value = this.dataView.getUint16(this.bytePosition, true);
        this.shift(2);
        return value;
      }
      /**
       * Read U32 value from the buffer and shift cursor by 4.
       * @returns
       */
      read32() {
        let value = this.dataView.getUint32(this.bytePosition, true);
        this.shift(4);
        return value;
      }
      /**
       * Read U64 value from the buffer and shift cursor by 8.
       * @returns
       */
      read64() {
        let value1 = this.read32();
        let value2 = this.read32();
        let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
        return BigInt("0x" + result).toString(10);
      }
      /**
       * Read U128 value from the buffer and shift cursor by 16.
       */
      read128() {
        let value1 = BigInt(this.read64());
        let value2 = BigInt(this.read64());
        let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
        return BigInt("0x" + result).toString(10);
      }
      /**
       * Read U128 value from the buffer and shift cursor by 32.
       * @returns
       */
      read256() {
        let value1 = BigInt(this.read128());
        let value2 = BigInt(this.read128());
        let result = value2.toString(16) + value1.toString(16).padStart(32, "0");
        return BigInt("0x" + result).toString(10);
      }
      /**
       * Read `num` number of bytes from the buffer and shift cursor by `num`.
       * @param num Number of bytes to read.
       */
      readBytes(num) {
        let start = this.bytePosition + this.dataView.byteOffset;
        let value = new Uint8Array(this.dataView.buffer, start, num);
        this.shift(num);
        return value;
      }
      /**
       * Read ULEB value - an integer of varying size. Used for enum indexes and
       * vector lengths.
       * @returns {Number} The ULEB value.
       */
      readULEB() {
        let start = this.bytePosition + this.dataView.byteOffset;
        let buffer = new Uint8Array(this.dataView.buffer, start);
        let { value, length } = (0, import_uleb5.ulebDecode)(buffer);
        this.shift(length);
        return value;
      }
      /**
       * Read a BCS vector: read a length and then apply function `cb` X times
       * where X is the length of the vector, defined as ULEB in BCS bytes.
       * @param cb Callback to process elements of vector.
       * @returns {Array<Any>} Array of the resulting values, returned by callback.
       */
      readVec(cb) {
        let length = this.readULEB();
        let result = [];
        for (let i = 0; i < length; i++) {
          result.push(cb(this, i, length));
        }
        return result;
      }
    };
  }
});

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/utils.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var utils_exports = {};
    __export2(utils_exports, {
      decodeStr: () => decodeStr2,
      encodeStr: () => encodeStr2,
      splitGenericParameters: () => splitGenericParameters2
    });
    module2.exports = __toCommonJS2(utils_exports);
    var import_b584 = require_b58();
    var import_b644 = require_b64();
    var import_hex4 = require_hex();
    function encodeStr2(data, encoding) {
      switch (encoding) {
        case "base58":
          return (0, import_b584.toBase58)(data);
        case "base64":
          return (0, import_b644.toBase64)(data);
        case "hex":
          return (0, import_hex4.toHex)(data);
        default:
          throw new Error("Unsupported encoding, supported values are: base64, hex");
      }
    }
    function decodeStr2(data, encoding) {
      switch (encoding) {
        case "base58":
          return (0, import_b584.fromBase58)(data);
        case "base64":
          return (0, import_b644.fromBase64)(data);
        case "hex":
          return (0, import_hex4.fromHex)(data);
        default:
          throw new Error("Unsupported encoding, supported values are: base64, hex");
      }
    }
    function splitGenericParameters2(str, genericSeparators = ["<", ">"]) {
      const [left, right] = genericSeparators;
      const tok = [];
      let word = "";
      let nestedAngleBrackets = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str[i];
        if (char === left) {
          nestedAngleBrackets++;
        }
        if (char === right) {
          nestedAngleBrackets--;
        }
        if (nestedAngleBrackets === 0 && char === ",") {
          tok.push(word.trim());
          word = "";
          continue;
        }
        word += char;
      }
      tok.push(word.trim());
      return tok;
    }
  }
});

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/writer.js
var require_writer = __commonJS({
  "../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/writer.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var writer_exports = {};
    __export2(writer_exports, {
      BcsWriter: () => BcsWriter2
    });
    module2.exports = __toCommonJS2(writer_exports);
    var import_uleb5 = require_uleb();
    var import_utils31 = require_utils2();
    var BcsWriter2 = class {
      constructor({
        initialSize = 1024,
        maxSize = Infinity,
        allocateSize = 1024
      } = {}) {
        this.bytePosition = 0;
        this.size = initialSize;
        this.maxSize = maxSize;
        this.allocateSize = allocateSize;
        this.dataView = new DataView(new ArrayBuffer(initialSize));
      }
      ensureSizeOrGrow(bytes) {
        const requiredSize = this.bytePosition + bytes;
        if (requiredSize > this.size) {
          const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
          if (requiredSize > nextSize) {
            throw new Error(
              `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
            );
          }
          this.size = nextSize;
          const nextBuffer = new ArrayBuffer(this.size);
          new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
          this.dataView = new DataView(nextBuffer);
        }
      }
      /**
       * Shift current cursor position by `bytes`.
       *
       * @param {Number} bytes Number of bytes to
       * @returns {this} Self for possible chaining.
       */
      shift(bytes) {
        this.bytePosition += bytes;
        return this;
      }
      /**
       * Write a U8 value into a buffer and shift cursor position by 1.
       * @param {Number} value Value to write.
       * @returns {this}
       */
      write8(value) {
        this.ensureSizeOrGrow(1);
        this.dataView.setUint8(this.bytePosition, Number(value));
        return this.shift(1);
      }
      /**
       * Write a U16 value into a buffer and shift cursor position by 2.
       * @param {Number} value Value to write.
       * @returns {this}
       */
      write16(value) {
        this.ensureSizeOrGrow(2);
        this.dataView.setUint16(this.bytePosition, Number(value), true);
        return this.shift(2);
      }
      /**
       * Write a U32 value into a buffer and shift cursor position by 4.
       * @param {Number} value Value to write.
       * @returns {this}
       */
      write32(value) {
        this.ensureSizeOrGrow(4);
        this.dataView.setUint32(this.bytePosition, Number(value), true);
        return this.shift(4);
      }
      /**
       * Write a U64 value into a buffer and shift cursor position by 8.
       * @param {bigint} value Value to write.
       * @returns {this}
       */
      write64(value) {
        toLittleEndian2(BigInt(value), 8).forEach((el2) => this.write8(el2));
        return this;
      }
      /**
       * Write a U128 value into a buffer and shift cursor position by 16.
       *
       * @param {bigint} value Value to write.
       * @returns {this}
       */
      write128(value) {
        toLittleEndian2(BigInt(value), 16).forEach((el2) => this.write8(el2));
        return this;
      }
      /**
       * Write a U256 value into a buffer and shift cursor position by 16.
       *
       * @param {bigint} value Value to write.
       * @returns {this}
       */
      write256(value) {
        toLittleEndian2(BigInt(value), 32).forEach((el2) => this.write8(el2));
        return this;
      }
      /**
       * Write a ULEB value into a buffer and shift cursor position by number of bytes
       * written.
       * @param {Number} value Value to write.
       * @returns {this}
       */
      writeULEB(value) {
        (0, import_uleb5.ulebEncode)(value).forEach((el2) => this.write8(el2));
        return this;
      }
      /**
       * Write a vector into a buffer by first writing the vector length and then calling
       * a callback on each passed value.
       *
       * @param {Array<Any>} vector Array of elements to write.
       * @param {WriteVecCb} cb Callback to call on each element of the vector.
       * @returns {this}
       */
      writeVec(vector, cb) {
        this.writeULEB(vector.length);
        Array.from(vector).forEach((el2, i) => cb(this, el2, i, vector.length));
        return this;
      }
      /**
       * Adds support for iterations over the object.
       * @returns {Uint8Array}
       */
      *[Symbol.iterator]() {
        for (let i = 0; i < this.bytePosition; i++) {
          yield this.dataView.getUint8(i);
        }
        return this.toBytes();
      }
      /**
       * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
       * @returns {Uint8Array} Resulting bcs.
       */
      toBytes() {
        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
      }
      /**
       * Represent data as 'hex' or 'base64'
       * @param encoding Encoding to use: 'base64' or 'hex'
       */
      toString(encoding) {
        return (0, import_utils31.encodeStr)(this.toBytes(), encoding);
      }
    };
    function toLittleEndian2(bigint2, size) {
      let result = new Uint8Array(size);
      let i = 0;
      while (bigint2 > 0) {
        result[i] = Number(bigint2 % BigInt(256));
        bigint2 = bigint2 / BigInt(256);
        i += 1;
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/bcs-type.js
var require_bcs_type = __commonJS({
  "../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/bcs-type.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __typeError6 = (msg) => {
      throw TypeError(msg);
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
    var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
    var __privateAdd6 = (obj, member, value) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    var __privateSet6 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
    var bcs_type_exports = {};
    __export2(bcs_type_exports, {
      BcsType: () => BcsType2,
      SerializedBcs: () => SerializedBcs2,
      bigUIntBcsType: () => bigUIntBcsType2,
      dynamicSizeBcsType: () => dynamicSizeBcsType2,
      fixedSizeBcsType: () => fixedSizeBcsType2,
      isSerializedBcs: () => isSerializedBcs2,
      lazyBcsType: () => lazyBcsType2,
      stringLikeBcsType: () => stringLikeBcsType2,
      uIntBcsType: () => uIntBcsType2
    });
    module2.exports = __toCommonJS2(bcs_type_exports);
    var import_b584 = require_b58();
    var import_b644 = require_b64();
    var import_hex4 = require_hex();
    var import_reader2 = require_reader();
    var import_uleb5 = require_uleb();
    var import_writer2 = require_writer();
    var _write2;
    var _serialize2;
    var _schema2;
    var _bytes2;
    var _BcsType3 = class _BcsType4 {
      constructor(options) {
        var _a7, _b3, _c;
        __privateAdd6(this, _write2);
        __privateAdd6(this, _serialize2);
        this.name = options.name;
        this.read = options.read;
        this.serializedSize = (_a7 = options.serializedSize) != null ? _a7 : () => null;
        __privateSet6(this, _write2, options.write);
        __privateSet6(this, _serialize2, (_b3 = options.serialize) != null ? _b3 : (value, options2) => {
          var _a8;
          const writer = new import_writer2.BcsWriter(__spreadValues({
            initialSize: (_a8 = this.serializedSize(value)) != null ? _a8 : void 0
          }, options2));
          __privateGet6(this, _write2).call(this, value, writer);
          return writer.toBytes();
        });
        this.validate = (_c = options.validate) != null ? _c : () => {
        };
      }
      write(value, writer) {
        this.validate(value);
        __privateGet6(this, _write2).call(this, value, writer);
      }
      serialize(value, options) {
        this.validate(value);
        return new SerializedBcs2(this, __privateGet6(this, _serialize2).call(this, value, options));
      }
      parse(bytes) {
        const reader = new import_reader2.BcsReader(bytes);
        return this.read(reader);
      }
      fromHex(hex) {
        return this.parse((0, import_hex4.fromHex)(hex));
      }
      fromBase58(b64) {
        return this.parse((0, import_b584.fromBase58)(b64));
      }
      fromBase64(b64) {
        return this.parse((0, import_b644.fromBase64)(b64));
      }
      transform({
        name,
        input,
        output,
        validate: validate2
      }) {
        return new _BcsType4({
          name: name != null ? name : this.name,
          read: (reader) => output(this.read(reader)),
          write: (value, writer) => __privateGet6(this, _write2).call(this, input(value), writer),
          serializedSize: (value) => this.serializedSize(input(value)),
          serialize: (value, options) => __privateGet6(this, _serialize2).call(this, input(value), options),
          validate: (value) => {
            validate2 == null ? void 0 : validate2(value);
            this.validate(input(value));
          }
        });
      }
    };
    _write2 = /* @__PURE__ */ new WeakMap();
    _serialize2 = /* @__PURE__ */ new WeakMap();
    var BcsType2 = _BcsType3;
    var SERIALIZED_BCS_BRAND2 = Symbol.for("@mysten/serialized-bcs");
    function isSerializedBcs2(obj) {
      return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND2] === true;
    }
    var SerializedBcs2 = class {
      constructor(type, schema) {
        __privateAdd6(this, _schema2);
        __privateAdd6(this, _bytes2);
        __privateSet6(this, _schema2, type);
        __privateSet6(this, _bytes2, schema);
      }
      // Used to brand SerializedBcs so that they can be identified, even between multiple copies
      // of the @mysten/bcs package are installed
      get [SERIALIZED_BCS_BRAND2]() {
        return true;
      }
      toBytes() {
        return __privateGet6(this, _bytes2);
      }
      toHex() {
        return (0, import_hex4.toHex)(__privateGet6(this, _bytes2));
      }
      toBase64() {
        return (0, import_b644.toBase64)(__privateGet6(this, _bytes2));
      }
      toBase58() {
        return (0, import_b584.toBase58)(__privateGet6(this, _bytes2));
      }
      parse() {
        return __privateGet6(this, _schema2).parse(__privateGet6(this, _bytes2));
      }
    };
    _schema2 = /* @__PURE__ */ new WeakMap();
    _bytes2 = /* @__PURE__ */ new WeakMap();
    function fixedSizeBcsType2(_a7) {
      var _b3 = _a7, {
        size
      } = _b3, options = __objRest(_b3, [
        "size"
      ]);
      return new BcsType2(__spreadProps(__spreadValues({}, options), {
        serializedSize: () => size
      }));
    }
    function uIntBcsType2(_a7) {
      var _b3 = _a7, {
        readMethod,
        writeMethod
      } = _b3, options = __objRest(_b3, [
        "readMethod",
        "writeMethod"
      ]);
      return fixedSizeBcsType2(__spreadProps(__spreadValues({}, options), {
        read: (reader) => reader[readMethod](),
        write: (value, writer) => writer[writeMethod](value),
        validate: (value) => {
          var _a8;
          if (value < 0 || value > options.maxValue) {
            throw new TypeError(
              `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`
            );
          }
          (_a8 = options.validate) == null ? void 0 : _a8.call(options, value);
        }
      }));
    }
    function bigUIntBcsType2(_a7) {
      var _b3 = _a7, {
        readMethod,
        writeMethod
      } = _b3, options = __objRest(_b3, [
        "readMethod",
        "writeMethod"
      ]);
      return fixedSizeBcsType2(__spreadProps(__spreadValues({}, options), {
        read: (reader) => reader[readMethod](),
        write: (value, writer) => writer[writeMethod](BigInt(value)),
        validate: (val) => {
          var _a8;
          const value = BigInt(val);
          if (value < 0 || value > options.maxValue) {
            throw new TypeError(
              `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`
            );
          }
          (_a8 = options.validate) == null ? void 0 : _a8.call(options, value);
        }
      }));
    }
    function dynamicSizeBcsType2(_a7) {
      var _b3 = _a7, {
        serialize
      } = _b3, options = __objRest(_b3, [
        "serialize"
      ]);
      const type = new BcsType2(__spreadProps(__spreadValues({}, options), {
        serialize,
        write: (value, writer) => {
          for (const byte of type.serialize(value).toBytes()) {
            writer.write8(byte);
          }
        }
      }));
      return type;
    }
    function stringLikeBcsType2(_a7) {
      var _b3 = _a7, {
        toBytes: toBytes2,
        fromBytes
      } = _b3, options = __objRest(_b3, [
        "toBytes",
        "fromBytes"
      ]);
      return new BcsType2(__spreadProps(__spreadValues({}, options), {
        read: (reader) => {
          const length = reader.readULEB();
          const bytes = reader.readBytes(length);
          return fromBytes(bytes);
        },
        write: (hex, writer) => {
          const bytes = toBytes2(hex);
          writer.writeULEB(bytes.length);
          for (let i = 0; i < bytes.length; i++) {
            writer.write8(bytes[i]);
          }
        },
        serialize: (value) => {
          const bytes = toBytes2(value);
          const size = (0, import_uleb5.ulebEncode)(bytes.length);
          const result = new Uint8Array(size.length + bytes.length);
          result.set(size, 0);
          result.set(bytes, size.length);
          return result;
        },
        validate: (value) => {
          var _a8;
          if (typeof value !== "string") {
            throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);
          }
          (_a8 = options.validate) == null ? void 0 : _a8.call(options, value);
        }
      }));
    }
    function lazyBcsType2(cb) {
      let lazyType = null;
      function getType() {
        if (!lazyType) {
          lazyType = cb();
        }
        return lazyType;
      }
      return new BcsType2({
        name: "lazy",
        read: (data) => getType().read(data),
        serializedSize: (value) => getType().serializedSize(value),
        write: (value, writer) => getType().write(value, writer),
        serialize: (value, options) => getType().serialize(value, options).toBytes()
      });
    }
  }
});

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/bcs.js
var require_bcs = __commonJS({
  "../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/bcs.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var bcs_exports = {};
    __export2(bcs_exports, {
      bcs: () => bcs2
    });
    module2.exports = __toCommonJS2(bcs_exports);
    var import_bcs_type3 = require_bcs_type();
    var import_uleb5 = require_uleb();
    var bcs2 = {
      /**
       * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
       * @example
       * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
       */
      u8(options) {
        return (0, import_bcs_type3.uIntBcsType)(__spreadValues({
          name: "u8",
          readMethod: "read8",
          writeMethod: "write8",
          size: 1,
          maxValue: 2 ** 8 - 1
        }, options));
      },
      /**
       * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
       * @example
       * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
       */
      u16(options) {
        return (0, import_bcs_type3.uIntBcsType)(__spreadValues({
          name: "u16",
          readMethod: "read16",
          writeMethod: "write16",
          size: 2,
          maxValue: 2 ** 16 - 1
        }, options));
      },
      /**
       * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
       * @example
       * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
       */
      u32(options) {
        return (0, import_bcs_type3.uIntBcsType)(__spreadValues({
          name: "u32",
          readMethod: "read32",
          writeMethod: "write32",
          size: 4,
          maxValue: 2 ** 32 - 1
        }, options));
      },
      /**
       * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
       * @example
       * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
       */
      u64(options) {
        return (0, import_bcs_type3.bigUIntBcsType)(__spreadValues({
          name: "u64",
          readMethod: "read64",
          writeMethod: "write64",
          size: 8,
          maxValue: /* @__PURE__ */ BigInt("2") ** /* @__PURE__ */ BigInt("64") - /* @__PURE__ */ BigInt("1")
        }, options));
      },
      /**
       * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
       * @example
       * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
       */
      u128(options) {
        return (0, import_bcs_type3.bigUIntBcsType)(__spreadValues({
          name: "u128",
          readMethod: "read128",
          writeMethod: "write128",
          size: 16,
          maxValue: /* @__PURE__ */ BigInt("2") ** /* @__PURE__ */ BigInt("128") - /* @__PURE__ */ BigInt("1")
        }, options));
      },
      /**
       * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
       * @example
       * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
       */
      u256(options) {
        return (0, import_bcs_type3.bigUIntBcsType)(__spreadValues({
          name: "u256",
          readMethod: "read256",
          writeMethod: "write256",
          size: 32,
          maxValue: /* @__PURE__ */ BigInt("2") ** /* @__PURE__ */ BigInt("256") - /* @__PURE__ */ BigInt("1")
        }, options));
      },
      /**
       * Creates a BcsType that can be used to read and write boolean values.
       * @example
       * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
       */
      bool(options) {
        return (0, import_bcs_type3.fixedSizeBcsType)(__spreadProps(__spreadValues({
          name: "bool",
          size: 1,
          read: (reader) => reader.read8() === 1,
          write: (value, writer) => writer.write8(value ? 1 : 0)
        }, options), {
          validate: (value) => {
            var _a7;
            (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
            if (typeof value !== "boolean") {
              throw new TypeError(`Expected boolean, found ${typeof value}`);
            }
          }
        }));
      },
      /**
       * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
       * @example
       *
       */
      uleb128(options) {
        return (0, import_bcs_type3.dynamicSizeBcsType)(__spreadValues({
          name: "uleb128",
          read: (reader) => reader.readULEB(),
          serialize: (value) => {
            return Uint8Array.from((0, import_uleb5.ulebEncode)(value));
          }
        }, options));
      },
      /**
       * Creates a BcsType representing a fixed length byte array
       * @param size The number of bytes this types represents
       * @example
       * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
       */
      bytes(size, options) {
        return (0, import_bcs_type3.fixedSizeBcsType)(__spreadProps(__spreadValues({
          name: `bytes[${size}]`,
          size,
          read: (reader) => reader.readBytes(size),
          write: (value, writer) => {
            var _a7;
            const array2 = new Uint8Array(value);
            for (let i = 0; i < size; i++) {
              writer.write8((_a7 = array2[i]) != null ? _a7 : 0);
            }
          }
        }, options), {
          validate: (value) => {
            var _a7;
            (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
            if (!value || typeof value !== "object" || !("length" in value)) {
              throw new TypeError(`Expected array, found ${typeof value}`);
            }
            if (value.length !== size) {
              throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
            }
          }
        }));
      },
      /**
       * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
       * @example
       * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
       */
      string(options) {
        return (0, import_bcs_type3.stringLikeBcsType)(__spreadValues({
          name: "string",
          toBytes: (value) => new TextEncoder().encode(value),
          fromBytes: (bytes) => new TextDecoder().decode(bytes)
        }, options));
      },
      /**
       * Creates a BcsType that represents a fixed length array of a given type
       * @param size The number of elements in the array
       * @param type The BcsType of each element in the array
       * @example
       * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
       */
      fixedArray(size, type, options) {
        return new import_bcs_type3.BcsType(__spreadProps(__spreadValues({
          name: `${type.name}[${size}]`,
          read: (reader) => {
            const result = new Array(size);
            for (let i = 0; i < size; i++) {
              result[i] = type.read(reader);
            }
            return result;
          },
          write: (value, writer) => {
            for (const item of value) {
              type.write(item, writer);
            }
          }
        }, options), {
          validate: (value) => {
            var _a7;
            (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
            if (!value || typeof value !== "object" || !("length" in value)) {
              throw new TypeError(`Expected array, found ${typeof value}`);
            }
            if (value.length !== size) {
              throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
            }
          }
        }));
      },
      /**
       * Creates a BcsType representing an optional value
       * @param type The BcsType of the optional value
       * @example
       * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
       * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
       */
      option(type) {
        return bcs2.enum(`Option<${type.name}>`, {
          None: null,
          Some: type
        }).transform({
          input: (value) => {
            if (value == null) {
              return { None: true };
            }
            return { Some: value };
          },
          output: (value) => {
            if (value.$kind === "Some") {
              return value.Some;
            }
            return null;
          }
        });
      },
      /**
       * Creates a BcsType representing a variable length vector of a given type
       * @param type The BcsType of each element in the vector
       *
       * @example
       * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
       */
      vector(type, options) {
        return new import_bcs_type3.BcsType(__spreadProps(__spreadValues({
          name: `vector<${type.name}>`,
          read: (reader) => {
            const length = reader.readULEB();
            const result = new Array(length);
            for (let i = 0; i < length; i++) {
              result[i] = type.read(reader);
            }
            return result;
          },
          write: (value, writer) => {
            writer.writeULEB(value.length);
            for (const item of value) {
              type.write(item, writer);
            }
          }
        }, options), {
          validate: (value) => {
            var _a7;
            (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
            if (!value || typeof value !== "object" || !("length" in value)) {
              throw new TypeError(`Expected array, found ${typeof value}`);
            }
          }
        }));
      },
      /**
       * Creates a BcsType representing a tuple of a given set of types
       * @param types The BcsTypes for each element in the tuple
       *
       * @example
       * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
       * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
       */
      tuple(types, options) {
        return new import_bcs_type3.BcsType(__spreadProps(__spreadValues({
          name: `(${types.map((t) => t.name).join(", ")})`,
          serializedSize: (values) => {
            let total = 0;
            for (let i = 0; i < types.length; i++) {
              const size = types[i].serializedSize(values[i]);
              if (size == null) {
                return null;
              }
              total += size;
            }
            return total;
          },
          read: (reader) => {
            const result = [];
            for (const type of types) {
              result.push(type.read(reader));
            }
            return result;
          },
          write: (value, writer) => {
            for (let i = 0; i < types.length; i++) {
              types[i].write(value[i], writer);
            }
          }
        }, options), {
          validate: (value) => {
            var _a7;
            (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
            if (!Array.isArray(value)) {
              throw new TypeError(`Expected array, found ${typeof value}`);
            }
            if (value.length !== types.length) {
              throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);
            }
          }
        }));
      },
      /**
       * Creates a BcsType representing a struct of a given set of fields
       * @param name The name of the struct
       * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
       *
       * @example
       * const struct = bcs.struct('MyStruct', {
       *  a: bcs.u8(),
       *  b: bcs.string(),
       * })
       * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
       */
      struct(name, fields, options) {
        const canonicalOrder = Object.entries(fields);
        return new import_bcs_type3.BcsType(__spreadProps(__spreadValues({
          name,
          serializedSize: (values) => {
            let total = 0;
            for (const [field, type] of canonicalOrder) {
              const size = type.serializedSize(values[field]);
              if (size == null) {
                return null;
              }
              total += size;
            }
            return total;
          },
          read: (reader) => {
            const result = {};
            for (const [field, type] of canonicalOrder) {
              result[field] = type.read(reader);
            }
            return result;
          },
          write: (value, writer) => {
            for (const [field, type] of canonicalOrder) {
              type.write(value[field], writer);
            }
          }
        }, options), {
          validate: (value) => {
            var _a7;
            (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
            if (typeof value !== "object" || value == null) {
              throw new TypeError(`Expected object, found ${typeof value}`);
            }
          }
        }));
      },
      /**
       * Creates a BcsType representing an enum of a given set of options
       * @param name The name of the enum
       * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
       * null can be used to represent a variant with no data.
       *
       * @example
       * const enum = bcs.enum('MyEnum', {
       *   A: bcs.u8(),
       *   B: bcs.string(),
       *   C: null,
       * })
       * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
       * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
       * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
       */
      enum(name, values, options) {
        const canonicalOrder = Object.entries(values);
        return new import_bcs_type3.BcsType(__spreadProps(__spreadValues({
          name,
          read: (reader) => {
            var _a7;
            const index = reader.readULEB();
            const enumEntry = canonicalOrder[index];
            if (!enumEntry) {
              throw new TypeError(`Unknown value ${index} for enum ${name}`);
            }
            const [kind, type] = enumEntry;
            return {
              [kind]: (_a7 = type == null ? void 0 : type.read(reader)) != null ? _a7 : true,
              $kind: kind
            };
          },
          write: (value, writer) => {
            const [name2, val] = Object.entries(value).filter(
              ([name3]) => Object.hasOwn(values, name3)
            )[0];
            for (let i = 0; i < canonicalOrder.length; i++) {
              const [optionName, optionType] = canonicalOrder[i];
              if (optionName === name2) {
                writer.writeULEB(i);
                optionType == null ? void 0 : optionType.write(val, writer);
                return;
              }
            }
          }
        }, options), {
          validate: (value) => {
            var _a7;
            (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
            if (typeof value !== "object" || value == null) {
              throw new TypeError(`Expected object, found ${typeof value}`);
            }
            const keys = Object.keys(value).filter(
              (k2) => value[k2] !== void 0 && Object.hasOwn(values, k2)
            );
            if (keys.length !== 1) {
              throw new TypeError(
                `Expected object with one key, but found ${keys.length} for type ${name}}`
              );
            }
            const [variant] = keys;
            if (!Object.hasOwn(values, variant)) {
              throw new TypeError(`Invalid enum variant ${variant}`);
            }
          }
        }));
      },
      /**
       * Creates a BcsType representing a map of a given key and value type
       * @param keyType The BcsType of the key
       * @param valueType The BcsType of the value
       * @example
       * const map = bcs.map(bcs.u8(), bcs.string())
       * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
       */
      map(keyType, valueType) {
        return bcs2.vector(bcs2.tuple([keyType, valueType])).transform({
          name: `Map<${keyType.name}, ${valueType.name}>`,
          input: (value) => {
            return [...value.entries()];
          },
          output: (value) => {
            const result = /* @__PURE__ */ new Map();
            for (const [key, val] of value) {
              result.set(key, val);
            }
            return result;
          }
        });
      },
      /**
       * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
       * @param cb A callback that returns the BcsType
       */
      lazy(cb) {
        return (0, import_bcs_type3.lazyBcsType)(cb);
      }
    };
  }
});

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/cjs/index.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var src_exports = {};
    __export2(src_exports, {
      BcsReader: () => import_reader2.BcsReader,
      BcsType: () => import_bcs_type3.BcsType,
      BcsWriter: () => import_writer2.BcsWriter,
      SerializedBcs: () => import_bcs_type3.SerializedBcs,
      bcs: () => import_bcs34.bcs,
      decodeStr: () => import_utils31.decodeStr,
      encodeStr: () => import_utils31.encodeStr,
      fromB58: () => import_b584.fromB58,
      fromB64: () => import_b644.fromB64,
      fromBase58: () => import_b584.fromBase58,
      fromBase64: () => import_b644.fromBase64,
      fromHEX: () => import_hex4.fromHEX,
      fromHex: () => import_hex4.fromHex,
      isSerializedBcs: () => import_bcs_type3.isSerializedBcs,
      splitGenericParameters: () => import_utils31.splitGenericParameters,
      toB58: () => import_b584.toB58,
      toB64: () => import_b644.toB64,
      toBase58: () => import_b584.toBase58,
      toBase64: () => import_b644.toBase64,
      toHEX: () => import_hex4.toHEX,
      toHex: () => import_hex4.toHex
    });
    module2.exports = __toCommonJS2(src_exports);
    var import_b584 = require_b58();
    var import_b644 = require_b64();
    var import_bcs_type3 = require_bcs_type();
    var import_bcs34 = require_bcs();
    var import_hex4 = require_hex();
    var import_reader2 = require_reader();
    var import_utils31 = require_utils2();
    var import_writer2 = require_writer();
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/sui-types.js
var require_sui_types = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/sui-types.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var sui_types_exports = {};
    __export2(sui_types_exports, {
      SUI_ADDRESS_LENGTH: () => SUI_ADDRESS_LENGTH2,
      isValidSuiAddress: () => isValidSuiAddress2,
      isValidSuiObjectId: () => isValidSuiObjectId2,
      isValidTransactionDigest: () => isValidTransactionDigest2,
      normalizeStructTag: () => normalizeStructTag2,
      normalizeSuiAddress: () => normalizeSuiAddress2,
      normalizeSuiObjectId: () => normalizeSuiObjectId2,
      parseStructTag: () => parseStructTag2
    });
    module2.exports = __toCommonJS2(sui_types_exports);
    var import_bcs34 = require_cjs5();
    var TX_DIGEST_LENGTH2 = 32;
    function isValidTransactionDigest2(value) {
      try {
        const buffer = (0, import_bcs34.fromBase58)(value);
        return buffer.length === TX_DIGEST_LENGTH2;
      } catch (e) {
        return false;
      }
    }
    var SUI_ADDRESS_LENGTH2 = 32;
    function isValidSuiAddress2(value) {
      return isHex4(value) && getHexByteLength2(value) === SUI_ADDRESS_LENGTH2;
    }
    function isValidSuiObjectId2(value) {
      return isValidSuiAddress2(value);
    }
    function parseTypeTag2(type) {
      if (!type.includes("::")) return type;
      return parseStructTag2(type);
    }
    function parseStructTag2(type) {
      const [address, module22] = type.split("::");
      const rest = type.slice(address.length + module22.length + 4);
      const name = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
      const typeParams = rest.includes("<") ? (0, import_bcs34.splitGenericParameters)(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map(
        (typeParam) => parseTypeTag2(typeParam.trim())
      ) : [];
      return {
        address: normalizeSuiAddress2(address),
        module: module22,
        name,
        typeParams
      };
    }
    function normalizeStructTag2(type) {
      const { address, module: module22, name, typeParams } = typeof type === "string" ? parseStructTag2(type) : type;
      const formattedTypeParams = (typeParams == null ? void 0 : typeParams.length) > 0 ? `<${typeParams.map(
        (typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag2(typeParam)
      ).join(",")}>` : "";
      return `${address}::${module22}::${name}${formattedTypeParams}`;
    }
    function normalizeSuiAddress2(value, forceAdd0x = false) {
      let address = value.toLowerCase();
      if (!forceAdd0x && address.startsWith("0x")) {
        address = address.slice(2);
      }
      return `0x${address.padStart(SUI_ADDRESS_LENGTH2 * 2, "0")}`;
    }
    function normalizeSuiObjectId2(value, forceAdd0x = false) {
      return normalizeSuiAddress2(value, forceAdd0x);
    }
    function isHex4(value) {
      return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
    }
    function getHexByteLength2(value) {
      return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
    }
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/suins.js
var require_suins = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/suins.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var suins_exports = {};
    __export2(suins_exports, {
      isValidSuiNSName: () => isValidSuiNSName,
      normalizeSuiNSName: () => normalizeSuiNSName2
    });
    module2.exports = __toCommonJS2(suins_exports);
    var SUI_NS_NAME_REGEX2 = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
    var SUI_NS_DOMAIN_REGEX2 = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
    var MAX_SUI_NS_NAME_LENGTH = 235;
    function isValidSuiNSName(name) {
      if (name.length > MAX_SUI_NS_NAME_LENGTH) {
        return false;
      }
      if (name.includes("@")) {
        return SUI_NS_NAME_REGEX2.test(name);
      }
      return SUI_NS_DOMAIN_REGEX2.test(name);
    }
    function normalizeSuiNSName2(name, format = "at") {
      const lowerCase = name.toLowerCase();
      let parts;
      if (lowerCase.includes("@")) {
        if (!SUI_NS_NAME_REGEX2.test(lowerCase)) {
          throw new Error(`Invalid SuiNS name ${name}`);
        }
        const [labels, domain] = lowerCase.split("@");
        parts = [...labels ? labels.split(".") : [], domain];
      } else {
        if (!SUI_NS_DOMAIN_REGEX2.test(lowerCase)) {
          throw new Error(`Invalid SuiNS name ${name}`);
        }
        parts = lowerCase.split(".").slice(0, -1);
      }
      if (format === "dot") {
        return `${parts.join(".")}.sui`;
      }
      return `${parts.slice(0, -1).join(".")}@${parts[parts.length - 1]}`;
    }
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/constants.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var constants_exports = {};
    __export2(constants_exports, {
      MIST_PER_SUI: () => MIST_PER_SUI2,
      MOVE_STDLIB_ADDRESS: () => MOVE_STDLIB_ADDRESS2,
      SUI_CLOCK_OBJECT_ID: () => SUI_CLOCK_OBJECT_ID2,
      SUI_DECIMALS: () => SUI_DECIMALS2,
      SUI_FRAMEWORK_ADDRESS: () => SUI_FRAMEWORK_ADDRESS2,
      SUI_SYSTEM_ADDRESS: () => SUI_SYSTEM_ADDRESS2,
      SUI_SYSTEM_MODULE_NAME: () => SUI_SYSTEM_MODULE_NAME2,
      SUI_SYSTEM_STATE_OBJECT_ID: () => SUI_SYSTEM_STATE_OBJECT_ID2,
      SUI_TYPE_ARG: () => SUI_TYPE_ARG2
    });
    module2.exports = __toCommonJS2(constants_exports);
    var import_sui_types14 = require_sui_types();
    var SUI_DECIMALS2 = 9;
    var MIST_PER_SUI2 = BigInt(1e9);
    var MOVE_STDLIB_ADDRESS2 = "0x1";
    var SUI_FRAMEWORK_ADDRESS2 = "0x2";
    var SUI_SYSTEM_ADDRESS2 = "0x3";
    var SUI_CLOCK_OBJECT_ID2 = (0, import_sui_types14.normalizeSuiObjectId)("0x6");
    var SUI_SYSTEM_MODULE_NAME2 = "sui_system";
    var SUI_TYPE_ARG2 = `${SUI_FRAMEWORK_ADDRESS2}::sui::SUI`;
    var SUI_SYSTEM_STATE_OBJECT_ID2 = (0, import_sui_types14.normalizeSuiObjectId)("0x5");
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/move-registry.js
var require_move_registry = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/move-registry.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var move_registry_exports = {};
    __export2(move_registry_exports, {
      isValidNamedPackage: () => isValidNamedPackage,
      isValidNamedType: () => isValidNamedType
    });
    module2.exports = __toCommonJS2(move_registry_exports);
    var import_suins2 = require_suins();
    var NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;
    var VERSION_REGEX = /^\d+$/;
    var MAX_APP_SIZE = 64;
    var NAME_SEPARATOR = "/";
    var isValidNamedPackage = (name) => {
      const parts = name.split(NAME_SEPARATOR);
      if (parts.length < 2 || parts.length > 3) return false;
      const [org, app, version] = parts;
      if (version !== void 0 && !VERSION_REGEX.test(version)) return false;
      if (!(0, import_suins2.isValidSuiNSName)(org)) return false;
      return NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;
    };
    var isValidNamedType = (type) => {
      const splitType = type.split(/::|<|>|,/);
      for (const t of splitType) {
        if (t.includes(NAME_SEPARATOR) && !isValidNamedPackage(t)) return false;
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS({
  "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/cryptoNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    var nc = require("crypto");
    exports2.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && "randomBytes" in nc ? nc : void 0;
  }
});

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.Hash = exports2.nextTick = exports2.swap32IfBE = exports2.byteSwapIfBE = exports2.swap8IfBE = exports2.isLE = void 0;
    exports2.isBytes = isBytes2;
    exports2.anumber = anumber2;
    exports2.abytes = abytes2;
    exports2.ahash = ahash;
    exports2.aexists = aexists2;
    exports2.aoutput = aoutput2;
    exports2.u8 = u8;
    exports2.u32 = u322;
    exports2.clean = clean2;
    exports2.createView = createView;
    exports2.rotr = rotr;
    exports2.rotl = rotl;
    exports2.byteSwap = byteSwap2;
    exports2.byteSwap32 = byteSwap322;
    exports2.bytesToHex = bytesToHex;
    exports2.hexToBytes = hexToBytes;
    exports2.asyncLoop = asyncLoop;
    exports2.utf8ToBytes = utf8ToBytes2;
    exports2.bytesToUtf8 = bytesToUtf8;
    exports2.toBytes = toBytes2;
    exports2.kdfInputToBytes = kdfInputToBytes;
    exports2.concatBytes = concatBytes;
    exports2.checkOpts = checkOpts;
    exports2.createHasher = createHasher;
    exports2.createOptHasher = createOptHasher2;
    exports2.createXOFer = createXOFer;
    exports2.randomBytes = randomBytes;
    var crypto_1 = require_cryptoNode();
    function isBytes2(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber2(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes2(b2, ...lengths) {
      if (!isBytes2(b2))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b2.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber2(h.outputLen);
      anumber2(h.blockLen);
    }
    function aexists2(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput2(out, instance) {
      abytes2(out);
      const min3 = instance.outputLen;
      if (out.length < min3) {
        throw new Error("digestInto() expects output buffer of length at least " + min3);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u322(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean2(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap2(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports2.swap8IfBE = exports2.isLE ? (n) => n : (n) => byteSwap2(n);
    exports2.byteSwapIfBE = exports2.swap8IfBE;
    function byteSwap322(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap2(arr[i]);
      }
      return arr;
    }
    exports2.swap32IfBE = exports2.isLE ? (u) => u : byteSwap322;
    var hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes2(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl2 = hex.length;
      const al2 = hl2 / 2;
      if (hl2 % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl2);
      const array2 = new Uint8Array(al2);
      for (let ai = 0, hi3 = 0; ai < al2; ai++, hi3 += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi3));
        const n2 = asciiToBase16(hex.charCodeAt(hi3 + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi3] + hex[hi3 + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi3);
        }
        array2[ai] = n1 * 16 + n2;
      }
      return array2;
    }
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts2 = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts2;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts2 += diff;
      }
    }
    function utf8ToBytes2(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes2(data);
      abytes2(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes2(data);
      abytes2(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum3 = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes2(a);
        sum3 += a.length;
      }
      const res = new Uint8Array(sum3);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash2 = class {
    };
    exports2.Hash = Hash2;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher2(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapConstructor = createHasher;
    exports2.wrapConstructorWithOpts = createOptHasher2;
    exports2.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_blake.js
var require_blake = __commonJS({
  "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_blake.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BSIGMA = void 0;
    exports2.G1s = G1s2;
    exports2.G2s = G2s2;
    var utils_ts_1 = require_utils3();
    exports2.BSIGMA = Uint8Array.from([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      // Blake1, unused in others
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9
    ]);
    function G1s2(a, b2, c, d, x2) {
      a = a + b2 + x2 | 0;
      d = (0, utils_ts_1.rotr)(d ^ a, 16);
      c = c + d | 0;
      b2 = (0, utils_ts_1.rotr)(b2 ^ c, 12);
      return { a, b: b2, c, d };
    }
    function G2s2(a, b2, c, d, x2) {
      a = a + b2 + x2 | 0;
      d = (0, utils_ts_1.rotr)(d ^ a, 8);
      c = c + d | 0;
      b2 = (0, utils_ts_1.rotr)(b2 ^ c, 7);
      return { a, b: b2, c, d };
    }
  }
});

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SHA512_IV = exports2.SHA384_IV = exports2.SHA224_IV = exports2.SHA256_IV = exports2.HashMD = void 0;
    exports2.setBigUint64 = setBigUint64;
    exports2.Chi = Chi;
    exports2.Maj = Maj;
    var utils_ts_1 = require_utils3();
    function setBigUint64(view, byteOffset, value, isLE2) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE2);
      const _32n2 = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n2 & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE2 ? 4 : 0;
      const l = isLE2 ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE2);
      view.setUint32(byteOffset + l, wl, isLE2);
    }
    function Chi(a, b2, c) {
      return a & b2 ^ ~a & c;
    }
    function Maj(a, b2, c) {
      return a & b2 ^ a & c ^ b2 & c;
    }
    var HashMD = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_ts_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE2);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports2.HashMD = HashMD;
    exports2.SHA256_IV = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    exports2.SHA224_IV = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    exports2.SHA384_IV = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    exports2.SHA512_IV = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toBig = exports2.shrSL = exports2.shrSH = exports2.rotrSL = exports2.rotrSH = exports2.rotrBL = exports2.rotrBH = exports2.rotr32L = exports2.rotr32H = exports2.rotlSL = exports2.rotlSH = exports2.rotlBL = exports2.rotlBH = exports2.add5L = exports2.add5H = exports2.add4L = exports2.add4H = exports2.add3L = exports2.add3H = void 0;
    exports2.add = add4;
    exports2.fromBig = fromBig2;
    exports2.split = split;
    var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n2 = /* @__PURE__ */ BigInt(32);
    function fromBig2(n, le2 = false) {
      if (le2)
        return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
      return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
    }
    function split(lst, le2 = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig2(lst[i], le2);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
    exports2.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports2.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.shrSL = shrSL;
    var rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
    exports2.rotrSH = rotrSH2;
    var rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
    exports2.rotrSL = rotrSL2;
    var rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports2.rotrBH = rotrBH2;
    var rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports2.rotrBL = rotrBL2;
    var rotr32H2 = (_h, l) => l;
    exports2.rotr32H = rotr32H2;
    var rotr32L2 = (h, _l) => h;
    exports2.rotr32L = rotr32L2;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports2.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports2.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports2.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports2.rotlBL = rotlBL;
    function add4(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports2.add3L = add3L2;
    var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports2.add3H = add3H2;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports2.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports2.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports2.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports2.add5H = add5H;
    var u64 = {
      fromBig: fromBig2,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH: rotrSH2,
      rotrSL: rotrSL2,
      rotrBH: rotrBH2,
      rotrBL: rotrBL2,
      rotr32H: rotr32H2,
      rotr32L: rotr32L2,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add: add4,
      add3L: add3L2,
      add3H: add3H2,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports2.default = u64;
  }
});

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/blake2.js
var require_blake2 = __commonJS({
  "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/blake2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.blake2s = exports2.BLAKE2s = exports2.blake2b = exports2.BLAKE2b = exports2.BLAKE2 = void 0;
    exports2.compress = compress;
    var _blake_ts_1 = require_blake();
    var _md_ts_1 = require_md();
    var u64 = require_u64();
    var utils_ts_1 = require_utils3();
    var B2B_IV2 = /* @__PURE__ */ Uint32Array.from([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var BBUF2 = /* @__PURE__ */ new Uint32Array(32);
    function G1b2(a, b2, c, d, msg, x2) {
      const Xl = msg[x2], Xh = msg[x2 + 1];
      let Al = BBUF2[2 * a], Ah = BBUF2[2 * a + 1];
      let Bl = BBUF2[2 * b2], Bh = BBUF2[2 * b2 + 1];
      let Cl = BBUF2[2 * c], Ch = BBUF2[2 * c + 1];
      let Dl = BBUF2[2 * d], Dh = BBUF2[2 * d + 1];
      let ll = u64.add3L(Al, Bl, Xl);
      Ah = u64.add3H(ll, Ah, Bh, Xh);
      Al = ll | 0;
      ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
      ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });
      ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));
      ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
      ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });
      BBUF2[2 * a] = Al, BBUF2[2 * a + 1] = Ah;
      BBUF2[2 * b2] = Bl, BBUF2[2 * b2 + 1] = Bh;
      BBUF2[2 * c] = Cl, BBUF2[2 * c + 1] = Ch;
      BBUF2[2 * d] = Dl, BBUF2[2 * d + 1] = Dh;
    }
    function G2b2(a, b2, c, d, msg, x2) {
      const Xl = msg[x2], Xh = msg[x2 + 1];
      let Al = BBUF2[2 * a], Ah = BBUF2[2 * a + 1];
      let Bl = BBUF2[2 * b2], Bh = BBUF2[2 * b2 + 1];
      let Cl = BBUF2[2 * c], Ch = BBUF2[2 * c + 1];
      let Dl = BBUF2[2 * d], Dh = BBUF2[2 * d + 1];
      let ll = u64.add3L(Al, Bl, Xl);
      Ah = u64.add3H(ll, Ah, Bh, Xh);
      Al = ll | 0;
      ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
      ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });
      ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));
      ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
      ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });
      BBUF2[2 * a] = Al, BBUF2[2 * a + 1] = Ah;
      BBUF2[2 * b2] = Bl, BBUF2[2 * b2 + 1] = Bh;
      BBUF2[2 * c] = Cl, BBUF2[2 * c + 1] = Ch;
      BBUF2[2 * d] = Dl, BBUF2[2 * d + 1] = Dh;
    }
    function checkBlake2Opts2(outputLen, opts = {}, keyLen, saltLen, persLen) {
      (0, utils_ts_1.anumber)(keyLen);
      if (outputLen < 0 || outputLen > keyLen)
        throw new Error("outputLen bigger than keyLen");
      const { key, salt, personalization } = opts;
      if (key !== void 0 && (key.length < 1 || key.length > keyLen))
        throw new Error("key length must be undefined or 1.." + keyLen);
      if (salt !== void 0 && salt.length !== saltLen)
        throw new Error("salt must be undefined or " + saltLen);
      if (personalization !== void 0 && personalization.length !== persLen)
        throw new Error("personalization must be undefined or " + persLen);
    }
    var BLAKE22 = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen) {
        super();
        this.finished = false;
        this.destroyed = false;
        this.length = 0;
        this.pos = 0;
        (0, utils_ts_1.anumber)(blockLen);
        (0, utils_ts_1.anumber)(outputLen);
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.buffer = new Uint8Array(blockLen);
        this.buffer32 = (0, utils_ts_1.u32)(this.buffer);
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, buffer, buffer32 } = this;
        const len = data.length;
        const offset = data.byteOffset;
        const buf = data.buffer;
        for (let pos = 0; pos < len; ) {
          if (this.pos === blockLen) {
            (0, utils_ts_1.swap32IfBE)(buffer32);
            this.compress(buffer32, 0, false);
            (0, utils_ts_1.swap32IfBE)(buffer32);
            this.pos = 0;
          }
          const take = Math.min(blockLen - this.pos, len - pos);
          const dataOffset = offset + pos;
          if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
            const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
            (0, utils_ts_1.swap32IfBE)(data32);
            for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
              this.length += blockLen;
              this.compress(data32, pos32, false);
            }
            (0, utils_ts_1.swap32IfBE)(data32);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          this.length += take;
          pos += take;
        }
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        const { pos, buffer32 } = this;
        this.finished = true;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        (0, utils_ts_1.swap32IfBE)(buffer32);
        this.compress(buffer32, 0, true);
        (0, utils_ts_1.swap32IfBE)(buffer32);
        const out32 = (0, utils_ts_1.u32)(out);
        this.get().forEach((v, i) => out32[i] = (0, utils_ts_1.swap8IfBE)(v));
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        const { buffer, length, finished, destroyed, outputLen, pos } = this;
        to || (to = new this.constructor({ dkLen: outputLen }));
        to.set(...this.get());
        to.buffer.set(buffer);
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        to.outputLen = outputLen;
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports2.BLAKE2 = BLAKE22;
    var BLAKE2b2 = class extends BLAKE22 {
      constructor(opts = {}) {
        const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
        super(128, olen);
        this.v0l = B2B_IV2[0] | 0;
        this.v0h = B2B_IV2[1] | 0;
        this.v1l = B2B_IV2[2] | 0;
        this.v1h = B2B_IV2[3] | 0;
        this.v2l = B2B_IV2[4] | 0;
        this.v2h = B2B_IV2[5] | 0;
        this.v3l = B2B_IV2[6] | 0;
        this.v3h = B2B_IV2[7] | 0;
        this.v4l = B2B_IV2[8] | 0;
        this.v4h = B2B_IV2[9] | 0;
        this.v5l = B2B_IV2[10] | 0;
        this.v5h = B2B_IV2[11] | 0;
        this.v6l = B2B_IV2[12] | 0;
        this.v6h = B2B_IV2[13] | 0;
        this.v7l = B2B_IV2[14] | 0;
        this.v7h = B2B_IV2[15] | 0;
        checkBlake2Opts2(olen, opts, 64, 16, 16);
        let { key, personalization, salt } = opts;
        let keyLength = 0;
        if (key !== void 0) {
          key = (0, utils_ts_1.toBytes)(key);
          keyLength = key.length;
        }
        this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
        if (salt !== void 0) {
          salt = (0, utils_ts_1.toBytes)(salt);
          const slt = (0, utils_ts_1.u32)(salt);
          this.v4l ^= (0, utils_ts_1.swap8IfBE)(slt[0]);
          this.v4h ^= (0, utils_ts_1.swap8IfBE)(slt[1]);
          this.v5l ^= (0, utils_ts_1.swap8IfBE)(slt[2]);
          this.v5h ^= (0, utils_ts_1.swap8IfBE)(slt[3]);
        }
        if (personalization !== void 0) {
          personalization = (0, utils_ts_1.toBytes)(personalization);
          const pers = (0, utils_ts_1.u32)(personalization);
          this.v6l ^= (0, utils_ts_1.swap8IfBE)(pers[0]);
          this.v6h ^= (0, utils_ts_1.swap8IfBE)(pers[1]);
          this.v7l ^= (0, utils_ts_1.swap8IfBE)(pers[2]);
          this.v7h ^= (0, utils_ts_1.swap8IfBE)(pers[3]);
        }
        if (key !== void 0) {
          const tmp = new Uint8Array(this.blockLen);
          tmp.set(key);
          this.update(tmp);
        }
      }
      // prettier-ignore
      get() {
        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
      }
      // prettier-ignore
      set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
        this.v0l = v0l | 0;
        this.v0h = v0h | 0;
        this.v1l = v1l | 0;
        this.v1h = v1h | 0;
        this.v2l = v2l | 0;
        this.v2h = v2h | 0;
        this.v3l = v3l | 0;
        this.v3h = v3h | 0;
        this.v4l = v4l | 0;
        this.v4h = v4h | 0;
        this.v5l = v5l | 0;
        this.v5h = v5h | 0;
        this.v6l = v6l | 0;
        this.v6h = v6h | 0;
        this.v7l = v7l | 0;
        this.v7h = v7h | 0;
      }
      compress(msg, offset, isLast) {
        this.get().forEach((v, i) => BBUF2[i] = v);
        BBUF2.set(B2B_IV2, 16);
        let { h, l } = u64.fromBig(BigInt(this.length));
        BBUF2[24] = B2B_IV2[8] ^ l;
        BBUF2[25] = B2B_IV2[9] ^ h;
        if (isLast) {
          BBUF2[28] = ~BBUF2[28];
          BBUF2[29] = ~BBUF2[29];
        }
        let j2 = 0;
        const s = _blake_ts_1.BSIGMA;
        for (let i = 0; i < 12; i++) {
          G1b2(0, 4, 8, 12, msg, offset + 2 * s[j2++]);
          G2b2(0, 4, 8, 12, msg, offset + 2 * s[j2++]);
          G1b2(1, 5, 9, 13, msg, offset + 2 * s[j2++]);
          G2b2(1, 5, 9, 13, msg, offset + 2 * s[j2++]);
          G1b2(2, 6, 10, 14, msg, offset + 2 * s[j2++]);
          G2b2(2, 6, 10, 14, msg, offset + 2 * s[j2++]);
          G1b2(3, 7, 11, 15, msg, offset + 2 * s[j2++]);
          G2b2(3, 7, 11, 15, msg, offset + 2 * s[j2++]);
          G1b2(0, 5, 10, 15, msg, offset + 2 * s[j2++]);
          G2b2(0, 5, 10, 15, msg, offset + 2 * s[j2++]);
          G1b2(1, 6, 11, 12, msg, offset + 2 * s[j2++]);
          G2b2(1, 6, 11, 12, msg, offset + 2 * s[j2++]);
          G1b2(2, 7, 8, 13, msg, offset + 2 * s[j2++]);
          G2b2(2, 7, 8, 13, msg, offset + 2 * s[j2++]);
          G1b2(3, 4, 9, 14, msg, offset + 2 * s[j2++]);
          G2b2(3, 4, 9, 14, msg, offset + 2 * s[j2++]);
        }
        this.v0l ^= BBUF2[0] ^ BBUF2[16];
        this.v0h ^= BBUF2[1] ^ BBUF2[17];
        this.v1l ^= BBUF2[2] ^ BBUF2[18];
        this.v1h ^= BBUF2[3] ^ BBUF2[19];
        this.v2l ^= BBUF2[4] ^ BBUF2[20];
        this.v2h ^= BBUF2[5] ^ BBUF2[21];
        this.v3l ^= BBUF2[6] ^ BBUF2[22];
        this.v3h ^= BBUF2[7] ^ BBUF2[23];
        this.v4l ^= BBUF2[8] ^ BBUF2[24];
        this.v4h ^= BBUF2[9] ^ BBUF2[25];
        this.v5l ^= BBUF2[10] ^ BBUF2[26];
        this.v5h ^= BBUF2[11] ^ BBUF2[27];
        this.v6l ^= BBUF2[12] ^ BBUF2[28];
        this.v6h ^= BBUF2[13] ^ BBUF2[29];
        this.v7l ^= BBUF2[14] ^ BBUF2[30];
        this.v7h ^= BBUF2[15] ^ BBUF2[31];
        (0, utils_ts_1.clean)(BBUF2);
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer32);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports2.BLAKE2b = BLAKE2b2;
    exports2.blake2b = (0, utils_ts_1.createOptHasher)((opts) => new BLAKE2b2(opts));
    function compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
      let j2 = 0;
      for (let i = 0; i < rounds; i++) {
        ({ a: v0, b: v4, c: v8, d: v12 } = (0, _blake_ts_1.G1s)(v0, v4, v8, v12, msg[offset + s[j2++]]));
        ({ a: v0, b: v4, c: v8, d: v12 } = (0, _blake_ts_1.G2s)(v0, v4, v8, v12, msg[offset + s[j2++]]));
        ({ a: v1, b: v5, c: v9, d: v13 } = (0, _blake_ts_1.G1s)(v1, v5, v9, v13, msg[offset + s[j2++]]));
        ({ a: v1, b: v5, c: v9, d: v13 } = (0, _blake_ts_1.G2s)(v1, v5, v9, v13, msg[offset + s[j2++]]));
        ({ a: v2, b: v6, c: v10, d: v14 } = (0, _blake_ts_1.G1s)(v2, v6, v10, v14, msg[offset + s[j2++]]));
        ({ a: v2, b: v6, c: v10, d: v14 } = (0, _blake_ts_1.G2s)(v2, v6, v10, v14, msg[offset + s[j2++]]));
        ({ a: v3, b: v7, c: v11, d: v15 } = (0, _blake_ts_1.G1s)(v3, v7, v11, v15, msg[offset + s[j2++]]));
        ({ a: v3, b: v7, c: v11, d: v15 } = (0, _blake_ts_1.G2s)(v3, v7, v11, v15, msg[offset + s[j2++]]));
        ({ a: v0, b: v5, c: v10, d: v15 } = (0, _blake_ts_1.G1s)(v0, v5, v10, v15, msg[offset + s[j2++]]));
        ({ a: v0, b: v5, c: v10, d: v15 } = (0, _blake_ts_1.G2s)(v0, v5, v10, v15, msg[offset + s[j2++]]));
        ({ a: v1, b: v6, c: v11, d: v12 } = (0, _blake_ts_1.G1s)(v1, v6, v11, v12, msg[offset + s[j2++]]));
        ({ a: v1, b: v6, c: v11, d: v12 } = (0, _blake_ts_1.G2s)(v1, v6, v11, v12, msg[offset + s[j2++]]));
        ({ a: v2, b: v7, c: v8, d: v13 } = (0, _blake_ts_1.G1s)(v2, v7, v8, v13, msg[offset + s[j2++]]));
        ({ a: v2, b: v7, c: v8, d: v13 } = (0, _blake_ts_1.G2s)(v2, v7, v8, v13, msg[offset + s[j2++]]));
        ({ a: v3, b: v4, c: v9, d: v14 } = (0, _blake_ts_1.G1s)(v3, v4, v9, v14, msg[offset + s[j2++]]));
        ({ a: v3, b: v4, c: v9, d: v14 } = (0, _blake_ts_1.G2s)(v3, v4, v9, v14, msg[offset + s[j2++]]));
      }
      return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };
    }
    var B2S_IV = _md_ts_1.SHA256_IV;
    var BLAKE2s = class extends BLAKE22 {
      constructor(opts = {}) {
        const olen = opts.dkLen === void 0 ? 32 : opts.dkLen;
        super(64, olen);
        this.v0 = B2S_IV[0] | 0;
        this.v1 = B2S_IV[1] | 0;
        this.v2 = B2S_IV[2] | 0;
        this.v3 = B2S_IV[3] | 0;
        this.v4 = B2S_IV[4] | 0;
        this.v5 = B2S_IV[5] | 0;
        this.v6 = B2S_IV[6] | 0;
        this.v7 = B2S_IV[7] | 0;
        checkBlake2Opts2(olen, opts, 32, 8, 8);
        let { key, personalization, salt } = opts;
        let keyLength = 0;
        if (key !== void 0) {
          key = (0, utils_ts_1.toBytes)(key);
          keyLength = key.length;
        }
        this.v0 ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
        if (salt !== void 0) {
          salt = (0, utils_ts_1.toBytes)(salt);
          const slt = (0, utils_ts_1.u32)(salt);
          this.v4 ^= (0, utils_ts_1.swap8IfBE)(slt[0]);
          this.v5 ^= (0, utils_ts_1.swap8IfBE)(slt[1]);
        }
        if (personalization !== void 0) {
          personalization = (0, utils_ts_1.toBytes)(personalization);
          const pers = (0, utils_ts_1.u32)(personalization);
          this.v6 ^= (0, utils_ts_1.swap8IfBE)(pers[0]);
          this.v7 ^= (0, utils_ts_1.swap8IfBE)(pers[1]);
        }
        if (key !== void 0) {
          (0, utils_ts_1.abytes)(key);
          const tmp = new Uint8Array(this.blockLen);
          tmp.set(key);
          this.update(tmp);
        }
      }
      get() {
        const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;
        return [v0, v1, v2, v3, v4, v5, v6, v7];
      }
      // prettier-ignore
      set(v0, v1, v2, v3, v4, v5, v6, v7) {
        this.v0 = v0 | 0;
        this.v1 = v1 | 0;
        this.v2 = v2 | 0;
        this.v3 = v3 | 0;
        this.v4 = v4 | 0;
        this.v5 = v5 | 0;
        this.v6 = v6 | 0;
        this.v7 = v7 | 0;
      }
      compress(msg, offset, isLast) {
        const { h, l } = u64.fromBig(BigInt(this.length));
        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(_blake_ts_1.BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);
        this.v0 ^= v0 ^ v8;
        this.v1 ^= v1 ^ v9;
        this.v2 ^= v2 ^ v10;
        this.v3 ^= v3 ^ v11;
        this.v4 ^= v4 ^ v12;
        this.v5 ^= v5 ^ v13;
        this.v6 ^= v6 ^ v14;
        this.v7 ^= v7 ^ v15;
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer32);
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports2.BLAKE2s = BLAKE2s;
    exports2.blake2s = (0, utils_ts_1.createOptHasher)((opts) => new BLAKE2s(opts));
  }
});

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/blake2b.js
var require_blake2b = __commonJS({
  "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/blake2b.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.blake2b = exports2.BLAKE2b = void 0;
    var blake2_ts_1 = require_blake2();
    exports2.BLAKE2b = blake2_ts_1.BLAKE2b;
    exports2.blake2b = blake2_ts_1.blake2b;
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/bcs/type-tag-serializer.js
var require_type_tag_serializer = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/bcs/type-tag-serializer.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var type_tag_serializer_exports = {};
    __export2(type_tag_serializer_exports, {
      TypeTagSerializer: () => TypeTagSerializer2
    });
    module2.exports = __toCommonJS2(type_tag_serializer_exports);
    var import_bcs34 = require_cjs5();
    var import_sui_types14 = require_sui_types();
    var VECTOR_REGEX2 = /^vector<(.+)>$/;
    var STRUCT_REGEX2 = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
    var TypeTagSerializer2 = class _TypeTagSerializer {
      static parseFromStr(str, normalizeAddress = false) {
        if (str === "address") {
          return { address: null };
        } else if (str === "bool") {
          return { bool: null };
        } else if (str === "u8") {
          return { u8: null };
        } else if (str === "u16") {
          return { u16: null };
        } else if (str === "u32") {
          return { u32: null };
        } else if (str === "u64") {
          return { u64: null };
        } else if (str === "u128") {
          return { u128: null };
        } else if (str === "u256") {
          return { u256: null };
        } else if (str === "signer") {
          return { signer: null };
        }
        const vectorMatch = str.match(VECTOR_REGEX2);
        if (vectorMatch) {
          return {
            vector: _TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
          };
        }
        const structMatch = str.match(STRUCT_REGEX2);
        if (structMatch) {
          const address = normalizeAddress ? (0, import_sui_types14.normalizeSuiAddress)(structMatch[1]) : structMatch[1];
          return {
            struct: {
              address,
              module: structMatch[2],
              name: structMatch[3],
              typeParams: structMatch[5] === void 0 ? [] : _TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
            }
          };
        }
        throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
      }
      static parseStructTypeArgs(str, normalizeAddress = false) {
        return (0, import_bcs34.splitGenericParameters)(str).map(
          (tok) => _TypeTagSerializer.parseFromStr(tok, normalizeAddress)
        );
      }
      static tagToString(tag3) {
        if ("bool" in tag3) {
          return "bool";
        }
        if ("u8" in tag3) {
          return "u8";
        }
        if ("u16" in tag3) {
          return "u16";
        }
        if ("u32" in tag3) {
          return "u32";
        }
        if ("u64" in tag3) {
          return "u64";
        }
        if ("u128" in tag3) {
          return "u128";
        }
        if ("u256" in tag3) {
          return "u256";
        }
        if ("address" in tag3) {
          return "address";
        }
        if ("signer" in tag3) {
          return "signer";
        }
        if ("vector" in tag3) {
          return `vector<${_TypeTagSerializer.tagToString(tag3.vector)}>`;
        }
        if ("struct" in tag3) {
          const struct = tag3.struct;
          const typeParams = struct.typeParams.map(_TypeTagSerializer.tagToString).join(", ");
          return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
        }
        throw new Error("Invalid TypeTag");
      }
    };
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/bcs/bcs.js
var require_bcs2 = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/bcs/bcs.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var bcs_exports = {};
    __export2(bcs_exports, {
      Address: () => Address2,
      AppId: () => AppId2,
      Argument: () => Argument4,
      CallArg: () => CallArg4,
      Command: () => Command4,
      CompressedSignature: () => CompressedSignature2,
      GasData: () => GasData4,
      Intent: () => Intent2,
      IntentMessage: () => IntentMessage2,
      IntentScope: () => IntentScope2,
      IntentVersion: () => IntentVersion2,
      MultiSig: () => MultiSig2,
      MultiSigPkMap: () => MultiSigPkMap2,
      MultiSigPublicKey: () => MultiSigPublicKey2,
      ObjectArg: () => ObjectArg5,
      ObjectDigest: () => ObjectDigest2,
      PasskeyAuthenticator: () => PasskeyAuthenticator2,
      ProgrammableMoveCall: () => ProgrammableMoveCall4,
      ProgrammableTransaction: () => ProgrammableTransaction2,
      PublicKey: () => PublicKey2,
      SenderSignedData: () => SenderSignedData2,
      SenderSignedTransaction: () => SenderSignedTransaction2,
      SharedObjectRef: () => SharedObjectRef2,
      StructTag: () => StructTag4,
      SuiObjectRef: () => SuiObjectRef2,
      TransactionData: () => TransactionData3,
      TransactionDataV1: () => TransactionDataV12,
      TransactionExpiration: () => TransactionExpiration5,
      TransactionKind: () => TransactionKind2,
      TypeTag: () => TypeTag3,
      base64String: () => base64String2
    });
    module2.exports = __toCommonJS2(bcs_exports);
    var import_bcs34 = require_cjs5();
    var import_sui_types14 = require_sui_types();
    var import_type_tag_serializer3 = require_type_tag_serializer();
    function unsafe_u642(options) {
      return import_bcs34.bcs.u64(__spreadValues({
        name: "unsafe_u64"
      }, options)).transform({
        input: (val) => val,
        output: (val) => Number(val)
      });
    }
    function optionEnum2(type) {
      return import_bcs34.bcs.enum("Option", {
        None: null,
        Some: type
      });
    }
    var Address2 = import_bcs34.bcs.bytes(import_sui_types14.SUI_ADDRESS_LENGTH).transform({
      validate: (val) => {
        const address = typeof val === "string" ? val : (0, import_bcs34.toHex)(val);
        if (!address || !(0, import_sui_types14.isValidSuiAddress)((0, import_sui_types14.normalizeSuiAddress)(address))) {
          throw new Error(`Invalid Sui address ${address}`);
        }
      },
      input: (val) => typeof val === "string" ? (0, import_bcs34.fromHex)((0, import_sui_types14.normalizeSuiAddress)(val)) : val,
      output: (val) => (0, import_sui_types14.normalizeSuiAddress)((0, import_bcs34.toHex)(val))
    });
    var ObjectDigest2 = import_bcs34.bcs.vector(import_bcs34.bcs.u8()).transform({
      name: "ObjectDigest",
      input: (value) => (0, import_bcs34.fromBase58)(value),
      output: (value) => (0, import_bcs34.toBase58)(new Uint8Array(value)),
      validate: (value) => {
        if ((0, import_bcs34.fromBase58)(value).length !== 32) {
          throw new Error("ObjectDigest must be 32 bytes");
        }
      }
    });
    var SuiObjectRef2 = import_bcs34.bcs.struct("SuiObjectRef", {
      objectId: Address2,
      version: import_bcs34.bcs.u64(),
      digest: ObjectDigest2
    });
    var SharedObjectRef2 = import_bcs34.bcs.struct("SharedObjectRef", {
      objectId: Address2,
      initialSharedVersion: import_bcs34.bcs.u64(),
      mutable: import_bcs34.bcs.bool()
    });
    var ObjectArg5 = import_bcs34.bcs.enum("ObjectArg", {
      ImmOrOwnedObject: SuiObjectRef2,
      SharedObject: SharedObjectRef2,
      Receiving: SuiObjectRef2
    });
    var CallArg4 = import_bcs34.bcs.enum("CallArg", {
      Pure: import_bcs34.bcs.struct("Pure", {
        bytes: import_bcs34.bcs.vector(import_bcs34.bcs.u8()).transform({
          input: (val) => typeof val === "string" ? (0, import_bcs34.fromBase64)(val) : val,
          output: (val) => (0, import_bcs34.toBase64)(new Uint8Array(val))
        })
      }),
      Object: ObjectArg5
    });
    var InnerTypeTag2 = import_bcs34.bcs.enum("TypeTag", {
      bool: null,
      u8: null,
      u64: null,
      u128: null,
      address: null,
      signer: null,
      vector: import_bcs34.bcs.lazy(() => InnerTypeTag2),
      struct: import_bcs34.bcs.lazy(() => StructTag4),
      u16: null,
      u32: null,
      u256: null
    });
    var TypeTag3 = InnerTypeTag2.transform({
      input: (typeTag) => typeof typeTag === "string" ? import_type_tag_serializer3.TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,
      output: (typeTag) => import_type_tag_serializer3.TypeTagSerializer.tagToString(typeTag)
    });
    var Argument4 = import_bcs34.bcs.enum("Argument", {
      GasCoin: null,
      Input: import_bcs34.bcs.u16(),
      Result: import_bcs34.bcs.u16(),
      NestedResult: import_bcs34.bcs.tuple([import_bcs34.bcs.u16(), import_bcs34.bcs.u16()])
    });
    var ProgrammableMoveCall4 = import_bcs34.bcs.struct("ProgrammableMoveCall", {
      package: Address2,
      module: import_bcs34.bcs.string(),
      function: import_bcs34.bcs.string(),
      typeArguments: import_bcs34.bcs.vector(TypeTag3),
      arguments: import_bcs34.bcs.vector(Argument4)
    });
    var Command4 = import_bcs34.bcs.enum("Command", {
      /**
       * A Move Call - any public Move function can be called via
       * this transaction. The results can be used that instant to pass
       * into the next transaction.
       */
      MoveCall: ProgrammableMoveCall4,
      /**
       * Transfer vector of objects to a receiver.
       */
      TransferObjects: import_bcs34.bcs.struct("TransferObjects", {
        objects: import_bcs34.bcs.vector(Argument4),
        address: Argument4
      }),
      // /**
      //  * Split `amount` from a `coin`.
      //  */
      SplitCoins: import_bcs34.bcs.struct("SplitCoins", {
        coin: Argument4,
        amounts: import_bcs34.bcs.vector(Argument4)
      }),
      // /**
      //  * Merge Vector of Coins (`sources`) into a `destination`.
      //  */
      MergeCoins: import_bcs34.bcs.struct("MergeCoins", {
        destination: Argument4,
        sources: import_bcs34.bcs.vector(Argument4)
      }),
      // /**
      //  * Publish a Move module.
      //  */
      Publish: import_bcs34.bcs.struct("Publish", {
        modules: import_bcs34.bcs.vector(
          import_bcs34.bcs.vector(import_bcs34.bcs.u8()).transform({
            input: (val) => typeof val === "string" ? (0, import_bcs34.fromBase64)(val) : val,
            output: (val) => (0, import_bcs34.toBase64)(new Uint8Array(val))
          })
        ),
        dependencies: import_bcs34.bcs.vector(Address2)
      }),
      // /**
      //  * Build a vector of objects using the input arguments.
      //  * It is impossible to export construct a `vector<T: key>` otherwise,
      //  * so this call serves a utility function.
      //  */
      MakeMoveVec: import_bcs34.bcs.struct("MakeMoveVec", {
        type: optionEnum2(TypeTag3).transform({
          input: (val) => val === null ? {
            None: true
          } : {
            Some: val
          },
          output: (val) => {
            var _a7;
            return (_a7 = val.Some) != null ? _a7 : null;
          }
        }),
        elements: import_bcs34.bcs.vector(Argument4)
      }),
      Upgrade: import_bcs34.bcs.struct("Upgrade", {
        modules: import_bcs34.bcs.vector(
          import_bcs34.bcs.vector(import_bcs34.bcs.u8()).transform({
            input: (val) => typeof val === "string" ? (0, import_bcs34.fromBase64)(val) : val,
            output: (val) => (0, import_bcs34.toBase64)(new Uint8Array(val))
          })
        ),
        dependencies: import_bcs34.bcs.vector(Address2),
        package: Address2,
        ticket: Argument4
      })
    });
    var ProgrammableTransaction2 = import_bcs34.bcs.struct("ProgrammableTransaction", {
      inputs: import_bcs34.bcs.vector(CallArg4),
      commands: import_bcs34.bcs.vector(Command4)
    });
    var TransactionKind2 = import_bcs34.bcs.enum("TransactionKind", {
      ProgrammableTransaction: ProgrammableTransaction2,
      ChangeEpoch: null,
      Genesis: null,
      ConsensusCommitPrologue: null
    });
    var TransactionExpiration5 = import_bcs34.bcs.enum("TransactionExpiration", {
      None: null,
      Epoch: unsafe_u642()
    });
    var StructTag4 = import_bcs34.bcs.struct("StructTag", {
      address: Address2,
      module: import_bcs34.bcs.string(),
      name: import_bcs34.bcs.string(),
      typeParams: import_bcs34.bcs.vector(InnerTypeTag2)
    });
    var GasData4 = import_bcs34.bcs.struct("GasData", {
      payment: import_bcs34.bcs.vector(SuiObjectRef2),
      owner: Address2,
      price: import_bcs34.bcs.u64(),
      budget: import_bcs34.bcs.u64()
    });
    var TransactionDataV12 = import_bcs34.bcs.struct("TransactionDataV1", {
      kind: TransactionKind2,
      sender: Address2,
      gasData: GasData4,
      expiration: TransactionExpiration5
    });
    var TransactionData3 = import_bcs34.bcs.enum("TransactionData", {
      V1: TransactionDataV12
    });
    var IntentScope2 = import_bcs34.bcs.enum("IntentScope", {
      TransactionData: null,
      TransactionEffects: null,
      CheckpointSummary: null,
      PersonalMessage: null
    });
    var IntentVersion2 = import_bcs34.bcs.enum("IntentVersion", {
      V0: null
    });
    var AppId2 = import_bcs34.bcs.enum("AppId", {
      Sui: null
    });
    var Intent2 = import_bcs34.bcs.struct("Intent", {
      scope: IntentScope2,
      version: IntentVersion2,
      appId: AppId2
    });
    function IntentMessage2(T2) {
      return import_bcs34.bcs.struct(`IntentMessage<${T2.name}>`, {
        intent: Intent2,
        value: T2
      });
    }
    var CompressedSignature2 = import_bcs34.bcs.enum("CompressedSignature", {
      ED25519: import_bcs34.bcs.fixedArray(64, import_bcs34.bcs.u8()),
      Secp256k1: import_bcs34.bcs.fixedArray(64, import_bcs34.bcs.u8()),
      Secp256r1: import_bcs34.bcs.fixedArray(64, import_bcs34.bcs.u8()),
      ZkLogin: import_bcs34.bcs.vector(import_bcs34.bcs.u8())
    });
    var PublicKey2 = import_bcs34.bcs.enum("PublicKey", {
      ED25519: import_bcs34.bcs.fixedArray(32, import_bcs34.bcs.u8()),
      Secp256k1: import_bcs34.bcs.fixedArray(33, import_bcs34.bcs.u8()),
      Secp256r1: import_bcs34.bcs.fixedArray(33, import_bcs34.bcs.u8()),
      ZkLogin: import_bcs34.bcs.vector(import_bcs34.bcs.u8())
    });
    var MultiSigPkMap2 = import_bcs34.bcs.struct("MultiSigPkMap", {
      pubKey: PublicKey2,
      weight: import_bcs34.bcs.u8()
    });
    var MultiSigPublicKey2 = import_bcs34.bcs.struct("MultiSigPublicKey", {
      pk_map: import_bcs34.bcs.vector(MultiSigPkMap2),
      threshold: import_bcs34.bcs.u16()
    });
    var MultiSig2 = import_bcs34.bcs.struct("MultiSig", {
      sigs: import_bcs34.bcs.vector(CompressedSignature2),
      bitmap: import_bcs34.bcs.u16(),
      multisig_pk: MultiSigPublicKey2
    });
    var base64String2 = import_bcs34.bcs.vector(import_bcs34.bcs.u8()).transform({
      input: (val) => typeof val === "string" ? (0, import_bcs34.fromBase64)(val) : val,
      output: (val) => (0, import_bcs34.toBase64)(new Uint8Array(val))
    });
    var SenderSignedTransaction2 = import_bcs34.bcs.struct("SenderSignedTransaction", {
      intentMessage: IntentMessage2(TransactionData3),
      txSignatures: import_bcs34.bcs.vector(base64String2)
    });
    var SenderSignedData2 = import_bcs34.bcs.vector(SenderSignedTransaction2, {
      name: "SenderSignedData"
    });
    var PasskeyAuthenticator2 = import_bcs34.bcs.struct("PasskeyAuthenticator", {
      authenticatorData: import_bcs34.bcs.vector(import_bcs34.bcs.u8()),
      clientDataJson: import_bcs34.bcs.string(),
      userSignature: import_bcs34.bcs.vector(import_bcs34.bcs.u8())
    });
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/bcs/effects.js
var require_effects = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/bcs/effects.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var effects_exports = {};
    __export2(effects_exports, {
      TransactionEffects: () => TransactionEffects2
    });
    module2.exports = __toCommonJS2(effects_exports);
    var import_bcs34 = require_cjs5();
    var import_bcs210 = require_bcs2();
    var PackageUpgradeError2 = import_bcs34.bcs.enum("PackageUpgradeError", {
      UnableToFetchPackage: import_bcs34.bcs.struct("UnableToFetchPackage", { packageId: import_bcs210.Address }),
      NotAPackage: import_bcs34.bcs.struct("NotAPackage", { objectId: import_bcs210.Address }),
      IncompatibleUpgrade: null,
      DigestDoesNotMatch: import_bcs34.bcs.struct("DigestDoesNotMatch", { digest: import_bcs34.bcs.vector(import_bcs34.bcs.u8()) }),
      UnknownUpgradePolicy: import_bcs34.bcs.struct("UnknownUpgradePolicy", { policy: import_bcs34.bcs.u8() }),
      PackageIDDoesNotMatch: import_bcs34.bcs.struct("PackageIDDoesNotMatch", {
        packageId: import_bcs210.Address,
        ticketId: import_bcs210.Address
      })
    });
    var ModuleId2 = import_bcs34.bcs.struct("ModuleId", {
      address: import_bcs210.Address,
      name: import_bcs34.bcs.string()
    });
    var MoveLocation2 = import_bcs34.bcs.struct("MoveLocation", {
      module: ModuleId2,
      function: import_bcs34.bcs.u16(),
      instruction: import_bcs34.bcs.u16(),
      functionName: import_bcs34.bcs.option(import_bcs34.bcs.string())
    });
    var CommandArgumentError2 = import_bcs34.bcs.enum("CommandArgumentError", {
      TypeMismatch: null,
      InvalidBCSBytes: null,
      InvalidUsageOfPureArg: null,
      InvalidArgumentToPrivateEntryFunction: null,
      IndexOutOfBounds: import_bcs34.bcs.struct("IndexOutOfBounds", { idx: import_bcs34.bcs.u16() }),
      SecondaryIndexOutOfBounds: import_bcs34.bcs.struct("SecondaryIndexOutOfBounds", {
        resultIdx: import_bcs34.bcs.u16(),
        secondaryIdx: import_bcs34.bcs.u16()
      }),
      InvalidResultArity: import_bcs34.bcs.struct("InvalidResultArity", { resultIdx: import_bcs34.bcs.u16() }),
      InvalidGasCoinUsage: null,
      InvalidValueUsage: null,
      InvalidObjectByValue: null,
      InvalidObjectByMutRef: null,
      SharedObjectOperationNotAllowed: null
    });
    var TypeArgumentError2 = import_bcs34.bcs.enum("TypeArgumentError", {
      TypeNotFound: null,
      ConstraintNotSatisfied: null
    });
    var ExecutionFailureStatus2 = import_bcs34.bcs.enum("ExecutionFailureStatus", {
      InsufficientGas: null,
      InvalidGasObject: null,
      InvariantViolation: null,
      FeatureNotYetSupported: null,
      MoveObjectTooBig: import_bcs34.bcs.struct("MoveObjectTooBig", {
        objectSize: import_bcs34.bcs.u64(),
        maxObjectSize: import_bcs34.bcs.u64()
      }),
      MovePackageTooBig: import_bcs34.bcs.struct("MovePackageTooBig", {
        objectSize: import_bcs34.bcs.u64(),
        maxObjectSize: import_bcs34.bcs.u64()
      }),
      CircularObjectOwnership: import_bcs34.bcs.struct("CircularObjectOwnership", { object: import_bcs210.Address }),
      InsufficientCoinBalance: null,
      CoinBalanceOverflow: null,
      PublishErrorNonZeroAddress: null,
      SuiMoveVerificationError: null,
      MovePrimitiveRuntimeError: import_bcs34.bcs.option(MoveLocation2),
      MoveAbort: import_bcs34.bcs.tuple([MoveLocation2, import_bcs34.bcs.u64()]),
      VMVerificationOrDeserializationError: null,
      VMInvariantViolation: null,
      FunctionNotFound: null,
      ArityMismatch: null,
      TypeArityMismatch: null,
      NonEntryFunctionInvoked: null,
      CommandArgumentError: import_bcs34.bcs.struct("CommandArgumentError", {
        argIdx: import_bcs34.bcs.u16(),
        kind: CommandArgumentError2
      }),
      TypeArgumentError: import_bcs34.bcs.struct("TypeArgumentError", {
        argumentIdx: import_bcs34.bcs.u16(),
        kind: TypeArgumentError2
      }),
      UnusedValueWithoutDrop: import_bcs34.bcs.struct("UnusedValueWithoutDrop", {
        resultIdx: import_bcs34.bcs.u16(),
        secondaryIdx: import_bcs34.bcs.u16()
      }),
      InvalidPublicFunctionReturnType: import_bcs34.bcs.struct("InvalidPublicFunctionReturnType", {
        idx: import_bcs34.bcs.u16()
      }),
      InvalidTransferObject: null,
      EffectsTooLarge: import_bcs34.bcs.struct("EffectsTooLarge", { currentSize: import_bcs34.bcs.u64(), maxSize: import_bcs34.bcs.u64() }),
      PublishUpgradeMissingDependency: null,
      PublishUpgradeDependencyDowngrade: null,
      PackageUpgradeError: import_bcs34.bcs.struct("PackageUpgradeError", { upgradeError: PackageUpgradeError2 }),
      WrittenObjectsTooLarge: import_bcs34.bcs.struct("WrittenObjectsTooLarge", {
        currentSize: import_bcs34.bcs.u64(),
        maxSize: import_bcs34.bcs.u64()
      }),
      CertificateDenied: null,
      SuiMoveVerificationTimedout: null,
      SharedObjectOperationNotAllowed: null,
      InputObjectDeleted: null,
      ExecutionCancelledDueToSharedObjectCongestion: import_bcs34.bcs.struct(
        "ExecutionCancelledDueToSharedObjectCongestion",
        {
          congestedObjects: import_bcs34.bcs.vector(import_bcs210.Address)
        }
      ),
      AddressDeniedForCoin: import_bcs34.bcs.struct("AddressDeniedForCoin", {
        address: import_bcs210.Address,
        coinType: import_bcs34.bcs.string()
      }),
      CoinTypeGlobalPause: import_bcs34.bcs.struct("CoinTypeGlobalPause", { coinType: import_bcs34.bcs.string() }),
      ExecutionCancelledDueToRandomnessUnavailable: null
    });
    var ExecutionStatus2 = import_bcs34.bcs.enum("ExecutionStatus", {
      Success: null,
      Failed: import_bcs34.bcs.struct("ExecutionFailed", {
        error: ExecutionFailureStatus2,
        command: import_bcs34.bcs.option(import_bcs34.bcs.u64())
      })
    });
    var GasCostSummary2 = import_bcs34.bcs.struct("GasCostSummary", {
      computationCost: import_bcs34.bcs.u64(),
      storageCost: import_bcs34.bcs.u64(),
      storageRebate: import_bcs34.bcs.u64(),
      nonRefundableStorageFee: import_bcs34.bcs.u64()
    });
    var Owner2 = import_bcs34.bcs.enum("Owner", {
      AddressOwner: import_bcs210.Address,
      ObjectOwner: import_bcs210.Address,
      Shared: import_bcs34.bcs.struct("Shared", {
        initialSharedVersion: import_bcs34.bcs.u64()
      }),
      Immutable: null
    });
    var TransactionEffectsV12 = import_bcs34.bcs.struct("TransactionEffectsV1", {
      status: ExecutionStatus2,
      executedEpoch: import_bcs34.bcs.u64(),
      gasUsed: GasCostSummary2,
      modifiedAtVersions: import_bcs34.bcs.vector(import_bcs34.bcs.tuple([import_bcs210.Address, import_bcs34.bcs.u64()])),
      sharedObjects: import_bcs34.bcs.vector(import_bcs210.SuiObjectRef),
      transactionDigest: import_bcs210.ObjectDigest,
      created: import_bcs34.bcs.vector(import_bcs34.bcs.tuple([import_bcs210.SuiObjectRef, Owner2])),
      mutated: import_bcs34.bcs.vector(import_bcs34.bcs.tuple([import_bcs210.SuiObjectRef, Owner2])),
      unwrapped: import_bcs34.bcs.vector(import_bcs34.bcs.tuple([import_bcs210.SuiObjectRef, Owner2])),
      deleted: import_bcs34.bcs.vector(import_bcs210.SuiObjectRef),
      unwrappedThenDeleted: import_bcs34.bcs.vector(import_bcs210.SuiObjectRef),
      wrapped: import_bcs34.bcs.vector(import_bcs210.SuiObjectRef),
      gasObject: import_bcs34.bcs.tuple([import_bcs210.SuiObjectRef, Owner2]),
      eventsDigest: import_bcs34.bcs.option(import_bcs210.ObjectDigest),
      dependencies: import_bcs34.bcs.vector(import_bcs210.ObjectDigest)
    });
    var VersionDigest2 = import_bcs34.bcs.tuple([import_bcs34.bcs.u64(), import_bcs210.ObjectDigest]);
    var ObjectIn2 = import_bcs34.bcs.enum("ObjectIn", {
      NotExist: null,
      Exist: import_bcs34.bcs.tuple([VersionDigest2, Owner2])
    });
    var ObjectOut2 = import_bcs34.bcs.enum("ObjectOut", {
      NotExist: null,
      ObjectWrite: import_bcs34.bcs.tuple([import_bcs210.ObjectDigest, Owner2]),
      PackageWrite: VersionDigest2
    });
    var IDOperation2 = import_bcs34.bcs.enum("IDOperation", {
      None: null,
      Created: null,
      Deleted: null
    });
    var EffectsObjectChange2 = import_bcs34.bcs.struct("EffectsObjectChange", {
      inputState: ObjectIn2,
      outputState: ObjectOut2,
      idOperation: IDOperation2
    });
    var UnchangedSharedKind2 = import_bcs34.bcs.enum("UnchangedSharedKind", {
      ReadOnlyRoot: VersionDigest2,
      MutateDeleted: import_bcs34.bcs.u64(),
      ReadDeleted: import_bcs34.bcs.u64(),
      Cancelled: import_bcs34.bcs.u64(),
      PerEpochConfig: null
    });
    var TransactionEffectsV22 = import_bcs34.bcs.struct("TransactionEffectsV2", {
      status: ExecutionStatus2,
      executedEpoch: import_bcs34.bcs.u64(),
      gasUsed: GasCostSummary2,
      transactionDigest: import_bcs210.ObjectDigest,
      gasObjectIndex: import_bcs34.bcs.option(import_bcs34.bcs.u32()),
      eventsDigest: import_bcs34.bcs.option(import_bcs210.ObjectDigest),
      dependencies: import_bcs34.bcs.vector(import_bcs210.ObjectDigest),
      lamportVersion: import_bcs34.bcs.u64(),
      changedObjects: import_bcs34.bcs.vector(import_bcs34.bcs.tuple([import_bcs210.Address, EffectsObjectChange2])),
      unchangedSharedObjects: import_bcs34.bcs.vector(import_bcs34.bcs.tuple([import_bcs210.Address, UnchangedSharedKind2])),
      auxDataDigest: import_bcs34.bcs.option(import_bcs210.ObjectDigest)
    });
    var TransactionEffects2 = import_bcs34.bcs.enum("TransactionEffects", {
      V1: TransactionEffectsV12,
      V2: TransactionEffectsV22
    });
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/bcs/index.js
var require_bcs3 = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/bcs/index.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var bcs_exports = {};
    __export2(bcs_exports, {
      BcsType: () => import_bcs35.BcsType,
      TypeTagSerializer: () => import_type_tag_serializer3.TypeTagSerializer,
      bcs: () => suiBcs2
    });
    module2.exports = __toCommonJS2(bcs_exports);
    var import_bcs34 = require_cjs5();
    var import_bcs210 = require_bcs2();
    var import_effects2 = require_effects();
    var import_type_tag_serializer3 = require_type_tag_serializer();
    var import_bcs35 = require_cjs5();
    var suiBcs2 = __spreadProps(__spreadValues({}, import_bcs34.bcs), {
      U8: import_bcs34.bcs.u8(),
      U16: import_bcs34.bcs.u16(),
      U32: import_bcs34.bcs.u32(),
      U64: import_bcs34.bcs.u64(),
      U128: import_bcs34.bcs.u128(),
      U256: import_bcs34.bcs.u256(),
      ULEB128: import_bcs34.bcs.uleb128(),
      Bool: import_bcs34.bcs.bool(),
      String: import_bcs34.bcs.string(),
      Address: import_bcs210.Address,
      AppId: import_bcs210.AppId,
      Argument: import_bcs210.Argument,
      CallArg: import_bcs210.CallArg,
      CompressedSignature: import_bcs210.CompressedSignature,
      GasData: import_bcs210.GasData,
      Intent: import_bcs210.Intent,
      IntentMessage: import_bcs210.IntentMessage,
      IntentScope: import_bcs210.IntentScope,
      IntentVersion: import_bcs210.IntentVersion,
      MultiSig: import_bcs210.MultiSig,
      MultiSigPkMap: import_bcs210.MultiSigPkMap,
      MultiSigPublicKey: import_bcs210.MultiSigPublicKey,
      ObjectArg: import_bcs210.ObjectArg,
      ObjectDigest: import_bcs210.ObjectDigest,
      ProgrammableMoveCall: import_bcs210.ProgrammableMoveCall,
      ProgrammableTransaction: import_bcs210.ProgrammableTransaction,
      PublicKey: import_bcs210.PublicKey,
      SenderSignedData: import_bcs210.SenderSignedData,
      SenderSignedTransaction: import_bcs210.SenderSignedTransaction,
      SharedObjectRef: import_bcs210.SharedObjectRef,
      StructTag: import_bcs210.StructTag,
      SuiObjectRef: import_bcs210.SuiObjectRef,
      Command: import_bcs210.Command,
      TransactionData: import_bcs210.TransactionData,
      TransactionDataV1: import_bcs210.TransactionDataV1,
      TransactionExpiration: import_bcs210.TransactionExpiration,
      TransactionKind: import_bcs210.TransactionKind,
      TypeTag: import_bcs210.TypeTag,
      TransactionEffects: import_effects2.TransactionEffects,
      PasskeyAuthenticator: import_bcs210.PasskeyAuthenticator
    });
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/dynamic-fields.js
var require_dynamic_fields = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/dynamic-fields.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var dynamic_fields_exports = {};
    __export2(dynamic_fields_exports, {
      deriveDynamicFieldID: () => deriveDynamicFieldID
    });
    module2.exports = __toCommonJS2(dynamic_fields_exports);
    var import_bcs34 = require_cjs5();
    var import_blake2b2 = require_blake2b();
    var import_bcs210 = require_bcs3();
    function deriveDynamicFieldID(parentId, typeTag, key) {
      const address = import_bcs210.bcs.Address.serialize(parentId).toBytes();
      const tag3 = import_bcs210.bcs.TypeTag.serialize(typeTag).toBytes();
      const keyLength = import_bcs210.bcs.u64().serialize(key.length).toBytes();
      const hash = import_blake2b2.blake2b.create({
        dkLen: 32
      });
      hash.update(new Uint8Array([240]));
      hash.update(address);
      hash.update(keyLength);
      hash.update(key);
      hash.update(tag3);
      return `0x${(0, import_bcs34.toHex)(hash.digest().slice(0, 32))}`;
    }
  }
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/index.js
var require_utils4 = __commonJS({
  "../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/cjs/utils/index.js"(exports2, module2) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp4(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod3) => __copyProps4(__defProp4({}, "__esModule", { value: true }), mod3);
    var utils_exports = {};
    __export2(utils_exports, {
      MIST_PER_SUI: () => import_constants11.MIST_PER_SUI,
      MOVE_STDLIB_ADDRESS: () => import_constants11.MOVE_STDLIB_ADDRESS,
      SUI_ADDRESS_LENGTH: () => import_sui_types14.SUI_ADDRESS_LENGTH,
      SUI_CLOCK_OBJECT_ID: () => import_constants11.SUI_CLOCK_OBJECT_ID,
      SUI_DECIMALS: () => import_constants11.SUI_DECIMALS,
      SUI_FRAMEWORK_ADDRESS: () => import_constants11.SUI_FRAMEWORK_ADDRESS,
      SUI_SYSTEM_ADDRESS: () => import_constants11.SUI_SYSTEM_ADDRESS,
      SUI_SYSTEM_MODULE_NAME: () => import_constants11.SUI_SYSTEM_MODULE_NAME,
      SUI_SYSTEM_STATE_OBJECT_ID: () => import_constants11.SUI_SYSTEM_STATE_OBJECT_ID,
      SUI_TYPE_ARG: () => import_constants11.SUI_TYPE_ARG,
      deriveDynamicFieldID: () => import_dynamic_fields.deriveDynamicFieldID,
      formatAddress: () => import_format.formatAddress,
      formatDigest: () => import_format.formatDigest,
      fromB64: () => import_bcs34.fromB64,
      fromBase58: () => import_bcs34.fromBase58,
      fromBase64: () => import_bcs34.fromBase64,
      fromHEX: () => import_bcs34.fromHEX,
      fromHex: () => import_bcs34.fromHex,
      isValidNamedPackage: () => import_move_registry.isValidNamedPackage,
      isValidNamedType: () => import_move_registry.isValidNamedType,
      isValidSuiAddress: () => import_sui_types14.isValidSuiAddress,
      isValidSuiNSName: () => import_suins2.isValidSuiNSName,
      isValidSuiObjectId: () => import_sui_types14.isValidSuiObjectId,
      isValidTransactionDigest: () => import_sui_types14.isValidTransactionDigest,
      normalizeStructTag: () => import_sui_types14.normalizeStructTag,
      normalizeSuiAddress: () => import_sui_types14.normalizeSuiAddress,
      normalizeSuiNSName: () => import_suins2.normalizeSuiNSName,
      normalizeSuiObjectId: () => import_sui_types14.normalizeSuiObjectId,
      parseStructTag: () => import_sui_types14.parseStructTag,
      toB64: () => import_bcs34.toB64,
      toBase58: () => import_bcs34.toBase58,
      toBase64: () => import_bcs34.toBase64,
      toHEX: () => import_bcs34.toHEX,
      toHex: () => import_bcs34.toHex
    });
    module2.exports = __toCommonJS2(utils_exports);
    var import_format = require_format();
    var import_sui_types14 = require_sui_types();
    var import_bcs34 = require_cjs5();
    var import_suins2 = require_suins();
    var import_constants11 = require_constants2();
    var import_move_registry = require_move_registry();
    var import_dynamic_fields = require_dynamic_fields();
  }
});

// ../../node_modules/.pnpm/@pythnetwork+pyth-sui-js@2.1.0_typescript@5.8.3/node_modules/@pythnetwork/pyth-sui-js/lib/client.js
var require_client = __commonJS({
  "../../node_modules/.pnpm/@pythnetwork+pyth-sui-js@2.1.0_typescript@5.8.3/node_modules/@pythnetwork/pyth-sui-js/lib/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SuiPythClient = void 0;
    var utils_1 = require_utils4();
    var bcs_1 = require_bcs3();
    var buffer_1 = require("buffer");
    var MAX_ARGUMENT_SIZE = 16 * 1024;
    var SuiPythClient2 = class {
      constructor(provider, pythStateId, wormholeStateId) {
        __publicField(this, "provider");
        __publicField(this, "pythStateId");
        __publicField(this, "wormholeStateId");
        __publicField(this, "pythPackageId");
        __publicField(this, "wormholePackageId");
        __publicField(this, "priceTableInfo");
        __publicField(this, "priceFeedObjectIdCache", /* @__PURE__ */ new Map());
        __publicField(this, "baseUpdateFee");
        this.provider = provider;
        this.pythStateId = pythStateId;
        this.wormholeStateId = wormholeStateId;
        this.pythPackageId = void 0;
        this.wormholePackageId = void 0;
      }
      async getBaseUpdateFee() {
        if (this.baseUpdateFee === void 0) {
          const result = await this.provider.getObject({
            id: this.pythStateId,
            options: { showContent: true }
          });
          if (!result.data || !result.data.content || result.data.content.dataType !== "moveObject")
            throw new Error("Unable to fetch pyth state object");
          this.baseUpdateFee = result.data.content.fields.base_update_fee;
        }
        return this.baseUpdateFee;
      }
      /**
       * getPackageId returns the latest package id that the object belongs to. Use this to
       * fetch the latest package id for a given object id and handle package upgrades automatically.
       * @param objectId
       * @returns package id
       */
      async getPackageId(objectId) {
        const state = await this.provider.getObject({
          id: objectId,
          options: {
            showContent: true
          }
        }).then((result) => {
          var _a7, _b3, _c;
          if (((_b3 = (_a7 = result.data) == null ? void 0 : _a7.content) == null ? void 0 : _b3.dataType) == "moveObject") {
            return result.data.content.fields;
          }
          console.log((_c = result.data) == null ? void 0 : _c.content);
          throw new Error(`Cannot fetch package id for object ${objectId}`);
        });
        if ("upgrade_cap" in state) {
          return state.upgrade_cap.fields.package;
        }
        throw new Error("upgrade_cap not found");
      }
      /**
       * Adds the commands for calling wormhole and verifying the vaas and returns the verified vaas.
       * @param vaas array of vaas to verify
       * @param tx transaction block to add commands to
       */
      async verifyVaas(vaas, tx) {
        const wormholePackageId = await this.getWormholePackageId();
        const verifiedVaas = [];
        for (const vaa of vaas) {
          const [verifiedVaa] = tx.moveCall({
            target: `${wormholePackageId}::vaa::parse_and_verify`,
            arguments: [
              tx.object(this.wormholeStateId),
              tx.pure(bcs_1.bcs.vector(bcs_1.bcs.U8).serialize(Array.from(vaa), {
                maxSize: MAX_ARGUMENT_SIZE
              }).toBytes()),
              tx.object(utils_1.SUI_CLOCK_OBJECT_ID)
            ]
          });
          verifiedVaas.push(verifiedVaa);
        }
        return verifiedVaas;
      }
      /**
       * Adds the necessary commands for updating the pyth price feeds to the transaction block.
       * @param tx transaction block to add commands to
       * @param updates array of price feed updates received from the price service
       * @param feedIds array of feed ids to update (in hex format)
       */
      async updatePriceFeeds(tx, updates, feedIds) {
        const packageId = await this.getPythPackageId();
        let priceUpdatesHotPotato;
        if (updates.length > 1) {
          throw new Error("SDK does not support sending multiple accumulator messages in a single transaction");
        }
        const vaa = this.extractVaaBytesFromAccumulatorMessage(updates[0]);
        const verifiedVaas = await this.verifyVaas([vaa], tx);
        [priceUpdatesHotPotato] = tx.moveCall({
          target: `${packageId}::pyth::create_authenticated_price_infos_using_accumulator`,
          arguments: [
            tx.object(this.pythStateId),
            tx.pure(bcs_1.bcs.vector(bcs_1.bcs.U8).serialize(Array.from(updates[0]), {
              maxSize: MAX_ARGUMENT_SIZE
            }).toBytes()),
            verifiedVaas[0],
            tx.object(utils_1.SUI_CLOCK_OBJECT_ID)
          ]
        });
        const priceInfoObjects = [];
        const baseUpdateFee = await this.getBaseUpdateFee();
        const coins = tx.splitCoins(tx.gas, feedIds.map(() => tx.pure.u64(baseUpdateFee)));
        let coinId = 0;
        for (const feedId of feedIds) {
          const priceInfoObjectId = await this.getPriceFeedObjectId(feedId);
          if (!priceInfoObjectId) {
            throw new Error(`Price feed ${feedId} not found, please create it first`);
          }
          priceInfoObjects.push(priceInfoObjectId);
          [priceUpdatesHotPotato] = tx.moveCall({
            target: `${packageId}::pyth::update_single_price_feed`,
            arguments: [
              tx.object(this.pythStateId),
              priceUpdatesHotPotato,
              tx.object(priceInfoObjectId),
              coins[coinId],
              tx.object(utils_1.SUI_CLOCK_OBJECT_ID)
            ]
          });
          coinId++;
        }
        tx.moveCall({
          target: `${packageId}::hot_potato_vector::destroy`,
          arguments: [priceUpdatesHotPotato],
          typeArguments: [`${packageId}::price_info::PriceInfo`]
        });
        return priceInfoObjects;
      }
      async createPriceFeed(tx, updates) {
        const packageId = await this.getPythPackageId();
        if (updates.length > 1) {
          throw new Error("SDK does not support sending multiple accumulator messages in a single transaction");
        }
        const vaa = this.extractVaaBytesFromAccumulatorMessage(updates[0]);
        const verifiedVaas = await this.verifyVaas([vaa], tx);
        tx.moveCall({
          target: `${packageId}::pyth::create_price_feeds_using_accumulator`,
          arguments: [
            tx.object(this.pythStateId),
            tx.pure(bcs_1.bcs.vector(bcs_1.bcs.U8).serialize(Array.from(updates[0]), {
              maxSize: MAX_ARGUMENT_SIZE
            }).toBytes()),
            verifiedVaas[0],
            tx.object(utils_1.SUI_CLOCK_OBJECT_ID)
          ]
        });
      }
      /**
       * Get the packageId for the wormhole package if not already cached
       */
      async getWormholePackageId() {
        if (!this.wormholePackageId) {
          this.wormholePackageId = await this.getPackageId(this.wormholeStateId);
        }
        return this.wormholePackageId;
      }
      /**
       * Get the packageId for the pyth package if not already cached
       */
      async getPythPackageId() {
        if (!this.pythPackageId) {
          this.pythPackageId = await this.getPackageId(this.pythStateId);
        }
        return this.pythPackageId;
      }
      /**
       * Get the priceFeedObjectId for a given feedId if not already cached
       * @param feedId
       */
      async getPriceFeedObjectId(feedId) {
        const normalizedFeedId = feedId.replace("0x", "");
        if (!this.priceFeedObjectIdCache.has(normalizedFeedId)) {
          const { id: tableId, fieldType } = await this.getPriceTableInfo();
          const result = await this.provider.getDynamicFieldObject({
            parentId: tableId,
            name: {
              type: `${fieldType}::price_identifier::PriceIdentifier`,
              value: {
                bytes: Array.from(buffer_1.Buffer.from(normalizedFeedId, "hex"))
              }
            }
          });
          if (!result.data || !result.data.content) {
            return void 0;
          }
          if (result.data.content.dataType !== "moveObject") {
            throw new Error("Price feed type mismatch");
          }
          this.priceFeedObjectIdCache.set(
            normalizedFeedId,
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            result.data.content.fields.value
          );
        }
        return this.priceFeedObjectIdCache.get(normalizedFeedId);
      }
      /**
       * Fetches the price table object id for the current state id if not cached
       * @returns price table object id
       */
      async getPriceTableInfo() {
        if (this.priceTableInfo === void 0) {
          const result = await this.provider.getDynamicFieldObject({
            parentId: this.pythStateId,
            name: {
              type: "vector<u8>",
              value: "price_info"
            }
          });
          if (!result.data || !result.data.type) {
            throw new Error("Price Table not found, contract may not be initialized");
          }
          let type = result.data.type.replace("0x2::table::Table<", "");
          type = type.replace("::price_identifier::PriceIdentifier, 0x2::object::ID>", "");
          this.priceTableInfo = { id: result.data.objectId, fieldType: type };
        }
        return this.priceTableInfo;
      }
      /**
       * Obtains the vaa bytes embedded in an accumulator message.
       * @param accumulatorMessage - the accumulator price update message
       * @returns vaa bytes as a uint8 array
       */
      extractVaaBytesFromAccumulatorMessage(accumulatorMessage) {
        const trailingPayloadSize = accumulatorMessage.readUint8(6);
        const vaaSizeOffset = 7 + // header bytes (header(4) + major(1) + minor(1) + trailing payload size(1))
        trailingPayloadSize + // trailing payload (variable number of bytes)
        1;
        const vaaSize = accumulatorMessage.readUint16BE(vaaSizeOffset);
        const vaaOffset = vaaSizeOffset + 2;
        return accumulatorMessage.subarray(vaaOffset, vaaOffset + vaaSize);
      }
    };
    exports2.SuiPythClient = SuiPythClient2;
  }
});

// ../../node_modules/.pnpm/@pythnetwork+pyth-sui-js@2.1.0_typescript@5.8.3/node_modules/@pythnetwork/pyth-sui-js/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/.pnpm/@pythnetwork+pyth-sui-js@2.1.0_typescript@5.8.3/node_modules/@pythnetwork/pyth-sui-js/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PriceFeed = exports2.Price = exports2.SuiPythClient = exports2.SuiPriceServiceConnection = void 0;
    var SuiPriceServiceConnection_1 = require_SuiPriceServiceConnection();
    Object.defineProperty(exports2, "SuiPriceServiceConnection", { enumerable: true, get: function() {
      return SuiPriceServiceConnection_1.SuiPriceServiceConnection;
    } });
    var client_1 = require_client();
    Object.defineProperty(exports2, "SuiPythClient", { enumerable: true, get: function() {
      return client_1.SuiPythClient;
    } });
    var price_service_client_1 = require_lib2();
    Object.defineProperty(exports2, "Price", { enumerable: true, get: function() {
      return price_service_client_1.Price;
    } });
    Object.defineProperty(exports2, "PriceFeed", { enumerable: true, get: function() {
      return price_service_client_1.PriceFeed;
    } });
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AFTERMATH: () => AFTERMATH,
  ALPAHFI: () => ALPAHFI,
  CETUS_VAULT_ID_LIST: () => CETUS_VAULT_ID_LIST,
  ContractError: () => ContractError,
  DEFAULT_Address: () => DEFAULT_Address,
  HAEDAL: () => HAEDAL,
  NEED_MIN_VALUE_LIST: () => NEED_MIN_VALUE_LIST,
  QUERY_CONFIGS: () => QUERY_CONFIGS,
  SCALLOP: () => SCALLOP,
  SPRING_SUI_STAKING_INFO_LIST: () => SPRING_SUI_STAKING_INFO_LIST,
  SSBUCK: () => SSBUCK,
  SUPER_SUI: () => SUPER_SUI,
  Time: () => Time,
  UNSUPPORTED_UNDERLYING_COINS: () => UNSUPPORTED_UNDERLYING_COINS,
  VALIDATORS: () => VALIDATORS,
  VOLO: () => VOLO,
  WINTER: () => WINTER,
  WWAL: () => WWAL,
  Winter_Blizzard_Staking_List: () => Winter_Blizzard_Staking_List,
  burnLp: () => burnLp,
  cn: () => cn2,
  debounce: () => debounce,
  depositSyCoin: () => depositSyCoin,
  fetchCoins: () => fetchCoins,
  formatDecimalValue: () => formatDecimalValue,
  formatLargeNumber: () => formatLargeNumber,
  formatPortfolioNumber: () => formatPortfolioNumber,
  formatTVL: () => formatTVL,
  formatTimeDiff: () => formatTimeDiff,
  getPrice: () => getPrice,
  getTreasury: () => getTreasury,
  get_pt_out: () => get_pt_out,
  handleInfinityValues: () => handleInfinityValues,
  isValidAmount: () => isValidAmount,
  mergeAllCoins: () => mergeAllCoins,
  mergeAllLpPositions: () => mergeAllLpPositions,
  mergeLpPositions: () => mergeLpPositions,
  mintPY: () => mintPY,
  parseErrorMessage: () => parseErrorMessage,
  parseGasErrorMessage: () => parseGasErrorMessage,
  redeemPy: () => redeemPy,
  redeemSyCoin: () => redeemSyCoin,
  safeDivide: () => safeDivide,
  splitCoinHelper: () => splitCoinHelper,
  splitSyAmount: () => splitSyAmount,
  swapExactPtForSy: () => swapExactPtForSy,
  swapExactSyForPt: () => swapExactSyForPt,
  swapExactYtForSy: () => swapExactYtForSy,
  truncateStr: () => truncateStr,
  useCalculatePtYt: () => useCalculatePtYt,
  useRatioLoadingState: () => useRatioLoadingState
});
module.exports = __toCommonJS(index_exports);

// src/hooks/useRatioLoadingState.ts
var import_react = __toESM(require_react());
function useRatioLoadingState(isFetching) {
  const timerRef = (0, import_react.useRef)();
  const [isLoading, setIsLoading] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    if (isFetching) {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
      setIsLoading(true);
    } else {
      timerRef.current = setTimeout(() => {
        setIsLoading(false);
      }, 500);
    }
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, [isFetching]);
  return { isLoading, setIsLoading };
}

// ../../node_modules/.pnpm/decimal.js@10.5.0/node_modules/decimal.js/decimal.mjs
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x2 = new this.constructor(this);
  if (x2.s < 0) x2.s = 1;
  return finalise(x2);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min3, max3) {
  var k2, x2 = this, Ctor = x2.constructor;
  min3 = new Ctor(min3);
  max3 = new Ctor(max3);
  if (!min3.s || !max3.s) return new Ctor(NaN);
  if (min3.gt(max3)) throw Error(invalidArgument + max3);
  k2 = x2.cmp(min3);
  return k2 < 0 ? min3 : x2.cmp(max3) > 0 ? max3 : new Ctor(x2);
};
P.comparedTo = P.cmp = function(y) {
  var i, j2, xdL, ydL, x2 = this, xd = x2.d, yd = (y = new x2.constructor(y)).d, xs = x2.s, ys2 = y.s;
  if (!xd || !yd) {
    return !xs || !ys2 ? NaN : xs !== ys2 ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys2 : 0;
  if (xs !== ys2) return xs;
  if (x2.e !== y.e) return x2.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j2 = xdL < ydL ? xdL : ydL; i < j2; ++i) {
    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.d) return new Ctor(NaN);
  if (!x2.d[0]) return new Ctor(1);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + Math.max(x2.e, x2.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x2 = cosine(Ctor, toLessThanHalfPi(Ctor, x2));
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x2.neg() : x2, pr2, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n, r2, rep, s, sd, t, t3, t3plusx, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero()) return new Ctor(x2);
  external = false;
  s = x2.s * mathpow(x2.s * x2, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x2.d);
    e = x2.e;
    if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r2 = new Ctor(n);
    r2.s = x2.s;
  } else {
    r2 = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r2;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x2);
    r2 = divide(t3plusx.plus(x2).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r2.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x2)) {
            r2 = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r2, e + 1, 1);
          m = !r2.times(r2).times(r2).eq(x2);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r2, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w2, d = this.d, n = NaN;
  if (d) {
    w2 = d.length - 1;
    n = (w2 - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w2 = d[w2];
    if (w2) for (; w2 % 10 == 0; w2 /= 10) n--;
    if (n < 0) n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x2 = this, Ctor = x2.constructor;
  return finalise(divide(x2, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k2 = this.cmp(y);
  return k2 == 1 || k2 === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k2, n, pr2, rm, len, x2 = this, Ctor = x2.constructor, one = new Ctor(1);
  if (!x2.isFinite()) return new Ctor(x2.s ? 1 / 0 : NaN);
  if (x2.isZero()) return one;
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + Math.max(x2.e, x2.sd()) + 4;
  Ctor.rounding = 1;
  len = x2.d.length;
  if (len < 32) {
    k2 = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k2)).toString();
  } else {
    k2 = 16;
    n = "2.3283064365386962890625e-10";
  }
  x2 = taylorSeries(Ctor, 1, x2.times(n), new Ctor(1), true);
  var cosh2_x, i = k2, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x2.times(x2);
    x2 = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x2, Ctor.precision = pr2, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k2, pr2, rm, len, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + Math.max(x2.e, x2.sd()) + 4;
  Ctor.rounding = 1;
  len = x2.d.length;
  if (len < 3) {
    x2 = taylorSeries(Ctor, 2, x2, x2, true);
  } else {
    k2 = 1.4 * Math.sqrt(len);
    k2 = k2 > 16 ? 16 : k2 | 0;
    x2 = x2.times(1 / tinyPow(5, k2));
    x2 = taylorSeries(Ctor, 2, x2, x2, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k2--; ) {
      sinh2_x = x2.times(x2);
      x2 = x2.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return finalise(x2, pr2, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite()) return new Ctor(x2.s);
  if (x2.isZero()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + 7;
  Ctor.rounding = 1;
  return divide(x2.sinh(), x2.cosh(), Ctor.precision = pr2, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var x2 = this, Ctor = x2.constructor, k2 = x2.abs().cmp(1), pr2 = Ctor.precision, rm = Ctor.rounding;
  if (k2 !== -1) {
    return k2 === 0 ? x2.isNeg() ? getPi(Ctor, pr2, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x2.isZero()) return getPi(Ctor, pr2 + 4, rm).times(0.5);
  Ctor.precision = pr2 + 6;
  Ctor.rounding = 1;
  x2 = new Ctor(1).minus(x2).div(x2.plus(1)).sqrt().atan();
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return x2.times(2);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (x2.lte(1)) return new Ctor(x2.eq(1) ? 0 : NaN);
  if (!x2.isFinite()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + Math.max(Math.abs(x2.e), x2.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x2 = x2.times(x2).minus(1).sqrt().plus(x2);
  external = true;
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return x2.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + 2 * Math.max(Math.abs(x2.e), x2.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x2 = x2.times(x2).plus(1).sqrt().plus(x2);
  external = true;
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return x2.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr2, rm, wpr, xsd, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite()) return new Ctor(NaN);
  if (x2.e >= 0) return new Ctor(x2.abs().eq(1) ? x2.s / 0 : x2.isZero() ? x2 : NaN);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x2.sd();
  if (Math.max(xsd, pr2) < 2 * -x2.e - 1) return finalise(new Ctor(x2), pr2, rm, true);
  Ctor.precision = wpr = xsd - x2.e;
  x2 = divide(x2.plus(1), new Ctor(1).minus(x2), wpr + pr2, 1);
  Ctor.precision = pr2 + 4;
  Ctor.rounding = 1;
  x2 = x2.ln();
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return x2.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k2, pr2, rm, x2 = this, Ctor = x2.constructor;
  if (x2.isZero()) return new Ctor(x2);
  k2 = x2.abs().cmp(1);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  if (k2 !== -1) {
    if (k2 === 0) {
      halfPi = getPi(Ctor, pr2 + 4, rm).times(0.5);
      halfPi.s = x2.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr2 + 6;
  Ctor.rounding = 1;
  x2 = x2.div(new Ctor(1).minus(x2.times(x2)).sqrt().plus(1)).atan();
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return x2.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j2, k2, n, px, t, r2, wpr, x2, x3 = this, Ctor = x3.constructor, pr2 = Ctor.precision, rm = Ctor.rounding;
  if (!x3.isFinite()) {
    if (!x3.s) return new Ctor(NaN);
    if (pr2 + 4 <= PI_PRECISION) {
      r2 = getPi(Ctor, pr2 + 4, rm).times(0.5);
      r2.s = x3.s;
      return r2;
    }
  } else if (x3.isZero()) {
    return new Ctor(x3);
  } else if (x3.abs().eq(1) && pr2 + 4 <= PI_PRECISION) {
    r2 = getPi(Ctor, pr2 + 4, rm).times(0.25);
    r2.s = x3.s;
    return r2;
  }
  Ctor.precision = wpr = pr2 + 10;
  Ctor.rounding = 1;
  k2 = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k2; i; --i) x3 = x3.div(x3.times(x3).plus(1).sqrt().plus(1));
  external = false;
  j2 = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x3.times(x3);
  r2 = new Ctor(x3);
  px = x3;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r2.minus(px.div(n += 2));
    px = px.times(x2);
    r2 = t.plus(px.div(n += 2));
    if (r2.d[j2] !== void 0) for (i = j2; r2.d[i] === t.d[i] && i--; ) ;
  }
  if (k2) r2 = r2.times(2 << k2 - 1);
  external = true;
  return finalise(r2, Ctor.precision = pr2, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base2) {
  var isBase10, d, denominator, k2, inf, num, sd, r2, arg = this, Ctor = arg.constructor, pr2 = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base2 == null) {
    base2 = new Ctor(10);
    isBase10 = true;
  } else {
    base2 = new Ctor(base2);
    d = base2.d;
    if (base2.s < 0 || !d || !d[0] || base2.eq(1)) return new Ctor(NaN);
    isBase10 = base2.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k2 = d[0]; k2 % 10 === 0; ) k2 /= 10;
      inf = k2 !== 1;
    }
  }
  external = false;
  sd = pr2 + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd);
  r2 = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r2.d, k2 = pr2, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd);
      r2 = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r2.d).slice(k2 + 1, k2 + 15) + 1 == 1e14) {
          r2 = finalise(r2, pr2 + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r2.d, k2 += 10, rm));
  }
  external = true;
  return finalise(r2, pr2, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j2, k2, len, pr2, rm, xd, xe3, xLTy, yd, x2 = this, Ctor = x2.constructor;
  y = new Ctor(y);
  if (!x2.d || !y.d) {
    if (!x2.s || !y.s) y = new Ctor(NaN);
    else if (x2.d) y.s = -y.s;
    else y = new Ctor(y.d || x2.s !== y.s ? x2 : NaN);
    return y;
  }
  if (x2.s != y.s) {
    y.s = -y.s;
    return x2.plus(y);
  }
  xd = x2.d;
  yd = y.d;
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0]) y.s = -y.s;
    else if (xd[0]) y = new Ctor(x2);
    else return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr2, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe3 = mathfloor(x2.e / LOG_BASE);
  xd = xd.slice();
  k2 = xe3 - e;
  if (k2) {
    xLTy = k2 < 0;
    if (xLTy) {
      d = xd;
      k2 = -k2;
      len = yd.length;
    } else {
      d = yd;
      e = xe3;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr2 / LOG_BASE), len) + 2;
    if (k2 > i) {
      k2 = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k2; i--; ) d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k2 = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
  for (i = yd.length; i > k2; ) {
    if (xd[--i] < yd[i]) {
      for (j2 = i; j2 && xd[--j2] === 0; ) xd[j2] = BASE - 1;
      --xd[j2];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; ) xd.pop();
  for (; xd[0] === 0; xd.shift()) --e;
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr2, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q3, x2 = this, Ctor = x2.constructor;
  y = new Ctor(y);
  if (!x2.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
  if (!y.d || x2.d && !x2.d[0]) {
    return finalise(new Ctor(x2), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q3 = divide(x2, y.abs(), 0, 3, 1);
    q3.s *= y.s;
  } else {
    q3 = divide(x2, y, 0, Ctor.modulo, 1);
  }
  q3 = q3.times(y);
  external = true;
  return x2.minus(q3);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x2 = new this.constructor(this);
  x2.s = -x2.s;
  return finalise(x2);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k2, len, pr2, rm, xd, yd, x2 = this, Ctor = x2.constructor;
  y = new Ctor(y);
  if (!x2.d || !y.d) {
    if (!x2.s || !y.s) y = new Ctor(NaN);
    else if (!x2.d) y = new Ctor(y.d || x2.s === y.s ? x2 : NaN);
    return y;
  }
  if (x2.s != y.s) {
    y.s = -y.s;
    return x2.minus(y);
  }
  xd = x2.d;
  yd = y.d;
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0]) y = new Ctor(x2);
    return external ? finalise(y, pr2, rm) : y;
  }
  k2 = mathfloor(x2.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k2 - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k2;
      len = xd.length;
    }
    k2 = Math.ceil(pr2 / LOG_BASE);
    len = k2 > len ? k2 + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; ) d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr2, rm) : y;
};
P.precision = P.sd = function(z) {
  var k2, x2 = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
  if (x2.d) {
    k2 = getPrecision(x2.d);
    if (z && x2.e + 1 > k2) k2 = x2.e + 1;
  } else {
    k2 = NaN;
  }
  return k2;
};
P.round = function() {
  var x2 = this, Ctor = x2.constructor;
  return finalise(new Ctor(x2), x2.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite()) return new Ctor(NaN);
  if (x2.isZero()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + Math.max(x2.e, x2.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x2 = sine(Ctor, toLessThanHalfPi(Ctor, x2));
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x2.neg() : x2, pr2, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r2, rep, t, x2 = this, d = x2.d, e = x2.e, s = x2.s, Ctor = x2.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x2 : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x2);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0) n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r2 = new Ctor(n);
  } else {
    r2 = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r2;
    r2 = t.plus(divide(x2, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r2.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x2)) {
            r2 = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r2, e + 1, 1);
          m = !r2.times(r2).eq(x2);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r2, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite()) return new Ctor(NaN);
  if (x2.isZero()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + 10;
  Ctor.rounding = 1;
  x2 = x2.sin();
  x2.s = 1;
  x2 = divide(x2, new Ctor(1).minus(x2.times(x2)).sqrt(), pr2 + 10, 0);
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x2.neg() : x2, pr2, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k2, r2, rL, t, xdL, ydL, x2 = this, Ctor = x2.constructor, xd = x2.d, yd = (y = new Ctor(y)).d;
  y.s *= x2.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x2.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r2 = xd;
    xd = yd;
    yd = r2;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r2 = [];
  rL = xdL + ydL;
  for (i = rL; i--; ) r2.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k2 = xdL + i; k2 > i; ) {
      t = r2[k2] + yd[i] * xd[k2 - i - 1] + carry;
      r2[k2--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r2[k2] = (r2[k2] + carry) % BASE | 0;
  }
  for (; !r2[--rL]; ) r2.pop();
  if (carry) ++e;
  else r2.shift();
  y.d = r2;
  y.e = getBase10Exponent(r2, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (dp === void 0) return x2;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  return finalise(x2, dp + x2.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = finiteToString(x2, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x2 = finalise(new Ctor(x2), dp + 1, rm);
    str = finiteToString(x2, true, dp + 1);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = finiteToString(x2);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x2), dp + x2.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k2, n, n0, n1, pr2, q3, r2, x2 = this, xd = x2.d, Ctor = x2.constructor;
  if (!xd) return new Ctor(x2);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x2.e - 1;
  k2 = e % LOG_BASE;
  d.d[0] = mathpow(10, k2 < 0 ? LOG_BASE + k2 : k2);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr2 = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q3 = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q3.times(d1));
    if (d2.cmp(maxD) == 1) break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q3.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q3.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x2.s;
  r2 = divide(n1, d1, e, 1).minus(x2).abs().cmp(divide(n0, d0, e, 1).minus(x2).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr2;
  external = true;
  return r2;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (y == null) {
    if (!x2.d) return x2;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x2.d) return y.s ? x2 : y;
    if (!y.d) {
      if (y.s) y.s = x2.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x2 = divide(x2, y, 0, rm, 1).times(y);
    external = true;
    finalise(x2);
  } else {
    y.s = x2.s;
    x2 = y;
  }
  return x2;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k2, pr2, r2, rm, s, x2 = this, Ctor = x2.constructor, yn3 = +(y = new Ctor(y));
  if (!x2.d || !y.d || !x2.d[0] || !y.d[0]) return new Ctor(mathpow(+x2, yn3));
  x2 = new Ctor(x2);
  if (x2.eq(1)) return x2;
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1)) return finalise(x2, pr2, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k2 = yn3 < 0 ? -yn3 : yn3) <= MAX_SAFE_INTEGER) {
    r2 = intPow(Ctor, x2, k2, pr2);
    return y.s < 0 ? new Ctor(1).div(r2) : finalise(r2, pr2, rm);
  }
  s = x2.s;
  if (s < 0) {
    if (e < y.d.length - 1) return new Ctor(NaN);
    if ((y.d[e] & 1) == 0) s = 1;
    if (x2.e == 0 && x2.d[0] == 1 && x2.d.length == 1) {
      x2.s = s;
      return x2;
    }
  }
  k2 = mathpow(+x2, yn3);
  e = k2 == 0 || !isFinite(k2) ? mathfloor(yn3 * (Math.log("0." + digitsToString(x2.d)) / Math.LN10 + x2.e + 1)) : new Ctor(k2 + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x2.s = 1;
  k2 = Math.min(12, (e + "").length);
  r2 = naturalExponential(y.times(naturalLogarithm(x2, pr2 + k2)), pr2);
  if (r2.d) {
    r2 = finalise(r2, pr2 + 5, 1);
    if (checkRoundingDigits(r2.d, pr2, rm)) {
      e = pr2 + 10;
      r2 = finalise(naturalExponential(y.times(naturalLogarithm(x2, e + k2)), e), e + 5, 1);
      if (+digitsToString(r2.d).slice(pr2 + 1, pr2 + 15) + 1 == 1e14) {
        r2 = finalise(r2, pr2 + 1, 0);
      }
    }
  }
  r2.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r2, pr2, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    str = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x2 = finalise(new Ctor(x2), sd, rm);
    str = finiteToString(x2, sd <= x2.e || x2.e <= Ctor.toExpNeg, sd);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x2), sd, rm);
};
P.toString = function() {
  var x2 = this, Ctor = x2.constructor, str = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x2 = this, Ctor = x2.constructor, str = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  return x2.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i, k2, ws, indexOfLastWord = d.length - 1, str = "", w2 = d[0];
  if (indexOfLastWord > 0) {
    str += w2;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k2 = LOG_BASE - ws.length;
      if (k2) str += getZeroString(k2);
      str += ws;
    }
    w2 = d[i];
    ws = w2 + "";
    k2 = LOG_BASE - ws.length;
    if (k2) str += getZeroString(k2);
  } else if (w2 === 0) {
    return "0";
  }
  for (; w2 % 10 === 0; ) w2 /= 10;
  return str + w2;
}
function checkInt32(i, min3, max3) {
  if (i !== ~~i || i < min3 || i > max3) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k2, r2, rd;
  for (k2 = d[0]; k2 >= 10; k2 /= 10) --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k2 = mathpow(10, LOG_BASE - i);
  rd = d[di] % k2 | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0) rd = rd / 100 | 0;
      else if (i == 1) rd = rd / 10 | 0;
      r2 = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r2 = (rm < 4 && rd + 1 == k2 || rm > 3 && rd + 1 == k2 / 2) && (d[di + 1] / k2 / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k2 / 2 || rd == 0) && (d[di + 1] / k2 / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0) rd = rd / 1e3 | 0;
      else if (i == 1) rd = rd / 100 | 0;
      else if (i == 2) rd = rd / 10 | 0;
      r2 = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r2 = ((repeating || rm < 4) && rd + 1 == k2 || !repeating && rm > 3 && rd + 1 == k2 / 2) && (d[di + 1] / k2 / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r2;
}
function convertBase(str, baseIn, baseOut) {
  var j2, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j2 = 0; j2 < arr.length; j2++) {
      if (arr[j2] > baseOut - 1) {
        if (arr[j2 + 1] === void 0) arr[j2 + 1] = 0;
        arr[j2 + 1] += arr[j2] / baseOut | 0;
        arr[j2] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x2) {
  var k2, len, y;
  if (x2.isZero()) return x2;
  len = x2.d.length;
  if (len < 32) {
    k2 = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k2)).toString();
  } else {
    k2 = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k2;
  x2 = taylorSeries(Ctor, 1, x2.times(y), new Ctor(1));
  for (var i = k2; i--; ) {
    var cos2x = x2.times(x2);
    x2 = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k2;
  return x2;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x2, k2, base2) {
    var temp, carry = 0, i = x2.length;
    for (x2 = x2.slice(); i--; ) {
      temp = x2[i] * k2 + carry;
      x2[i] = temp % base2 | 0;
      carry = temp / base2 | 0;
    }
    if (carry) x2.unshift(carry);
    return x2;
  }
  function compare(a, b2, aL, bL) {
    var i, r2;
    if (aL != bL) {
      r2 = aL > bL ? 1 : -1;
    } else {
      for (i = r2 = 0; i < aL; i++) {
        if (a[i] != b2[i]) {
          r2 = a[i] > b2[i] ? 1 : -1;
          break;
        }
      }
    }
    return r2;
  }
  function subtract(a, b2, aL, base2) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b2[aL] ? 1 : 0;
      a[aL] = i * base2 + a[aL] - b2[aL];
    }
    for (; !a[0] && a.length > 1; ) a.shift();
  }
  return function(x2, y, pr2, rm, dp, base2) {
    var cmp, e, i, k2, logBase, more, prod, prodL, q3, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x2.constructor, sign3 = x2.s == y.s ? 1 : -1, xd = x2.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x2.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign3 * 0 : sign3 / 0
        )
      );
    }
    if (base2) {
      logBase = 1;
      e = x2.e - y.e;
    } else {
      base2 = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x2.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q3 = new Ctor(sign3);
    qd = q3.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++) ;
    if (yd[i] > (xd[i] || 0)) e--;
    if (pr2 == null) {
      sd = pr2 = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr2 + (x2.e - y.e) + 1;
    } else {
      sd = pr2;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k2 = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k2) && sd--; i++) {
          t = k2 * base2 + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k2 = t % yd | 0;
        }
        more = k2 || i < xL;
      } else {
        k2 = base2 / (yd[0] + 1) | 0;
        if (k2 > 1) {
          yd = multiplyInteger(yd, k2, base2);
          xd = multiplyInteger(xd, k2, base2);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; ) rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base2 / 2) ++yd0;
        do {
          k2 = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base2 + (rem[1] || 0);
            k2 = rem0 / yd0 | 0;
            if (k2 > 1) {
              if (k2 >= base2) k2 = base2 - 1;
              prod = multiplyInteger(yd, k2, base2);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k2--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base2);
              }
            } else {
              if (k2 == 0) cmp = k2 = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL) prod.unshift(0);
            subtract(rem, prod, remL, base2);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k2++;
                subtract(rem, yL < remL ? yz : yd, remL, base2);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k2++;
            rem = [0];
          }
          qd[i++] = k2;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0]) qd.shift();
    }
    if (logBase == 1) {
      q3.e = e;
      inexact = more;
    } else {
      for (i = 1, k2 = qd[0]; k2 >= 10; k2 /= 10) i++;
      q3.e = i + e * logBase - 1;
      finalise(q3, dp ? pr2 + q3.e + 1 : pr2, rm, more);
    }
    return q3;
  };
}();
function finalise(x2, sd, rm, isTruncated) {
  var digits, i, j2, k2, rd, roundUp, w2, xd, xdi, Ctor = x2.constructor;
  out: if (sd != null) {
    xd = x2.d;
    if (!xd) return x2;
    for (digits = 1, k2 = xd[0]; k2 >= 10; k2 /= 10) digits++;
    i = sd - digits;
    if (i < 0) {
      i += LOG_BASE;
      j2 = sd;
      w2 = xd[xdi = 0];
      rd = w2 / mathpow(10, digits - j2 - 1) % 10 | 0;
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k2 = xd.length;
      if (xdi >= k2) {
        if (isTruncated) {
          for (; k2++ <= xdi; ) xd.push(0);
          w2 = rd = 0;
          digits = 1;
          i %= LOG_BASE;
          j2 = i - LOG_BASE + 1;
        } else {
          break out;
        }
      } else {
        w2 = k2 = xd[xdi];
        for (digits = 1; k2 >= 10; k2 /= 10) digits++;
        i %= LOG_BASE;
        j2 = i - LOG_BASE + digits;
        rd = j2 < 0 ? 0 : w2 / mathpow(10, digits - j2 - 1) % 10 | 0;
      }
    }
    isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j2 < 0 ? w2 : w2 % mathpow(10, digits - j2 - 1));
    roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j2 > 0 ? w2 / mathpow(10, digits - j2) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
    if (sd < 1 || !xd[0]) {
      xd.length = 0;
      if (roundUp) {
        sd -= x2.e + 1;
        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
        x2.e = -sd || 0;
      } else {
        xd[0] = x2.e = 0;
      }
      return x2;
    }
    if (i == 0) {
      xd.length = xdi;
      k2 = 1;
      xdi--;
    } else {
      xd.length = xdi + 1;
      k2 = mathpow(10, LOG_BASE - i);
      xd[xdi] = j2 > 0 ? (w2 / mathpow(10, digits - j2) % mathpow(10, j2) | 0) * k2 : 0;
    }
    if (roundUp) {
      for (; ; ) {
        if (xdi == 0) {
          for (i = 1, j2 = xd[0]; j2 >= 10; j2 /= 10) i++;
          j2 = xd[0] += k2;
          for (k2 = 1; j2 >= 10; j2 /= 10) k2++;
          if (i != k2) {
            x2.e++;
            if (xd[0] == BASE) xd[0] = 1;
          }
          break;
        } else {
          xd[xdi] += k2;
          if (xd[xdi] != BASE) break;
          xd[xdi--] = 0;
          k2 = 1;
        }
      }
    }
    for (i = xd.length; xd[--i] === 0; ) xd.pop();
  }
  if (external) {
    if (x2.e > Ctor.maxE) {
      x2.d = null;
      x2.e = NaN;
    } else if (x2.e < Ctor.minE) {
      x2.e = 0;
      x2.d = [0];
    }
  }
  return x2;
}
function finiteToString(x2, isExp, sd) {
  if (!x2.isFinite()) return nonFiniteToString(x2);
  var k2, e = x2.e, str = digitsToString(x2.d), len = str.length;
  if (isExp) {
    if (sd && (k2 = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k2);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x2.e < 0 ? "e" : "e+") + x2.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k2 = sd - len) > 0) str += getZeroString(k2);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k2 = sd - e - 1) > 0) str = str + "." + getZeroString(k2);
  } else {
    if ((k2 = e + 1) < len) str = str.slice(0, k2) + "." + str.slice(k2);
    if (sd && (k2 = sd - len) > 0) {
      if (e + 1 === len) str += ".";
      str += getZeroString(k2);
    }
  }
  return str;
}
function getBase10Exponent(digits, e) {
  var w2 = digits[0];
  for (e *= LOG_BASE; w2 >= 10; w2 /= 10) e++;
  return e;
}
function getLn10(Ctor, sd, pr2) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr2) Ctor.precision = pr2;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w2 = digits.length - 1, len = w2 * LOG_BASE + 1;
  w2 = digits[w2];
  if (w2) {
    for (; w2 % 10 == 0; w2 /= 10) len--;
    for (w2 = digits[0]; w2 >= 10; w2 /= 10) len++;
  }
  return len;
}
function getZeroString(k2) {
  var zs = "";
  for (; k2--; ) zs += "0";
  return zs;
}
function intPow(Ctor, x2, n, pr2) {
  var isTruncated, r2 = new Ctor(1), k2 = Math.ceil(pr2 / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r2 = r2.times(x2);
      if (truncate(r2.d, k2)) isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r2.d.length - 1;
      if (isTruncated && r2.d[n] === 0) ++r2.d[n];
      break;
    }
    x2 = x2.times(x2);
    truncate(x2.d, k2);
  }
  external = true;
  return r2;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, n) {
  var k2, y, x2 = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x2 = y;
      break;
    }
    k2 = x2.cmp(y);
    if (k2 === n || k2 === 0 && x2.s === n) {
      x2 = y;
    }
  }
  return x2;
}
function naturalExponential(x2, sd) {
  var denominator, guard, j2, pow3, sum3, t, wpr, rep = 0, i = 0, k2 = 0, Ctor = x2.constructor, rm = Ctor.rounding, pr2 = Ctor.precision;
  if (!x2.d || !x2.d[0] || x2.e > 17) {
    return new Ctor(x2.d ? !x2.d[0] ? 1 : x2.s < 0 ? 0 : 1 / 0 : x2.s ? x2.s < 0 ? 0 : x2 : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr2;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x2.e > -2) {
    x2 = x2.times(t);
    k2 += 5;
  }
  guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow3 = sum3 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow3 = finalise(pow3.times(x2), wpr, 1);
    denominator = denominator.times(++i);
    t = sum3.plus(divide(pow3, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
      j2 = k2;
      while (j2--) sum3 = finalise(sum3.times(sum3), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow3 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum3, Ctor.precision = pr2, rm, external = true);
        }
      } else {
        Ctor.precision = pr2;
        return sum3;
      }
    }
    sum3 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x3 = y, xd = x3.d, Ctor = x3.constructor, rm = Ctor.rounding, pr2 = Ctor.precision;
  if (x3.s < 0 || !xd || !xd[0] || !x3.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x3.s != 1 ? NaN : xd ? 0 : x3);
  }
  if (sd == null) {
    external = false;
    wpr = pr2;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x3.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x3 = x3.times(y);
      c = digitsToString(x3.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x3.e;
    if (c0 > 1) {
      x3 = new Ctor("0." + c);
      e++;
    } else {
      x3 = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr2).times(e + "");
    x3 = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr2;
    return sd == null ? finalise(x3, pr2, rm, external = true) : x3;
  }
  x1 = x3;
  sum3 = numerator = x3 = divide(x3.minus(1), x3.plus(1), wpr, 1);
  x2 = finalise(x3.times(x3), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum3.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
      sum3 = sum3.times(2);
      if (e !== 0) sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr2).times(e + ""));
      sum3 = divide(sum3, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x3 = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x3.times(x3), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum3, Ctor.precision = pr2, rm, external = true);
        }
      } else {
        Ctor.precision = pr2;
        return sum3;
      }
    }
    sum3 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x2) {
  return String(x2.s * x2.s / 0);
}
function parseDecimal(x2, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++) ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x2.e = e = e - i - 1;
    x2.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;
    if (i < len) {
      if (i) x2.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; ) x2.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; ) str += "0";
    x2.d.push(+str);
    if (external) {
      if (x2.e > x2.constructor.maxE) {
        x2.d = null;
        x2.e = NaN;
      } else if (x2.e < x2.constructor.minE) {
        x2.e = 0;
        x2.d = [0];
      }
    }
  } else {
    x2.e = 0;
    x2.d = [0];
  }
  return x2;
}
function parseOther(x2, str) {
  var base2, Ctor, divisor, i, isFloat, len, p, xd, xe3;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str)) return parseDecimal(x2, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str) x2.s = NaN;
    x2.e = NaN;
    x2.d = null;
    return x2;
  }
  if (isHex.test(str)) {
    base2 = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base2 = 2;
  } else if (isOctal.test(str)) {
    base2 = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x2.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base2), i, i * 2);
  }
  xd = convertBase(str, base2, BASE);
  xe3 = xd.length - 1;
  for (i = xe3; xd[i] === 0; --i) xd.pop();
  if (i < 0) return new Ctor(x2.s * 0);
  x2.e = getBase10Exponent(xd, xe3);
  x2.d = xd;
  external = false;
  if (isFloat) x2 = divide(x2, divisor, len * 4);
  if (p) x2 = x2.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x2;
}
function sine(Ctor, x2) {
  var k2, len = x2.d.length;
  if (len < 3) {
    return x2.isZero() ? x2 : taylorSeries(Ctor, 2, x2, x2);
  }
  k2 = 1.4 * Math.sqrt(len);
  k2 = k2 > 16 ? 16 : k2 | 0;
  x2 = x2.times(1 / tinyPow(5, k2));
  x2 = taylorSeries(Ctor, 2, x2, x2);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k2--; ) {
    sin2_x = x2.times(x2);
    x2 = x2.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x2;
}
function taylorSeries(Ctor, n, x2, y, isHyperbolic) {
  var j2, t, u, x22, i = 1, pr2 = Ctor.precision, k2 = Math.ceil(pr2 / LOG_BASE);
  external = false;
  x22 = x2.times(x2);
  u = new Ctor(y);
  for (; ; ) {
    t = divide(u.times(x22), new Ctor(n++ * n++), pr2, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x22), new Ctor(n++ * n++), pr2, 1);
    t = u.plus(y);
    if (t.d[k2] !== void 0) {
      for (j2 = k2; t.d[j2] === u.d[j2] && j2--; ) ;
      if (j2 == -1) break;
    }
    j2 = u;
    u = y;
    y = t;
    t = j2;
    i++;
  }
  external = true;
  t.d.length = k2 + 1;
  return t;
}
function tinyPow(b2, e) {
  var n = b2;
  while (--e) n *= b2;
  return n;
}
function toLessThanHalfPi(Ctor, x2) {
  var t, isNeg = x2.s < 0, pi2 = getPi(Ctor, Ctor.precision, 1), halfPi = pi2.times(0.5);
  x2 = x2.abs();
  if (x2.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x2;
  }
  t = x2.divToInt(pi2);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x2 = x2.minus(t.times(pi2));
    if (x2.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x2;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x2.minus(pi2).abs();
}
function toStringBinary(x2, baseOut, sd, rm) {
  var base2, e, i, k2, len, roundUp, str, xd, y, Ctor = x2.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x2.isFinite()) {
    str = nonFiniteToString(x2);
  } else {
    str = finiteToString(x2);
    i = str.indexOf(".");
    if (isExp) {
      base2 = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base2 = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base2);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base2);
    e = len = xd.length;
    for (; xd[--len] == 0; ) xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x2 = new Ctor(x2);
        x2.d = xd;
        x2.e = e;
        x2 = divide(x2, y, sd, rm, 0, base2);
        xd = x2.d;
        e = x2.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k2 = base2 / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x2.s < 0 ? 3 : 2)) : i > k2 || i === k2 && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x2.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base2 - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len) ;
      for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++) str += "0";
            xd = convertBase(str, base2, baseOut);
            for (len = xd.length; !xd[len - 1]; --len) ;
            for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; ) str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len) for (e -= len; e--; ) str += "0";
        else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x2.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x2) {
  return new this(x2).abs();
}
function acos(x2) {
  return new this(x2).acos();
}
function acosh(x2) {
  return new this(x2).acosh();
}
function add(x2, y) {
  return new this(x2).plus(y);
}
function asin(x2) {
  return new this(x2).asin();
}
function asinh(x2) {
  return new this(x2).asinh();
}
function atan(x2) {
  return new this(x2).atan();
}
function atanh(x2) {
  return new this(x2).atanh();
}
function atan2(y, x2) {
  y = new this(y);
  x2 = new this(x2);
  var r2, pr2 = this.precision, rm = this.rounding, wpr = pr2 + 4;
  if (!y.s || !x2.s) {
    r2 = new this(NaN);
  } else if (!y.d && !x2.d) {
    r2 = getPi(this, wpr, 1).times(x2.s > 0 ? 0.25 : 0.75);
    r2.s = y.s;
  } else if (!x2.d || y.isZero()) {
    r2 = x2.s < 0 ? getPi(this, pr2, rm) : new this(0);
    r2.s = y.s;
  } else if (!y.d || x2.isZero()) {
    r2 = getPi(this, wpr, 1).times(0.5);
    r2.s = y.s;
  } else if (x2.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r2 = this.atan(divide(y, x2, wpr, 1));
    x2 = getPi(this, wpr, 1);
    this.precision = pr2;
    this.rounding = rm;
    r2 = y.s < 0 ? r2.minus(x2) : r2.plus(x2);
  } else {
    r2 = this.atan(divide(y, x2, wpr, 1));
  }
  return r2;
}
function cbrt(x2) {
  return new this(x2).cbrt();
}
function ceil(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, 2);
}
function clamp(x2, min3, max3) {
  return new this(x2).clamp(min3, max3);
}
function config(obj) {
  if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x2) {
  return new this(x2).cos();
}
function cosh(x2) {
  return new this(x2).cosh();
}
function clone(obj) {
  var i, p, ps;
  function Decimal3(v) {
    var e, i2, t, x2 = this;
    if (!(x2 instanceof Decimal3)) return new Decimal3(v);
    x2.constructor = Decimal3;
    if (isDecimalInstance(v)) {
      x2.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal3.maxE) {
          x2.e = NaN;
          x2.d = null;
        } else if (v.e < Decimal3.minE) {
          x2.e = 0;
          x2.d = [0];
        } else {
          x2.e = v.e;
          x2.d = v.d.slice();
        }
      } else {
        x2.e = v.e;
        x2.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x2.s = 1 / v < 0 ? -1 : 1;
        x2.e = 0;
        x2.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x2.s = -1;
      } else {
        x2.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
        if (external) {
          if (e > Decimal3.maxE) {
            x2.e = NaN;
            x2.d = null;
          } else if (e < Decimal3.minE) {
            x2.e = 0;
            x2.d = [0];
          } else {
            x2.e = e;
            x2.d = [v];
          }
        } else {
          x2.e = e;
          x2.d = [v];
        }
        return;
      }
      if (v * 0 !== 0) {
        if (!v) x2.s = NaN;
        x2.e = NaN;
        x2.d = null;
        return;
      }
      return parseDecimal(x2, v.toString());
    }
    if (t === "string") {
      if ((i2 = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x2.s = -1;
      } else {
        if (i2 === 43) v = v.slice(1);
        x2.s = 1;
      }
      return isDecimal.test(v) ? parseDecimal(x2, v) : parseOther(x2, v);
    }
    if (t === "bigint") {
      if (v < 0) {
        v = -v;
        x2.s = -1;
      } else {
        x2.s = 1;
      }
      return parseDecimal(x2, v.toString());
    }
    throw Error(invalidArgument + v);
  }
  Decimal3.prototype = P;
  Decimal3.ROUND_UP = 0;
  Decimal3.ROUND_DOWN = 1;
  Decimal3.ROUND_CEIL = 2;
  Decimal3.ROUND_FLOOR = 3;
  Decimal3.ROUND_HALF_UP = 4;
  Decimal3.ROUND_HALF_DOWN = 5;
  Decimal3.ROUND_HALF_EVEN = 6;
  Decimal3.ROUND_HALF_CEIL = 7;
  Decimal3.ROUND_HALF_FLOOR = 8;
  Decimal3.EUCLID = 9;
  Decimal3.config = Decimal3.set = config;
  Decimal3.clone = clone;
  Decimal3.isDecimal = isDecimalInstance;
  Decimal3.abs = abs;
  Decimal3.acos = acos;
  Decimal3.acosh = acosh;
  Decimal3.add = add;
  Decimal3.asin = asin;
  Decimal3.asinh = asinh;
  Decimal3.atan = atan;
  Decimal3.atanh = atanh;
  Decimal3.atan2 = atan2;
  Decimal3.cbrt = cbrt;
  Decimal3.ceil = ceil;
  Decimal3.clamp = clamp;
  Decimal3.cos = cos;
  Decimal3.cosh = cosh;
  Decimal3.div = div;
  Decimal3.exp = exp;
  Decimal3.floor = floor;
  Decimal3.hypot = hypot;
  Decimal3.ln = ln;
  Decimal3.log = log;
  Decimal3.log10 = log10;
  Decimal3.log2 = log2;
  Decimal3.max = max;
  Decimal3.min = min;
  Decimal3.mod = mod;
  Decimal3.mul = mul;
  Decimal3.pow = pow;
  Decimal3.random = random;
  Decimal3.round = round;
  Decimal3.sign = sign;
  Decimal3.sin = sin;
  Decimal3.sinh = sinh;
  Decimal3.sqrt = sqrt;
  Decimal3.sub = sub;
  Decimal3.sum = sum;
  Decimal3.tan = tan;
  Decimal3.tanh = tanh;
  Decimal3.trunc = trunc;
  if (obj === void 0) obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }
  }
  Decimal3.config(obj);
  return Decimal3;
}
function div(x2, y) {
  return new this(x2).div(y);
}
function exp(x2) {
  return new this(x2).exp();
}
function floor(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, 3);
}
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x2) {
  return new this(x2).ln();
}
function log(x2, y) {
  return new this(x2).log(y);
}
function log2(x2) {
  return new this(x2).log(2);
}
function log10(x2) {
  return new this(x2).log(10);
}
function max() {
  return maxOrMin(this, arguments, -1);
}
function min() {
  return maxOrMin(this, arguments, 1);
}
function mod(x2, y) {
  return new this(x2).mod(y);
}
function mul(x2, y) {
  return new this(x2).mul(y);
}
function pow(x2, y) {
  return new this(x2).pow(y);
}
function random(sd) {
  var d, e, k2, n, i = 0, r2 = new this(1), rd = [];
  if (sd === void 0) sd = this.precision;
  else checkInt32(sd, 1, MAX_DIGITS);
  k2 = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i < k2; ) rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k2));
    for (; i < k2; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k2 *= 4);
    for (; i < k2; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k2 / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k2 = rd[--i];
  sd %= LOG_BASE;
  if (k2 && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k2 / n | 0) * n;
  }
  for (; rd[i] === 0; i--) rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
    for (k2 = 1, n = rd[0]; n >= 10; n /= 10) k2++;
    if (k2 < LOG_BASE) e -= LOG_BASE - k2;
  }
  r2.e = e;
  r2.d = rd;
  return r2;
}
function round(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, this.rounding);
}
function sign(x2) {
  x2 = new this(x2);
  return x2.d ? x2.d[0] ? x2.s : 0 * x2.s : x2.s || NaN;
}
function sin(x2) {
  return new this(x2).sin();
}
function sinh(x2) {
  return new this(x2).sinh();
}
function sqrt(x2) {
  return new this(x2).sqrt();
}
function sub(x2, y) {
  return new this(x2).sub(y);
}
function sum() {
  var i = 0, args = arguments, x2 = new this(args[i]);
  external = false;
  for (; x2.s && ++i < args.length; ) x2 = x2.plus(args[i]);
  external = true;
  return finalise(x2, this.precision, this.rounding);
}
function tan(x2) {
  return new this(x2).tan();
}
function tanh(x2) {
  return new this(x2).tanh();
}
function trunc(x2) {
  return finalise(x2 = new this(x2), x2.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/subscribable.js
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/utils.js
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop() {
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function replaceEqualDeep(a, b2) {
  if (a === b2) {
    return a;
  }
  const array2 = isPlainArray(a) && isPlainArray(b2);
  if (array2 || isPlainObject(a) && isPlainObject(b2)) {
    const aItems = array2 ? a : Object.keys(a);
    const aSize = aItems.length;
    const bItems = array2 ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy = array2 ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array2 ? i : bItems[i];
      if ((!array2 && aItems.includes(key) || array2) && a[key] === void 0 && b2[key] === void 0) {
        copy[key] = void 0;
        equalItems++;
      } else {
        copy[key] = replaceEqualDeep(a[key], b2[key]);
        if (copy[key] === a[key] && a[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy;
  }
  return b2;
}
function shallowEqualObjects(a, b2) {
  if (!b2 || Object.keys(a).length !== Object.keys(b2).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b2[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    if (process.env.NODE_ENV !== "production") {
      try {
        return replaceEqualDeep(prevData, data);
      } catch (error) {
        console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`
        );
        throw error;
      }
    }
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
var skipToken = Symbol();
function shouldThrowError(throwOnError, params) {
  if (typeof throwOnError === "function") {
    return throwOnError(...params);
  }
  return !!throwOnError;
}

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/focusManager.js
var _focused, _cleanup, _setup, _a;
var FocusManager = (_a = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a7;
    if (!this.hasListeners()) {
      (_a7 = __privateGet(this, _cleanup)) == null ? void 0 : _a7.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a7;
    __privateSet(this, _setup, setup);
    (_a7 = __privateGet(this, _cleanup)) == null ? void 0 : _a7.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a7;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a7 = globalThis.document) == null ? void 0 : _a7.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
var focusManager = new FocusManager();

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/onlineManager.js
var _online, _cleanup2, _setup2, _a2;
var OnlineManager = (_a2 = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a7;
    if (!this.hasListeners()) {
      (_a7 = __privateGet(this, _cleanup2)) == null ? void 0 : _a7.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a7;
    __privateSet(this, _setup2, setup);
    (_a7 = __privateGet(this, _cleanup2)) == null ? void 0 : _a7.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _a2);
var onlineManager = new OnlineManager();

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/thenable.js
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/retryer.js
function canFetch(networkMode) {
  return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
}

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/notifyManager.js
var defaultScheduler = (cb) => setTimeout(cb, 0);
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = defaultScheduler;
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn3) => {
      notifyFn = fn3;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn3) => {
      batchNotifyFn = fn3;
    },
    setScheduler: (fn3) => {
      scheduleFn = fn3;
    }
  };
}
var notifyManager = createNotifyManager();

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/query.js
function fetchState(data, options) {
  return __spreadValues({
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused"
  }, data === void 0 && {
    error: null,
    status: "pending"
  });
}

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/mutation.js
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/queryObserver.js
var _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _b;
var QueryObserver = (_b = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _QueryObserver_instances);
    __privateAdd(this, _client);
    __privateAdd(this, _currentQuery);
    __privateAdd(this, _currentQueryInitialState);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentResultState);
    __privateAdd(this, _currentResultOptions);
    __privateAdd(this, _currentThenable);
    __privateAdd(this, _selectError);
    __privateAdd(this, _selectFn);
    __privateAdd(this, _selectResult);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    __privateAdd(this, _lastQueryWithDefinedData);
    __privateAdd(this, _staleTimeoutId);
    __privateAdd(this, _refetchIntervalId);
    __privateAdd(this, _currentRefetchInterval);
    __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
    this.options = options;
    __privateSet(this, _client, client);
    __privateSet(this, _selectError, null);
    __privateSet(this, _currentThenable, pendingThenable());
    if (!this.options.experimental_prefetchInRender) {
      __privateGet(this, _currentThenable).reject(
        new Error("experimental_prefetchInRender feature flag is not enabled")
      );
    }
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      __privateGet(this, _currentQuery).addObserver(this);
      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      } else {
        this.updateResult();
      }
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateGet(this, _currentQuery).removeObserver(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    const prevQuery = __privateGet(this, _currentQuery);
    this.options = __privateGet(this, _client).defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    __privateGet(this, _currentQuery).setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: __privateGet(this, _currentQuery),
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      __privateGet(this, _currentQuery),
      prevQuery,
      this.options,
      prevOptions
    )) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
    this.updateResult();
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
      __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    }
    const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
      __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      __privateSet(this, _currentResult, result);
      __privateSet(this, _currentResultOptions, this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    }
    return result;
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  trackResult(result, onPropTracked) {
    return new Proxy(result, {
      get: (target, key) => {
        this.trackProp(key);
        onPropTracked == null ? void 0 : onPropTracked(key);
        return Reflect.get(target, key);
      }
    });
  }
  trackProp(key) {
    __privateGet(this, _trackedProps).add(key);
  }
  getCurrentQuery() {
    return __privateGet(this, _currentQuery);
  }
  refetch(_a7 = {}) {
    var options = __objRest(_a7, []);
    return this.fetch(__spreadValues({}, options));
  }
  fetchOptimistic(options) {
    const defaultedOptions = __privateGet(this, _client).defaultQueryOptions(options);
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), defaultedOptions);
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    var _a7;
    return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, __spreadProps(__spreadValues({}, fetchOptions), {
      cancelRefetch: (_a7 = fetchOptions.cancelRefetch) != null ? _a7 : true
    })).then(() => {
      this.updateResult();
      return __privateGet(this, _currentResult);
    });
  }
  createResult(query, options) {
    var _a7;
    const prevQuery = __privateGet(this, _currentQuery);
    const prevOptions = this.options;
    const prevResult = __privateGet(this, _currentResult);
    const prevResultState = __privateGet(this, _currentResultState);
    const prevResultOptions = __privateGet(this, _currentResultOptions);
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
    const { state } = query;
    let newState = __spreadValues({}, state);
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = __spreadValues(__spreadValues({}, newState), fetchState(state.data, query.options));
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    data = newState.data;
    let skipSelect = false;
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
        skipSelect = true;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          (_a7 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a7.state.data,
          __privateGet(this, _lastQueryWithDefinedData)
        ) : options.placeholderData;
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult == null ? void 0 : prevResult.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (options.select && data !== void 0 && !skipSelect) {
      if (prevResult && data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {
        data = __privateGet(this, _selectResult);
      } else {
        try {
          __privateSet(this, _selectFn, options.select);
          data = options.select(data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          __privateSet(this, _selectResult, data);
          __privateSet(this, _selectError, null);
        } catch (selectError) {
          __privateSet(this, _selectError, selectError);
        }
      }
    }
    if (__privateGet(this, _selectError)) {
      error = __privateGet(this, _selectError);
      data = __privateGet(this, _selectResult);
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch,
      promise: __privateGet(this, _currentThenable)
    };
    const nextResult = result;
    if (this.options.experimental_prefetchInRender) {
      const finalizeThenableIfPossible = (thenable) => {
        if (nextResult.status === "error") {
          thenable.reject(nextResult.error);
        } else if (nextResult.data !== void 0) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = __privateSet(this, _currentThenable, nextResult.promise = pendingThenable());
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = __privateGet(this, _currentThenable);
      switch (prevThenable.status) {
        case "pending":
          if (query.queryHash === prevQuery.queryHash) {
            finalizeThenableIfPossible(prevThenable);
          }
          break;
        case "fulfilled":
          if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    return nextResult;
  }
  updateResult() {
    const prevResult = __privateGet(this, _currentResult);
    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    __privateSet(this, _currentResultOptions, this.options);
    if (__privateGet(this, _currentResultState).data !== void 0) {
      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    __privateSet(this, _currentResult, nextResult);
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue != null ? notifyOnChangePropsValue : __privateGet(this, _trackedProps)
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(__privateGet(this, _currentResult)).some((key) => {
        const typedKey = key;
        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { listeners: shouldNotifyListeners() });
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
}, _client = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _currentThenable = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
  __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
  let promise = __privateGet(this, _currentQuery).fetch(
    this.options,
    fetchOptions
  );
  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
    promise = promise.catch(noop);
  }
  return promise;
}, updateStaleTimeout_fn = function() {
  __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
  const staleTime = resolveStaleTime(
    this.options.staleTime,
    __privateGet(this, _currentQuery)
  );
  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
    return;
  }
  const time = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
  const timeout = time + 1;
  __privateSet(this, _staleTimeoutId, setTimeout(() => {
    if (!__privateGet(this, _currentResult).isStale) {
      this.updateResult();
    }
  }, timeout));
}, computeRefetchInterval_fn = function() {
  var _a7;
  return (_a7 = typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) != null ? _a7 : false;
}, updateRefetchInterval_fn = function(nextInterval) {
  __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
  __privateSet(this, _currentRefetchInterval, nextInterval);
  if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
    return;
  }
  __privateSet(this, _refetchIntervalId, setInterval(() => {
    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
  }, __privateGet(this, _currentRefetchInterval)));
}, updateTimers_fn = function() {
  __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
  __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
}, clearStaleTimeout_fn = function() {
  if (__privateGet(this, _staleTimeoutId)) {
    clearTimeout(__privateGet(this, _staleTimeoutId));
    __privateSet(this, _staleTimeoutId, void 0);
  }
}, clearRefetchInterval_fn = function() {
  if (__privateGet(this, _refetchIntervalId)) {
    clearInterval(__privateGet(this, _refetchIntervalId));
    __privateSet(this, _refetchIntervalId, void 0);
  }
}, updateQuery_fn = function() {
  const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), this.options);
  if (query === __privateGet(this, _currentQuery)) {
    return;
  }
  const prevQuery = __privateGet(this, _currentQuery);
  __privateSet(this, _currentQuery, query);
  __privateSet(this, _currentQueryInitialState, query.state);
  if (this.hasListeners()) {
    prevQuery == null ? void 0 : prevQuery.removeObserver(this);
    query.addObserver(this);
  }
}, notify_fn = function(notifyOptions) {
  notifyManager.batch(() => {
    if (notifyOptions.listeners) {
      this.listeners.forEach((listener) => {
        listener(__privateGet(this, _currentResult));
      });
    }
    __privateGet(this, _client).getQueryCache().notify({
      query: __privateGet(this, _currentQuery),
      type: "observerResultsUpdated"
    });
  });
}, _b);
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}

// ../../node_modules/.pnpm/@tanstack+query-core@5.76.0/node_modules/@tanstack/query-core/build/modern/mutationObserver.js
var _client2, _currentResult2, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn2, _a3;
var MutationObserver = (_a3 = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client2);
    __privateAdd(this, _currentResult2);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client2, client);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a7;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client2).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client2).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a7 = __privateGet(this, _currentMutation)) == null ? void 0 : _a7.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a7;
    if (!this.hasListeners()) {
      (_a7 = __privateGet(this, _currentMutation)) == null ? void 0 : _a7.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult2);
  }
  reset() {
    var _a7;
    (_a7 = __privateGet(this, _currentMutation)) == null ? void 0 : _a7.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this);
  }
  mutate(variables, options) {
    var _a7;
    __privateSet(this, _mutateOptions, options);
    (_a7 = __privateGet(this, _currentMutation)) == null ? void 0 : _a7.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client2).getMutationCache().build(__privateGet(this, _client2), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client2 = new WeakMap(), _currentResult2 = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  var _a7, _b3;
  const state = (_b3 = (_a7 = __privateGet(this, _currentMutation)) == null ? void 0 : _a7.state) != null ? _b3 : getDefaultState();
  __privateSet(this, _currentResult2, __spreadProps(__spreadValues({}, state), {
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  }));
}, notify_fn2 = function(action) {
  notifyManager.batch(() => {
    var _a7, _b3, _c, _d, _e3, _f, _g, _h;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult2).variables;
      const context = __privateGet(this, _currentResult2).context;
      if ((action == null ? void 0 : action.type) === "success") {
        (_b3 = (_a7 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b3.call(_a7, action.data, variables, context);
        (_d = (_c = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d.call(_c, action.data, null, variables, context);
      } else if ((action == null ? void 0 : action.type) === "error") {
        (_f = (_e3 = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f.call(_e3, action.error, variables, context);
        (_h = (_g = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h.call(
          _g,
          void 0,
          action.error,
          variables,
          context
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult2));
    });
  });
}, _a3);

// ../../node_modules/.pnpm/@tanstack+react-query@5.76.0_react@19.1.0/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var QueryClientContext = React.createContext(
  void 0
);
var useQueryClient = (queryClient) => {
  const client = React.useContext(QueryClientContext);
  if (queryClient) {
    return queryClient;
  }
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};

// ../../node_modules/.pnpm/@tanstack+react-query@5.76.0_react@19.1.0/node_modules/@tanstack/react-query/build/modern/IsRestoringProvider.js
var React2 = __toESM(require_react(), 1);
var IsRestoringContext = React2.createContext(false);
var useIsRestoring = () => React2.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// ../../node_modules/.pnpm/@tanstack+react-query@5.76.0_react@19.1.0/node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React3.createContext(createValue());
var useQueryErrorResetBoundary = () => React3.useContext(QueryErrorResetBoundaryContext);

// ../../node_modules/.pnpm/@tanstack+react-query@5.76.0_react@19.1.0/node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
var React4 = __toESM(require_react(), 1);
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  React4.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));
};

// ../../node_modules/.pnpm/@tanstack+react-query@5.76.0_react@19.1.0/node_modules/@tanstack/react-query/build/modern/suspense.js
var ensureSuspenseTimers = (defaultedOptions) => {
  const originalStaleTime = defaultedOptions.staleTime;
  if (defaultedOptions.suspense) {
    defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => Math.max(originalStaleTime(...args), 1e3) : Math.max(originalStaleTime != null ? originalStaleTime : 1e3, 1e3);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});

// ../../node_modules/.pnpm/@tanstack+react-query@5.76.0_react@19.1.0/node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
var React5 = __toESM(require_react(), 1);
function useBaseQuery(options, Observer, queryClient) {
  var _a7, _b3, _c, _d, _e3;
  if (process.env.NODE_ENV !== "production") {
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new Error(
        'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
      );
    }
  }
  const client = useQueryClient(queryClient);
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = client.defaultQueryOptions(options);
  (_b3 = (_a7 = client.getDefaultOptions().queries) == null ? void 0 : _a7._experimental_beforeQuery) == null ? void 0 : _b3.call(
    _a7,
    defaultedOptions
  );
  if (process.env.NODE_ENV !== "production") {
    if (!defaultedOptions.queryFn) {
      console.error(
        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
      );
    }
  }
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = React5.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  React5.useSyncExternalStore(
    React5.useCallback(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  React5.useEffect(() => {
    observer.setOptions(defaultedOptions);
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client.getQueryCache().get(defaultedOptions.queryHash),
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  ;
  (_d = (_c = client.getDefaultOptions().queries) == null ? void 0 : _c._experimental_afterQuery) == null ? void 0 : _d.call(
    _c,
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (_e3 = client.getQueryCache().get(defaultedOptions.queryHash)) == null ? void 0 : _e3.promise
    );
    promise == null ? void 0 : promise.catch(noop).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// ../../node_modules/.pnpm/@tanstack+react-query@5.76.0_react@19.1.0/node_modules/@tanstack/react-query/build/modern/useQuery.js
function useQuery(options, queryClient) {
  return useBaseQuery(options, QueryObserver, queryClient);
}

// ../../node_modules/.pnpm/@tanstack+react-query@5.76.0_react@19.1.0/node_modules/@tanstack/react-query/build/modern/useMutation.js
var React6 = __toESM(require_react(), 1);
function useMutation(options, queryClient) {
  const client = useQueryClient(queryClient);
  const [observer] = React6.useState(
    () => new MutationObserver(
      client,
      options
    )
  );
  React6.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = React6.useSyncExternalStore(
    React6.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = React6.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return __spreadProps(__spreadValues({}, result), { mutate, mutateAsync: result.mutate });
}

// ../../node_modules/.pnpm/base-x@5.0.1/node_modules/base-x/src/esm/index.js
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (let i = 0; i < ALPHABET2.length; i++) {
    const x2 = ALPHABET2.charAt(i);
    const xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  const BASE3 = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE3) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE3);
  function encode(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i = 0;
      for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE3 >>> 0;
        carry = carry / BASE3 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i = 0;
      for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE3 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode(string2) {
    const buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE3 + " character");
  }
  return {
    encode,
    decodeUnsafe,
    decode
  };
}
var esm_default = base;

// ../../node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/esm/b58.js
var toBase58 = (buffer) => esm_default2.encode(buffer);
var fromBase58 = (str) => esm_default2.decode(str);

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/esm/b64.js
function fromBase64(base64String2) {
  return Uint8Array.from(atob(base64String2), (char) => char.charCodeAt(0));
}
var CHUNK_SIZE = 8192;
function toBase64(bytes) {
  if (bytes.length < CHUNK_SIZE) {
    return btoa(String.fromCharCode(...bytes));
  }
  let output = "";
  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
    const chunk2 = bytes.slice(i, i + CHUNK_SIZE);
    output += String.fromCharCode(...chunk2);
  }
  return btoa(output);
}

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/esm/hex.js
function fromHex(hexStr) {
  var _a7, _b3;
  const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;
  const intArr = (_b3 = (_a7 = padded.match(/[0-9a-fA-F]{2}/g)) == null ? void 0 : _a7.map((byte) => parseInt(byte, 16))) != null ? _b3 : [];
  if (intArr.length !== padded.length / 2) {
    throw new Error(`Invalid hex string ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
function toHex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/esm/uleb.js
function ulebEncode(num) {
  let arr = [];
  let len = 0;
  if (num === 0) {
    return [0];
  }
  while (num > 0) {
    arr[len] = num & 127;
    if (num >>= 7) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode(arr) {
  let total = 0;
  let shift = 0;
  let len = 0;
  while (true) {
    let byte = arr[len];
    len += 1;
    total |= (byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return {
    value: total,
    length: len
  };
}

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/esm/reader.js
var BcsReader = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    let value = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    let value = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    let value = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    let value1 = this.read32();
    let value2 = this.read32();
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    let value1 = BigInt(this.read64());
    let value2 = BigInt(this.read64());
    let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    let value1 = BigInt(this.read128());
    let value2 = BigInt(this.read128());
    let result = value2.toString(16) + value1.toString(16).padStart(32, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num) {
    let start = this.bytePosition + this.dataView.byteOffset;
    let value = new Uint8Array(this.dataView.buffer, start, num);
    this.shift(num);
    return value;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    let start = this.bytePosition + this.dataView.byteOffset;
    let buffer = new Uint8Array(this.dataView.buffer, start);
    let { value, length } = ulebDecode(buffer);
    this.shift(length);
    return value;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb) {
    let length = this.readULEB();
    let result = [];
    for (let i = 0; i < length; i++) {
      result.push(cb(this, i, length));
    }
    return result;
  }
};

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/esm/utils.js
function encodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return toBase58(data);
    case "base64":
      return toBase64(data);
    case "hex":
      return toHex(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function splitGenericParameters(str, genericSeparators = ["<", ">"]) {
  const [left, right] = genericSeparators;
  const tok = [];
  let word = "";
  let nestedAngleBrackets = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (char === left) {
      nestedAngleBrackets++;
    }
    if (char === right) {
      nestedAngleBrackets--;
    }
    if (nestedAngleBrackets === 0 && char === ",") {
      tok.push(word.trim());
      word = "";
      continue;
    }
    word += char;
  }
  tok.push(word.trim());
  return tok;
}

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/esm/writer.js
var BcsWriter = class {
  constructor({
    initialSize = 1024,
    maxSize = Infinity,
    allocateSize = 1024
  } = {}) {
    this.bytePosition = 0;
    this.size = initialSize;
    this.maxSize = maxSize;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(initialSize));
  }
  ensureSizeOrGrow(bytes) {
    const requiredSize = this.bytePosition + bytes;
    if (requiredSize > this.size) {
      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value));
    return this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value) {
    toLittleEndian(BigInt(value), 8).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value) {
    toLittleEndian(BigInt(value), 16).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value) {
    toLittleEndian(BigInt(value), 32).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value) {
    ulebEncode(value).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector, cb) {
    this.writeULEB(vector.length);
    Array.from(vector).forEach((el2, i) => cb(this, el2, i, vector.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let i = 0; i < this.bytePosition; i++) {
      yield this.dataView.getUint8(i);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr(this.toBytes(), encoding);
  }
};
function toLittleEndian(bigint2, size) {
  let result = new Uint8Array(size);
  let i = 0;
  while (bigint2 > 0) {
    result[i] = Number(bigint2 % BigInt(256));
    bigint2 = bigint2 / BigInt(256);
    i += 1;
  }
  return result;
}

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/esm/bcs-type.js
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _write;
var _serialize;
var _schema;
var _bytes;
var _BcsType = class _BcsType2 {
  constructor(options) {
    var _a7, _b3, _c;
    __privateAdd2(this, _write);
    __privateAdd2(this, _serialize);
    this.name = options.name;
    this.read = options.read;
    this.serializedSize = (_a7 = options.serializedSize) != null ? _a7 : () => null;
    __privateSet2(this, _write, options.write);
    __privateSet2(this, _serialize, (_b3 = options.serialize) != null ? _b3 : (value, options2) => {
      var _a8;
      const writer = new BcsWriter(__spreadValues({
        initialSize: (_a8 = this.serializedSize(value)) != null ? _a8 : void 0
      }, options2));
      __privateGet2(this, _write).call(this, value, writer);
      return writer.toBytes();
    });
    this.validate = (_c = options.validate) != null ? _c : () => {
    };
  }
  write(value, writer) {
    this.validate(value);
    __privateGet2(this, _write).call(this, value, writer);
  }
  serialize(value, options) {
    this.validate(value);
    return new SerializedBcs(this, __privateGet2(this, _serialize).call(this, value, options));
  }
  parse(bytes) {
    const reader = new BcsReader(bytes);
    return this.read(reader);
  }
  fromHex(hex) {
    return this.parse(fromHex(hex));
  }
  fromBase58(b64) {
    return this.parse(fromBase58(b64));
  }
  fromBase64(b64) {
    return this.parse(fromBase64(b64));
  }
  transform({
    name,
    input,
    output,
    validate: validate2
  }) {
    return new _BcsType2({
      name: name != null ? name : this.name,
      read: (reader) => output(this.read(reader)),
      write: (value, writer) => __privateGet2(this, _write).call(this, input(value), writer),
      serializedSize: (value) => this.serializedSize(input(value)),
      serialize: (value, options) => __privateGet2(this, _serialize).call(this, input(value), options),
      validate: (value) => {
        validate2 == null ? void 0 : validate2(value);
        this.validate(input(value));
      }
    });
  }
};
_write = /* @__PURE__ */ new WeakMap();
_serialize = /* @__PURE__ */ new WeakMap();
var BcsType = _BcsType;
var SERIALIZED_BCS_BRAND = Symbol.for("@mysten/serialized-bcs");
function isSerializedBcs(obj) {
  return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
var SerializedBcs = class {
  constructor(type, schema) {
    __privateAdd2(this, _schema);
    __privateAdd2(this, _bytes);
    __privateSet2(this, _schema, type);
    __privateSet2(this, _bytes, schema);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [SERIALIZED_BCS_BRAND]() {
    return true;
  }
  toBytes() {
    return __privateGet2(this, _bytes);
  }
  toHex() {
    return toHex(__privateGet2(this, _bytes));
  }
  toBase64() {
    return toBase64(__privateGet2(this, _bytes));
  }
  toBase58() {
    return toBase58(__privateGet2(this, _bytes));
  }
  parse() {
    return __privateGet2(this, _schema).parse(__privateGet2(this, _bytes));
  }
};
_schema = /* @__PURE__ */ new WeakMap();
_bytes = /* @__PURE__ */ new WeakMap();
function fixedSizeBcsType(_a7) {
  var _b3 = _a7, {
    size
  } = _b3, options = __objRest(_b3, [
    "size"
  ]);
  return new BcsType(__spreadProps(__spreadValues({}, options), {
    serializedSize: () => size
  }));
}
function uIntBcsType(_a7) {
  var _b3 = _a7, {
    readMethod,
    writeMethod
  } = _b3, options = __objRest(_b3, [
    "readMethod",
    "writeMethod"
  ]);
  return fixedSizeBcsType(__spreadProps(__spreadValues({}, options), {
    read: (reader) => reader[readMethod](),
    write: (value, writer) => writer[writeMethod](value),
    validate: (value) => {
      var _a8;
      if (value < 0 || value > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a8 = options.validate) == null ? void 0 : _a8.call(options, value);
    }
  }));
}
function bigUIntBcsType(_a7) {
  var _b3 = _a7, {
    readMethod,
    writeMethod
  } = _b3, options = __objRest(_b3, [
    "readMethod",
    "writeMethod"
  ]);
  return fixedSizeBcsType(__spreadProps(__spreadValues({}, options), {
    read: (reader) => reader[readMethod](),
    write: (value, writer) => writer[writeMethod](BigInt(value)),
    validate: (val) => {
      var _a8;
      const value = BigInt(val);
      if (value < 0 || value > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a8 = options.validate) == null ? void 0 : _a8.call(options, value);
    }
  }));
}
function dynamicSizeBcsType(_a7) {
  var _b3 = _a7, {
    serialize
  } = _b3, options = __objRest(_b3, [
    "serialize"
  ]);
  const type = new BcsType(__spreadProps(__spreadValues({}, options), {
    serialize,
    write: (value, writer) => {
      for (const byte of type.serialize(value).toBytes()) {
        writer.write8(byte);
      }
    }
  }));
  return type;
}
function stringLikeBcsType(_a7) {
  var _b3 = _a7, {
    toBytes: toBytes2,
    fromBytes
  } = _b3, options = __objRest(_b3, [
    "toBytes",
    "fromBytes"
  ]);
  return new BcsType(__spreadProps(__spreadValues({}, options), {
    read: (reader) => {
      const length = reader.readULEB();
      const bytes = reader.readBytes(length);
      return fromBytes(bytes);
    },
    write: (hex, writer) => {
      const bytes = toBytes2(hex);
      writer.writeULEB(bytes.length);
      for (let i = 0; i < bytes.length; i++) {
        writer.write8(bytes[i]);
      }
    },
    serialize: (value) => {
      const bytes = toBytes2(value);
      const size = ulebEncode(bytes.length);
      const result = new Uint8Array(size.length + bytes.length);
      result.set(size, 0);
      result.set(bytes, size.length);
      return result;
    },
    validate: (value) => {
      var _a8;
      if (typeof value !== "string") {
        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);
      }
      (_a8 = options.validate) == null ? void 0 : _a8.call(options, value);
    }
  }));
}
function lazyBcsType(cb) {
  let lazyType = null;
  function getType() {
    if (!lazyType) {
      lazyType = cb();
    }
    return lazyType;
  }
  return new BcsType({
    name: "lazy",
    read: (data) => getType().read(data),
    serializedSize: (value) => getType().serializedSize(value),
    write: (value, writer) => getType().write(value, writer),
    serialize: (value, options) => getType().serialize(value, options).toBytes()
  });
}

// ../../node_modules/.pnpm/@mysten+bcs@1.2.0/node_modules/@mysten/bcs/dist/esm/bcs.js
var bcs = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(options) {
    return uIntBcsType(__spreadValues({
      name: "u8",
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1
    }, options));
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(options) {
    return uIntBcsType(__spreadValues({
      name: "u16",
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1
    }, options));
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(options) {
    return uIntBcsType(__spreadValues({
      name: "u32",
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1
    }, options));
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(options) {
    return bigUIntBcsType(__spreadValues({
      name: "u64",
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: /* @__PURE__ */ BigInt("2") ** /* @__PURE__ */ BigInt("64") - /* @__PURE__ */ BigInt("1")
    }, options));
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(options) {
    return bigUIntBcsType(__spreadValues({
      name: "u128",
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: /* @__PURE__ */ BigInt("2") ** /* @__PURE__ */ BigInt("128") - /* @__PURE__ */ BigInt("1")
    }, options));
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(options) {
    return bigUIntBcsType(__spreadValues({
      name: "u256",
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: /* @__PURE__ */ BigInt("2") ** /* @__PURE__ */ BigInt("256") - /* @__PURE__ */ BigInt("1")
    }, options));
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(options) {
    return fixedSizeBcsType(__spreadProps(__spreadValues({
      name: "bool",
      size: 1,
      read: (reader) => reader.read8() === 1,
      write: (value, writer) => writer.write8(value ? 1 : 0)
    }, options), {
      validate: (value) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
        if (typeof value !== "boolean") {
          throw new TypeError(`Expected boolean, found ${typeof value}`);
        }
      }
    }));
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(options) {
    return dynamicSizeBcsType(__spreadValues({
      name: "uleb128",
      read: (reader) => reader.readULEB(),
      serialize: (value) => {
        return Uint8Array.from(ulebEncode(value));
      }
    }, options));
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(size, options) {
    return fixedSizeBcsType(__spreadProps(__spreadValues({
      name: `bytes[${size}]`,
      size,
      read: (reader) => reader.readBytes(size),
      write: (value, writer) => {
        var _a7;
        const array2 = new Uint8Array(value);
        for (let i = 0; i < size; i++) {
          writer.write8((_a7 = array2[i]) != null ? _a7 : 0);
        }
      }
    }, options), {
      validate: (value) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
        if (!value || typeof value !== "object" || !("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
        }
      }
    }));
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(options) {
    return stringLikeBcsType(__spreadValues({
      name: "string",
      toBytes: (value) => new TextEncoder().encode(value),
      fromBytes: (bytes) => new TextDecoder().decode(bytes)
    }, options));
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray(size, type, options) {
    return new BcsType(__spreadProps(__spreadValues({
      name: `${type.name}[${size}]`,
      read: (reader) => {
        const result = new Array(size);
        for (let i = 0; i < size; i++) {
          result[i] = type.read(reader);
        }
        return result;
      },
      write: (value, writer) => {
        for (const item of value) {
          type.write(item, writer);
        }
      }
    }, options), {
      validate: (value) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
        if (!value || typeof value !== "object" || !("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
        }
      }
    }));
  },
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option(type) {
    return bcs.enum(`Option<${type.name}>`, {
      None: null,
      Some: type
    }).transform({
      input: (value) => {
        if (value == null) {
          return { None: true };
        }
        return { Some: value };
      },
      output: (value) => {
        if (value.$kind === "Some") {
          return value.Some;
        }
        return null;
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector(type, options) {
    return new BcsType(__spreadProps(__spreadValues({
      name: `vector<${type.name}>`,
      read: (reader) => {
        const length = reader.readULEB();
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
          result[i] = type.read(reader);
        }
        return result;
      },
      write: (value, writer) => {
        writer.writeULEB(value.length);
        for (const item of value) {
          type.write(item, writer);
        }
      }
    }, options), {
      validate: (value) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
        if (!value || typeof value !== "object" || !("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
      }
    }));
  },
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(types, options) {
    return new BcsType(__spreadProps(__spreadValues({
      name: `(${types.map((t) => t.name).join(", ")})`,
      serializedSize: (values) => {
        let total = 0;
        for (let i = 0; i < types.length; i++) {
          const size = types[i].serializedSize(values[i]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = [];
        for (const type of types) {
          result.push(type.read(reader));
        }
        return result;
      },
      write: (value, writer) => {
        for (let i = 0; i < types.length; i++) {
          types[i].write(value[i], writer);
        }
      }
    }, options), {
      validate: (value) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
        if (!Array.isArray(value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== types.length) {
          throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);
        }
      }
    }));
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(name, fields, options) {
    const canonicalOrder = Object.entries(fields);
    return new BcsType(__spreadProps(__spreadValues({
      name,
      serializedSize: (values) => {
        let total = 0;
        for (const [field, type] of canonicalOrder) {
          const size = type.serializedSize(values[field]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = {};
        for (const [field, type] of canonicalOrder) {
          result[field] = type.read(reader);
        }
        return result;
      },
      write: (value, writer) => {
        for (const [field, type] of canonicalOrder) {
          type.write(value[field], writer);
        }
      }
    }, options), {
      validate: (value) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
        if (typeof value !== "object" || value == null) {
          throw new TypeError(`Expected object, found ${typeof value}`);
        }
      }
    }));
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(name, values, options) {
    const canonicalOrder = Object.entries(values);
    return new BcsType(__spreadProps(__spreadValues({
      name,
      read: (reader) => {
        var _a7;
        const index = reader.readULEB();
        const enumEntry = canonicalOrder[index];
        if (!enumEntry) {
          throw new TypeError(`Unknown value ${index} for enum ${name}`);
        }
        const [kind, type] = enumEntry;
        return {
          [kind]: (_a7 = type == null ? void 0 : type.read(reader)) != null ? _a7 : true,
          $kind: kind
        };
      },
      write: (value, writer) => {
        const [name2, val] = Object.entries(value).filter(
          ([name3]) => Object.hasOwn(values, name3)
        )[0];
        for (let i = 0; i < canonicalOrder.length; i++) {
          const [optionName, optionType] = canonicalOrder[i];
          if (optionName === name2) {
            writer.writeULEB(i);
            optionType == null ? void 0 : optionType.write(val, writer);
            return;
          }
        }
      }
    }, options), {
      validate: (value) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value);
        if (typeof value !== "object" || value == null) {
          throw new TypeError(`Expected object, found ${typeof value}`);
        }
        const keys = Object.keys(value).filter(
          (k2) => value[k2] !== void 0 && Object.hasOwn(values, k2)
        );
        if (keys.length !== 1) {
          throw new TypeError(
            `Expected object with one key, but found ${keys.length} for type ${name}}`
          );
        }
        const [variant] = keys;
        if (!Object.hasOwn(values, variant)) {
          throw new TypeError(`Invalid enum variant ${variant}`);
        }
      }
    }));
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map(keyType, valueType) {
    return bcs.vector(bcs.tuple([keyType, valueType])).transform({
      name: `Map<${keyType.name}, ${valueType.name}>`,
      input: (value) => {
        return [...value.entries()];
      },
      output: (value) => {
        const result = /* @__PURE__ */ new Map();
        for (const [key, val] of value) {
          result.set(key, val);
        }
        return result;
      }
    });
  },
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(cb) {
    return lazyBcsType(cb);
  }
};

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/utils/sui-types.js
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value) {
  try {
    const buffer = fromBase58(value);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e) {
    return false;
  }
}
var SUI_ADDRESS_LENGTH = 32;
function isValidSuiAddress(value) {
  return isHex2(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;
}
function isValidSuiObjectId(value) {
  return isValidSuiAddress(value);
}
function parseTypeTag(type) {
  if (!type.includes("::")) return type;
  return parseStructTag(type);
}
function parseStructTag(type) {
  const [address, module2] = type.split("::");
  const rest = type.slice(address.length + module2.length + 4);
  const name = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
  const typeParams = rest.includes("<") ? splitGenericParameters(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map(
    (typeParam) => parseTypeTag(typeParam.trim())
  ) : [];
  return {
    address: normalizeSuiAddress(address),
    module: module2,
    name,
    typeParams
  };
}
function normalizeStructTag(type) {
  const { address, module: module2, name, typeParams } = typeof type === "string" ? parseStructTag(type) : type;
  const formattedTypeParams = (typeParams == null ? void 0 : typeParams.length) > 0 ? `<${typeParams.map(
    (typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag(typeParam)
  ).join(",")}>` : "";
  return `${address}::${module2}::${name}${formattedTypeParams}`;
}
function normalizeSuiAddress(value, forceAdd0x = false) {
  let address = value.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value, forceAdd0x = false) {
  return normalizeSuiAddress(value, forceAdd0x);
}
function isHex2(value) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength(value) {
  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class _TypeTagSerializer {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: _TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : _TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
        }
      };
    }
    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    return splitGenericParameters(str).map(
      (tok) => _TypeTagSerializer.parseFromStr(tok, normalizeAddress)
    );
  }
  static tagToString(tag3) {
    if ("bool" in tag3) {
      return "bool";
    }
    if ("u8" in tag3) {
      return "u8";
    }
    if ("u16" in tag3) {
      return "u16";
    }
    if ("u32" in tag3) {
      return "u32";
    }
    if ("u64" in tag3) {
      return "u64";
    }
    if ("u128" in tag3) {
      return "u128";
    }
    if ("u256" in tag3) {
      return "u256";
    }
    if ("address" in tag3) {
      return "address";
    }
    if ("signer" in tag3) {
      return "signer";
    }
    if ("vector" in tag3) {
      return `vector<${_TypeTagSerializer.tagToString(tag3.vector)}>`;
    }
    if ("struct" in tag3) {
      const struct = tag3.struct;
      const typeParams = struct.typeParams.map(_TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/bcs/bcs.js
function unsafe_u64(options) {
  return bcs.u64(__spreadValues({
    name: "unsafe_u64"
  }, options)).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum(type) {
  return bcs.enum("Option", {
    None: null,
    Some: type
  });
}
var Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({
  validate: (val) => {
    const address = typeof val === "string" ? val : toHex(val);
    if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {
      throw new Error(`Invalid Sui address ${address}`);
    }
  },
  input: (val) => typeof val === "string" ? fromHex(normalizeSuiAddress(val)) : val,
  output: (val) => normalizeSuiAddress(toHex(val))
});
var ObjectDigest = bcs.vector(bcs.u8()).transform({
  name: "ObjectDigest",
  input: (value) => fromBase58(value),
  output: (value) => toBase58(new Uint8Array(value)),
  validate: (value) => {
    if (fromBase58(value).length !== 32) {
      throw new Error("ObjectDigest must be 32 bytes");
    }
  }
});
var SuiObjectRef = bcs.struct("SuiObjectRef", {
  objectId: Address,
  version: bcs.u64(),
  digest: ObjectDigest
});
var SharedObjectRef = bcs.struct("SharedObjectRef", {
  objectId: Address,
  initialSharedVersion: bcs.u64(),
  mutable: bcs.bool()
});
var ObjectArg = bcs.enum("ObjectArg", {
  ImmOrOwnedObject: SuiObjectRef,
  SharedObject: SharedObjectRef,
  Receiving: SuiObjectRef
});
var CallArg = bcs.enum("CallArg", {
  Pure: bcs.struct("Pure", {
    bytes: bcs.vector(bcs.u8()).transform({
      input: (val) => typeof val === "string" ? fromBase64(val) : val,
      output: (val) => toBase64(new Uint8Array(val))
    })
  }),
  Object: ObjectArg
});
var InnerTypeTag = bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs.lazy(() => InnerTypeTag),
  struct: bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
var TypeTag = InnerTypeTag.transform({
  input: (typeTag) => typeof typeTag === "string" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,
  output: (typeTag) => TypeTagSerializer.tagToString(typeTag)
});
var Argument = bcs.enum("Argument", {
  GasCoin: null,
  Input: bcs.u16(),
  Result: bcs.u16(),
  NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])
});
var ProgrammableMoveCall = bcs.struct("ProgrammableMoveCall", {
  package: Address,
  module: bcs.string(),
  function: bcs.string(),
  typeArguments: bcs.vector(TypeTag),
  arguments: bcs.vector(Argument)
});
var Command = bcs.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: ProgrammableMoveCall,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: bcs.struct("TransferObjects", {
    objects: bcs.vector(Argument),
    address: Argument
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: bcs.struct("SplitCoins", {
    coin: Argument,
    amounts: bcs.vector(Argument)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: bcs.struct("MergeCoins", {
    destination: Argument,
    sources: bcs.vector(Argument)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: bcs.struct("Publish", {
    modules: bcs.vector(
      bcs.vector(bcs.u8()).transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: bcs.struct("MakeMoveVec", {
    type: optionEnum(TypeTag).transform({
      input: (val) => val === null ? {
        None: true
      } : {
        Some: val
      },
      output: (val) => {
        var _a7;
        return (_a7 = val.Some) != null ? _a7 : null;
      }
    }),
    elements: bcs.vector(Argument)
  }),
  Upgrade: bcs.struct("Upgrade", {
    modules: bcs.vector(
      bcs.vector(bcs.u8()).transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address),
    package: Address,
    ticket: Argument
  })
});
var ProgrammableTransaction = bcs.struct("ProgrammableTransaction", {
  inputs: bcs.vector(CallArg),
  commands: bcs.vector(Command)
});
var TransactionKind = bcs.enum("TransactionKind", {
  ProgrammableTransaction,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var TransactionExpiration = bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u64()
});
var StructTag = bcs.struct("StructTag", {
  address: Address,
  module: bcs.string(),
  name: bcs.string(),
  typeParams: bcs.vector(InnerTypeTag)
});
var GasData = bcs.struct("GasData", {
  payment: bcs.vector(SuiObjectRef),
  owner: Address,
  price: bcs.u64(),
  budget: bcs.u64()
});
var TransactionDataV1 = bcs.struct("TransactionDataV1", {
  kind: TransactionKind,
  sender: Address,
  gasData: GasData,
  expiration: TransactionExpiration
});
var TransactionData = bcs.enum("TransactionData", {
  V1: TransactionDataV1
});
var IntentScope = bcs.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
});
var IntentVersion = bcs.enum("IntentVersion", {
  V0: null
});
var AppId = bcs.enum("AppId", {
  Sui: null
});
var Intent = bcs.struct("Intent", {
  scope: IntentScope,
  version: IntentVersion,
  appId: AppId
});
function IntentMessage(T2) {
  return bcs.struct(`IntentMessage<${T2.name}>`, {
    intent: Intent,
    value: T2
  });
}
var CompressedSignature = bcs.enum("CompressedSignature", {
  ED25519: bcs.fixedArray(64, bcs.u8()),
  Secp256k1: bcs.fixedArray(64, bcs.u8()),
  Secp256r1: bcs.fixedArray(64, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var PublicKey = bcs.enum("PublicKey", {
  ED25519: bcs.fixedArray(32, bcs.u8()),
  Secp256k1: bcs.fixedArray(33, bcs.u8()),
  Secp256r1: bcs.fixedArray(33, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var MultiSigPkMap = bcs.struct("MultiSigPkMap", {
  pubKey: PublicKey,
  weight: bcs.u8()
});
var MultiSigPublicKey = bcs.struct("MultiSigPublicKey", {
  pk_map: bcs.vector(MultiSigPkMap),
  threshold: bcs.u16()
});
var MultiSig = bcs.struct("MultiSig", {
  sigs: bcs.vector(CompressedSignature),
  bitmap: bcs.u16(),
  multisig_pk: MultiSigPublicKey
});
var base64String = bcs.vector(bcs.u8()).transform({
  input: (val) => typeof val === "string" ? fromBase64(val) : val,
  output: (val) => toBase64(new Uint8Array(val))
});
var SenderSignedTransaction = bcs.struct("SenderSignedTransaction", {
  intentMessage: IntentMessage(TransactionData),
  txSignatures: bcs.vector(base64String)
});
var SenderSignedData = bcs.vector(SenderSignedTransaction, {
  name: "SenderSignedData"
});
var PasskeyAuthenticator = bcs.struct("PasskeyAuthenticator", {
  authenticatorData: bcs.vector(bcs.u8()),
  clientDataJson: bcs.string(),
  userSignature: bcs.vector(bcs.u8())
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/bcs/effects.js
var PackageUpgradeError = bcs.enum("PackageUpgradeError", {
  UnableToFetchPackage: bcs.struct("UnableToFetchPackage", { packageId: Address }),
  NotAPackage: bcs.struct("NotAPackage", { objectId: Address }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: bcs.struct("DigestDoesNotMatch", { digest: bcs.vector(bcs.u8()) }),
  UnknownUpgradePolicy: bcs.struct("UnknownUpgradePolicy", { policy: bcs.u8() }),
  PackageIDDoesNotMatch: bcs.struct("PackageIDDoesNotMatch", {
    packageId: Address,
    ticketId: Address
  })
});
var ModuleId = bcs.struct("ModuleId", {
  address: Address,
  name: bcs.string()
});
var MoveLocation = bcs.struct("MoveLocation", {
  module: ModuleId,
  function: bcs.u16(),
  instruction: bcs.u16(),
  functionName: bcs.option(bcs.string())
});
var CommandArgumentError = bcs.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: bcs.struct("IndexOutOfBounds", { idx: bcs.u16() }),
  SecondaryIndexOutOfBounds: bcs.struct("SecondaryIndexOutOfBounds", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidResultArity: bcs.struct("InvalidResultArity", { resultIdx: bcs.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
});
var TypeArgumentError = bcs.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
});
var ExecutionFailureStatus = bcs.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: bcs.struct("MoveObjectTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  MovePackageTooBig: bcs.struct("MovePackageTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  CircularObjectOwnership: bcs.struct("CircularObjectOwnership", { object: Address }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: bcs.option(MoveLocation),
  MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: bcs.struct("CommandArgumentError", {
    argIdx: bcs.u16(),
    kind: CommandArgumentError
  }),
  TypeArgumentError: bcs.struct("TypeArgumentError", {
    argumentIdx: bcs.u16(),
    kind: TypeArgumentError
  }),
  UnusedValueWithoutDrop: bcs.struct("UnusedValueWithoutDrop", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidPublicFunctionReturnType: bcs.struct("InvalidPublicFunctionReturnType", {
    idx: bcs.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: bcs.struct("EffectsTooLarge", { currentSize: bcs.u64(), maxSize: bcs.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: bcs.struct("PackageUpgradeError", { upgradeError: PackageUpgradeError }),
  WrittenObjectsTooLarge: bcs.struct("WrittenObjectsTooLarge", {
    currentSize: bcs.u64(),
    maxSize: bcs.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null,
  ExecutionCancelledDueToSharedObjectCongestion: bcs.struct(
    "ExecutionCancelledDueToSharedObjectCongestion",
    {
      congestedObjects: bcs.vector(Address)
    }
  ),
  AddressDeniedForCoin: bcs.struct("AddressDeniedForCoin", {
    address: Address,
    coinType: bcs.string()
  }),
  CoinTypeGlobalPause: bcs.struct("CoinTypeGlobalPause", { coinType: bcs.string() }),
  ExecutionCancelledDueToRandomnessUnavailable: null
});
var ExecutionStatus = bcs.enum("ExecutionStatus", {
  Success: null,
  Failed: bcs.struct("ExecutionFailed", {
    error: ExecutionFailureStatus,
    command: bcs.option(bcs.u64())
  })
});
var GasCostSummary = bcs.struct("GasCostSummary", {
  computationCost: bcs.u64(),
  storageCost: bcs.u64(),
  storageRebate: bcs.u64(),
  nonRefundableStorageFee: bcs.u64()
});
var Owner = bcs.enum("Owner", {
  AddressOwner: Address,
  ObjectOwner: Address,
  Shared: bcs.struct("Shared", {
    initialSharedVersion: bcs.u64()
  }),
  Immutable: null
});
var TransactionEffectsV1 = bcs.struct("TransactionEffectsV1", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  modifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),
  sharedObjects: bcs.vector(SuiObjectRef),
  transactionDigest: ObjectDigest,
  created: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  mutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  unwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  deleted: bcs.vector(SuiObjectRef),
  unwrappedThenDeleted: bcs.vector(SuiObjectRef),
  wrapped: bcs.vector(SuiObjectRef),
  gasObject: bcs.tuple([SuiObjectRef, Owner]),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest)
});
var VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);
var ObjectIn = bcs.enum("ObjectIn", {
  NotExist: null,
  Exist: bcs.tuple([VersionDigest, Owner])
});
var ObjectOut = bcs.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: bcs.tuple([ObjectDigest, Owner]),
  PackageWrite: VersionDigest
});
var IDOperation = bcs.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
});
var EffectsObjectChange = bcs.struct("EffectsObjectChange", {
  inputState: ObjectIn,
  outputState: ObjectOut,
  idOperation: IDOperation
});
var UnchangedSharedKind = bcs.enum("UnchangedSharedKind", {
  ReadOnlyRoot: VersionDigest,
  MutateDeleted: bcs.u64(),
  ReadDeleted: bcs.u64(),
  Cancelled: bcs.u64(),
  PerEpochConfig: null
});
var TransactionEffectsV2 = bcs.struct("TransactionEffectsV2", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  transactionDigest: ObjectDigest,
  gasObjectIndex: bcs.option(bcs.u32()),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest),
  lamportVersion: bcs.u64(),
  changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),
  unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),
  auxDataDigest: bcs.option(ObjectDigest)
});
var TransactionEffects = bcs.enum("TransactionEffects", {
  V1: TransactionEffectsV1,
  V2: TransactionEffectsV2
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/bcs/index.js
var suiBcs = __spreadProps(__spreadValues({}, bcs), {
  U8: bcs.u8(),
  U16: bcs.u16(),
  U32: bcs.u32(),
  U64: bcs.u64(),
  U128: bcs.u128(),
  U256: bcs.u256(),
  ULEB128: bcs.uleb128(),
  Bool: bcs.bool(),
  String: bcs.string(),
  Address,
  AppId,
  Argument,
  CallArg,
  CompressedSignature,
  GasData,
  Intent,
  IntentMessage,
  IntentScope,
  IntentVersion,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SenderSignedTransaction,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  Command,
  TransactionData,
  TransactionDataV1,
  TransactionExpiration,
  TransactionKind,
  TypeTag,
  TransactionEffects,
  PasskeyAuthenticator
});

// src/hooks/types.ts
var ContractError = class extends Error {
  constructor(message, debugInfo) {
    super(message);
    this.debugInfo = debugInfo;
  }
};

// src/lib/constants.ts
var SCALLOP = {
  MARKET_OBJECT: "0xa757975255146dc9686aa823b7838b507f315d704f428cbadad2f4ea061939d9",
  VERSION_OBJECT: "0x07871c4b3c847a0f674510d4978d5cf6f960452795e8ff6f189fd2088a3f6ac7",
  S_COIN: [
    {
      coinType: "0xaafc4f740de0dd0dde642a31148fb94517087052f19afb0f7bed1dc41a50c77b::scallop_sui::SCALLOP_SUI",
      treasury: "0x5c1678c8261ac9eec024d4d630006a9f55c80dc0b1aa38a003fcb1d425818c6b"
    },
    {
      coinType: "0xea346ce428f91ab007210443efcea5f5cdbbb3aae7e9affc0ca93f9203c31f0c::scallop_cetus::SCALLOP_CETUS",
      treasury: "0xa283c63488773c916cb3d6c64109536160d5eb496caddc721eb39aad2977d735"
    },
    {
      coinType: "0x5ca17430c1d046fae9edeaa8fd76c7b4193a00d764a0ecfa9418d733ad27bc1e::scallop_sca::SCALLOP_SCA",
      treasury: "0xe04bfc95e00252bd654ee13c08edef9ac5e4b6ae4074e8390db39e9a0109c529"
    },
    {
      coinType: "0xad4d71551d31092230db1fd482008ea42867dbf27b286e9c70a79d2a6191d58d::scallop_wormhole_usdc::SCALLOP_WORMHOLE_USDC",
      treasury: "0x50c5cfcbcca3aaacab0984e4d7ad9a6ad034265bebb440f0d1cd688ec20b2548"
    },
    {
      coinType: "0xe6e5a012ec20a49a3d1d57bd2b67140b96cd4d3400b9d79e541f7bdbab661f95::scallop_wormhole_usdt::SCALLOP_WORMHOLE_USDT",
      treasury: "0x1f02e2fed702b477732d4ad6044aaed04f2e8e586a169153694861a901379df0"
    },
    {
      coinType: "0x67540ceb850d418679e69f1fb6b2093d6df78a2a699ffc733f7646096d552e9b::scallop_wormhole_eth::SCALLOP_WORMHOLE_ETH",
      treasury: "0x4b7f5da0e306c9d52490a0c1d4091e653d6b89778b9b4f23c877e534e4d9cd21"
    },
    {
      coinType: "0x00671b1fa2a124f5be8bdae8b91ee711462c5d9e31bda232e70fd9607b523c88::scallop_af_sui::SCALLOP_AF_SUI",
      treasury: "0x55f4dfe9e40bc4cc11c70fcb1f3daefa2bdc330567c58d4f0792fbd9f9175a62"
    },
    {
      coinType: "0x9a2376943f7d22f88087c259c5889925f332ca4347e669dc37d54c2bf651af3c::scallop_ha_sui::SCALLOP_HA_SUI",
      treasury: "0x404ccc1404d74a90eb6f9c9d4b6cda6d417fb03189f80d9070a35e5dab1df0f5"
    },
    {
      coinType: "0xe1a1cc6bcf0001a015eab84bcc6713393ce20535f55b8b6f35c142e057a25fbe::scallop_v_sui::SCALLOP_V_SUI",
      treasury: "0xc06688ee1af25abc286ffb1d18ce273d1d5907cd1064c25f4e8ca61ea989c1d1"
    },
    {
      coinType: "0x1392650f2eca9e3f6ffae3ff89e42a3590d7102b80e2b430f674730bc30d3259::scallop_wormhole_sol::SCALLOP_WORMHOLE_SOL",
      treasury: "0x760fd66f5be869af4382fa32b812b3c67f0eca1bb1ed7a5578b21d56e1848819"
    },
    {
      coinType: "0x2cf76a9cf5d3337961d1154283234f94da2dcff18544dfe5cbdef65f319591b5::scallop_wormhole_btc::SCALLOP_WORMHOLE_BTC",
      treasury: "0xe2883934ea42c99bc998bbe0f01dd6d27aa0e27a56455707b1b34e6a41c20baa"
    },
    {
      coinType: "0x854950aa624b1df59fe64e630b2ba7c550642e9342267a33061d59fb31582da5::scallop_usdc::SCALLOP_USDC",
      treasury: "0xbe6b63021f3d82e0e7e977cdd718ed7c019cf2eba374b7b546220402452f938e"
    },
    {
      coinType: "0xb14f82d8506d139eacef109688d1b71e7236bcce9b2c0ad526abcd6aa5be7de0::scallop_sb_eth::SCALLOP_SB_ETH",
      treasury: "0xfd0f02def6358a1f266acfa1493d4707ee8387460d434fb667d63d755ff907ed"
    },
    {
      coinType: "0x6711551c1e7652a270d9fbf0eee25d99594c157cde3cb5fbb49035eb59b1b001::scallop_fdusd::SCALLOP_FDUSD",
      treasury: "0xdad9bc6293e694f67a5274ea51b596e0bdabfafc585ae6d7e82888e65f1a03e0"
    },
    {
      coinType: "0xeb7a05a3224837c5e5503575aed0be73c091d1ce5e43aa3c3e716e0ae614608f::scallop_deep::SCALLOP_DEEP",
      treasury: "0xc63838fabe37b25ad897392d89876d920f5e0c6a406bf3abcb84753d2829bc88"
    },
    {
      coinType: "0xe56d5167f427cbe597da9e8150ef5c337839aaf46891d62468dcf80bdd8e10d1::scallop_fud::SCALLOP_FUD",
      treasury: "0xf25212f11d182decff7a86165699a73e3d5787aced203ca539f43cfbc10db867"
    },
    {
      coinType: "0xb1d7df34829d1513b73ba17cb7ad90c88d1e104bb65ab8f62f13e0cc103783d3::scallop_sb_usdt::SCALLOP_SB_USDT",
      treasury: "0x58bdf6a9752e3a60144d0b70e8608d630dfd971513e2b2bfa7282f5eaa7d04d8"
    },
    {
      coinType: "0xd285cbbf54c87fd93cd15227547467bb3e405da8bbf2ab99f83f323f88ac9a65::scallop_usdy::SCALLOP_USDY",
      treasury: "0xc8c5339fb10d9ad96f235fb312bda54df351549a3302e7fa7fd5d1725481604f"
    },
    {
      coinType: "0x6711551c1e7652a270d9fbf0eee25d99594c157cde3cb5fbb49035eb59b1b001::scallop_fdusd::SCALLOP_FDUSD",
      treasury: "0xdad9bc6293e694f67a5274ea51b596e0bdabfafc585ae6d7e82888e65f1a03e0"
    },
    {
      coinType: "0x0a228d1c59071eccf3716076a1f71216846ee256d9fb07ea11fb7c1eb56435a5::scallop_musd::SCALLOP_MUSD",
      treasury: "0xadfd554635ccc87e992f23ca838f0f16c14874e324a1b79b77f6bfe118edea9f"
    },
    {
      coinType: "0x9a2376943f7d22f88087c259c5889925f332ca4347e669dc37d54c2bf651af3c::scallop_ha_sui::SCALLOP_HA_SUI",
      treasury: "0x404ccc1404d74a90eb6f9c9d4b6cda6d417fb03189f80d9070a35e5dab1df0f5"
    },
    {
      coinType: "0x00671b1fa2a124f5be8bdae8b91ee711462c5d9e31bda232e70fd9607b523c88::scallop_af_sui::SCALLOP_AF_SUI",
      treasury: "0x55f4dfe9e40bc4cc11c70fcb1f3daefa2bdc330567c58d4f0792fbd9f9175a62"
    },
    {
      coinType: "0xe1a1cc6bcf0001a015eab84bcc6713393ce20535f55b8b6f35c142e057a25fbe::scallop_v_sui::SCALLOP_V_SUI",
      treasury: "0xc06688ee1af25abc286ffb1d18ce273d1d5907cd1064c25f4e8ca61ea989c1d1"
    },
    {
      coinType: "0x622345b3f80ea5947567760eec7b9639d0582adcfd6ab9fccb85437aeda7c0d0::scallop_wal::SCALLOP_WAL",
      treasury: "0xc02b365a1d880156c1a757d7777867e8a436ab97ce5f51e211695580ab7c9bce"
    },
    {
      coinType: "0x0425be5f46f5639ab7201dfde3b2ed837fc129c434f55677c9ba11b528a3214a::scallop_haedal::SCALLOP_HAEDAL",
      treasury: "0x4ae9417c4c2ae8e629e72d06682f248c90c61233d43eb0a5654de768d63be26d"
    }
  ]
};
var VALIDATORS = {
  MYSTEN_2: "0xcb7efe4253a0fe58df608d8a2d3c0eea94b4b40a8738c8daae4eb77830c16cd7",
  MYSTEN_1: "0x4fffd0005522be4bc029724c7f0f6ed7093a6bf3a09b90e62f61dc15181e1a3e"
};
var AFTERMATH = {
  STAKED_SUI_VAULT: "0x2f8f6d5da7f13ea37daa397724280483ed062769813b6f31e9788e59cc88994d",
  SAFE: "0xeb685899830dd5837b47007809c76d91a098d52aabbf61e8ac467c59e5cc4610",
  REFERRAL_VAULT: "0x4ce9a19b594599536c53edb25d22532f82f18038dc8ef618afd00fbbfb9845ef",
  SYSTEM_STATE: "0x5",
  CLOCK: "0x6",
  TREASURY: "0xd2b95022244757b0ab9f74e2ee2fb2c3bf29dce5590fa6993a85d64bd219d7e8",
  VALIDATOR_CONFIGS_TABLE: "0x8536350cfb8a8efdd133a1e087b55416d431f7e8b894f77b55b20c4b799ebad9"
};
function getTreasury(coinType) {
  var _a7;
  const treasury = (_a7 = SCALLOP.S_COIN.find(
    (item) => item.coinType === coinType
  )) == null ? void 0 : _a7.treasury;
  if (!treasury) {
    throw new Error("Scallop scoin treasury not found");
  }
  return treasury;
}
var DEFAULT_Address = "0x0000000000000000000000000000000000000000000000000000000000000001";
var SSBUCK = {
  VAULT: "0xe83e455a9e99884c086c8c79c13367e7a865de1f953e75bcf3e529cdf03c6224"
};
var Time = {
  CONVERSION_RATE_REFRESH_INTERVAL: 1e3 * 20
};
var ALPAHFI = {
  PACKAGE_ID: "0x059f94b85c07eb74d2847f8255d8cc0a67c9a8dcc039eabf9f8b9e23a0de2700",
  LIQUID_STAKING_INFO: "0x1adb343ab351458e151bc392fbf1558b3332467f23bda45ae67cd355a57fd5f5"
};
var SPRING_SUI_STAKING_INFO_LIST = [
  {
    coinType: "0x83556891f4a0f233ce7b05cfe7f957d4020492a34f5405b2cb9377d060bef4bf::spring_sui::SPRING_SUI",
    value: "0x15eda7330c8f99c30e430b4d82fd7ab2af3ead4ae17046fcb224aa9bad394f6b"
  },
  {
    coinType: "0xe68fad47384e18cd79040cb8d72b7f64d267eebb73a0b8d54711aa860570f404::upsui::UPSUI",
    value: "0x0ee341383a760c3af14337f134d96a5502073b897f551895e92f74aa07de0905"
  },
  {
    coinType: "0xc5c4bc11427315926cf0cc284504d8e5693a10da75500a5198bdee23f47f4254::lofi_sui::LOFI_SUI",
    value: "0xeb784ecfc02515248b71f45b069310592e07f934107a0377cc5919200288e513"
  },
  {
    coinType: "0x285b49635f4ed253967a2a4a5f0c5aea2cbd9dd0fc427b4086f3fad7ccef2c29::i_sui::I_SUI",
    value: "0x4c19387aae1ce9baec9f53d7e7a1dcae348a2fd5614785a7047b0b8cbc5494d7"
  },
  {
    coinType: "0x83f1bb8c91ecd1fd313344058b0eed94d63c54e41d8d1ae5bff1353443517d65::yap_sui::YAP_SUI",
    value: "0x55f3108cf195481de42d6c44469d0c870c08f3e8ea00c59452ad46445da88fcf"
  },
  {
    coinType: "0x41ff228bfd566f0c707173ee6413962a77e3929588d010250e4e76f0d1cc0ad4::ksui::KSUI",
    value: "0x03583e2c4d5a66299369214012564d72c4a141afeefce50c349cd56b5f8a6955"
  },
  {
    coinType: "0x0f26f0dced338b538e027fca6ac24019791a7578e7eb2e81840e268970fbfbd6::para_sui::PARA_SUI",
    value: "0x8f50587e228c3d4217293ea85406827d6755f598613a0697b2cb19dac297e993"
  },
  {
    coinType: "0x02358129a7d66f943786a10b518fdc79145f1fc8d23420d9948c4aeea190f603::fud_sui::FUD_SUI",
    value: "0x7b4406fd4de96e08711729516f826e36f3268c2fefe6de985abc41192b02b871"
  },
  {
    coinType: "0x502867b177303bf1bf226245fcdd3403c177e78d175a55a56c0602c7ff51c7fa::trevin_sui::TREVIN_SUI",
    value: "0x1ec3b836fe8095152741ae5425ca4c35606ba5622c76291962d8fd9daba961db"
  },
  {
    coinType: "0x922d15d7f55c13fd790f6e54397470ec592caa2b508df292a2e8553f3d3b274f::msui::MSUI",
    value: "0x985dd33bc2a8b5390f2c30a18d32e9a63a993a5b52750c6fe2e6ac8baeb69f48"
  }
];
var HAEDAL = {
  HAEDAL_STAKING_ID: "0x47b224762220393057ebf4f70501b6e657c3e56684737568439a04f80849b2ca"
};
var NEED_MIN_VALUE_LIST = [
  {
    provider: "Winter",
    minValue: 1
  },
  {
    provider: "SpringSui",
    minValue: 1
  },
  {
    provider: "Cetus",
    minValue: 3
  },
  {
    coinType: "0xf325ce1300e8dac124071d3152c5c5ee6174914f8bc2161e88329cf579246efc::afsui::AFSUI",
    minValue: 1
  },
  {
    coinType: "0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55::cert::CERT",
    minValue: 1
  },
  {
    coinType: "0xbde4ba4c2e274a60ce15c1cfff9e5c42e41654ac8b6d906a57efa4bd3c29f47d::hasui::HASUI",
    minValue: 1
  },
  {
    coinType: "0x8b4d553839b219c3fd47608a0cc3d5fcc572cb25d41b7df3833208586a8d2470::hawal::HAWAL",
    minValue: 1
  }
];
var VOLO = {
  NATIVE_POOL: "0x7fa2faa111b8c65bea48a23049bfd81ca8f971a262d981dcd9a17c3825cb5baf",
  METADATA: "0x680cd26af32b2bde8d3361e804c53ec1d1cfe24c7f039eb7f549e8dfde389a60"
};
var WINTER = {
  WALRUS_STAKING: "0x10b9d30c28448939ce6c4d6c6e0ffce4a7f8a4ada8248bdad09ef8b70e4a3904"
};
var Winter_Blizzard_Staking_List = [
  {
    coinType: "0xb1b0650a8862e30e3f604fd6c5838bc25464b8d3d827fbd58af7cb9685b832bf::wwal::WWAL",
    value: "0xccf034524a2bdc65295e212128f77428bb6860d757250c43323aa38b3d04df6d"
  },
  {
    coinType: "0xd8b855d48fb4d8ffbb5c4a3ecac27b00f3712ce58626deb5a16a290e0c6edf84::nwal::NWAL",
    value: "0x75c4a3d4f78aa3157e2ab6e8dfb2230432272c23ab9392b10a2212e4b2fcc9f9"
  },
  {
    coinType: "0x0f03158a2caec1b656ee929007d08e58d620eeabeacac90ea7657d8b386b00b9::pwal::PWAL",
    value: "0xd355b8e62f16418a02879de9bc4ab15c4dad9dd2966d15645e1674689bfbc8b9"
  },
  {
    coinType: "0x5f70820b716a1d83580e5cf36dd0d0915b8763e1b85e3ef3db821ff40846be44::bread_wal::BREAD_WAL",
    value: "0xc75f916f5cdc94664f58f5e8284a70ef69f973d62cd9841584bc70200a98a8b7"
  },
  {
    coinType: "0xa8ad8c2720f064676856f4999894974a129e3d15386b3d0a27f3a7f85811c64a::tr_wal::TR_WAL",
    value: "0x76d5f7309ac302c10aa91d72ab7d48252a840816c39764293e986ce90c3c4a0d"
  },
  {
    coinType: "0x615b29e7cf458a4e29363a966a01d6a6bf5026349bb4e957daa61ca9ffff639d::up_wal::UP_WAL",
    value: "0xa3d69fdb63cbeaec068e8739fe7bda05a184f82999d1e76f0c0f5e9a29e297ed"
  },
  {
    coinType: "0x64e081287af3fb4eb5720137348661493203d48535f582577177fcd3b253805f::mwal::MWAL",
    value: "0x1c98a3851302351913b34491a07930e83b1bd502cf1c6e9428b1c5d690d1e074"
  }
];
var SUPER_SUI = {
  REGISTRY: "0x5ff2396592a20f7bf6ff291963948d6fc2abec279e11f50ee74d193c4cf0bba8",
  VAULT: "0x3062285974a5e517c88cf3395923aac788dce74f3640029a01e25d76c4e76f5d"
};
var WWAL = {
  PACKAGE_ID: "0x0c2e5a60b4c6e2eda7a5add1f9340160bfcc0559749af239622e8d107d51b431",
  TREASURY_CAP: "0x6d7da14a09687a3ed3e97deb3bc2428ab7f2db39f4e706dd7344760b5ae43729",
  WALRUS_STAKING: "0x10b9d30c28448939ce6c4d6c6e0ffce4a7f8a4ada8248bdad09ef8b70e4a3904"
};
var UNSUPPORTED_UNDERLYING_COINS = [];
var CETUS_VAULT_ID_LIST = [
  {
    coinType: "0x828b452d2aa239d48e4120c24f4a59f451b8cd8ac76706129f4ac3bd78ac8809::lp_token::LP_TOKEN",
    vaultId: "0xde97452e63505df696440f86f0b805263d8659b77b8c316739106009d514c270"
  },
  {
    coinType: "0x0c8a5fcbe32b9fc88fe1d758d33dd32586143998f68656f43f3a6ced95ea4dc3::lp_token::LP_TOKEN",
    vaultId: "0xff4cc0af0ad9d50d4a3264dfaafd534437d8b66c8ebe9f92b4c39d898d6870a3"
  },
  {
    coinType: "0xb490d6fa9ead588a9d72da07a02914da42f6b5b1339b8118a90011a42b67a44f::lp_token::LP_TOKEN",
    vaultId: "0x5732b81e659bd2db47a5b55755743dde15be99490a39717abc80d62ec812bcb6"
  }
];

// src/lib/txHelper/price.ts
var getPriceVoucher = (tx, coinConfig, returnDebugInfo = true) => {
  var _a7, _b3;
  let moveCall;
  if (coinConfig.provider === "SpringSui") {
    const lstInfo = (_a7 = SPRING_SUI_STAKING_INFO_LIST.find(
      (item) => item.coinType === coinConfig.coinType
    )) == null ? void 0 : _a7.value;
    if (!lstInfo) {
      throw new Error(`SpringSui: lstInfo not found for ${coinConfig.coinType}`);
    }
    moveCall = {
      target: `${coinConfig.oraclePackageId}::spring::get_price_voucher_from_spring`,
      arguments: [
        {
          name: "price_oracle_config",
          value: coinConfig.priceOracleConfigId
        },
        {
          name: "price_ticket_cap",
          value: coinConfig.oracleTicket
        },
        { name: "lst_info", value: lstInfo },
        { name: "sy_state", value: coinConfig.syStateId }
      ],
      typeArguments: [coinConfig.syCoinType, coinConfig.coinType]
    };
    const [priceVoucher] = tx.moveCall({
      target: moveCall.target,
      arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
      typeArguments: moveCall.typeArguments
    });
    return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
  } else if (coinConfig.provider === "Winter") {
    const blizzardStaking = (_b3 = Winter_Blizzard_Staking_List.find(
      (item) => item.coinType === coinConfig.coinType
    )) == null ? void 0 : _b3.value;
    if (!blizzardStaking) {
      throw new Error("Winter blizzard staking not found");
    }
    moveCall = {
      target: `${coinConfig.oraclePackageId}::haedal::get_price_voucher_from_blizzard`,
      arguments: [
        {
          name: "price_oracle_config",
          value: coinConfig.priceOracleConfigId
        },
        {
          name: "price_ticket_cap",
          value: coinConfig.oracleTicket
        },
        {
          name: "blizzard_staking",
          value: blizzardStaking
        },
        {
          name: "walrus_staking",
          value: WWAL.WALRUS_STAKING
        },
        { name: "sy_state", value: coinConfig.syStateId }
      ],
      typeArguments: [coinConfig.syCoinType, coinConfig.coinType]
    };
    const [priceVoucher] = tx.moveCall({
      target: moveCall.target,
      arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
      typeArguments: moveCall.typeArguments
    });
    return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
  }
  switch (coinConfig.coinType) {
    case "0x8b4d553839b219c3fd47608a0cc3d5fcc572cb25d41b7df3833208586a8d2470::hawal::HAWAL": {
      moveCall = {
        target: `${coinConfig.oraclePackageId}::haedal::get_haWAL_price_voucher`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          {
            name: "staking",
            value: "0x9e5f6537be1a5b658ec7eed23160df0b28c799563f6c41e9becc9ad633cb592b"
          },
          { name: "sy_state", value: coinConfig.syStateId }
        ],
        typeArguments: [coinConfig.syCoinType, coinConfig.coinType]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
    case "0x828b452d2aa239d48e4120c24f4a59f451b8cd8ac76706129f4ac3bd78ac8809::lp_token::LP_TOKEN": {
      moveCall = {
        target: `${coinConfig.oraclePackageId}::haedal::get_price_voucher_from_cetus_vault`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          {
            name: "staking",
            value: HAEDAL.HAEDAL_STAKING_ID
          },
          {
            name: "vault",
            value: "0xde97452e63505df696440f86f0b805263d8659b77b8c316739106009d514c270"
          },
          {
            name: "pool",
            value: "0x871d8a227114f375170f149f7e9d45be822dd003eba225e83c05ac80828596bc"
          },
          { name: "sy_state", value: coinConfig.syStateId }
        ],
        typeArguments: [
          coinConfig.syCoinType,
          coinConfig.yieldTokenType,
          // Use underlyingCoinType as YieldToken
          coinConfig.coinType
        ]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
    case "0xd01d27939064d79e4ae1179cd11cfeeff23943f32b1a842ea1a1e15a0045d77d::st_sbuck::ST_SBUCK": {
      moveCall = {
        target: `${coinConfig.oraclePackageId}::buck::get_price_voucher_from_ssbuck`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          {
            name: "vault",
            value: SSBUCK.VAULT
          },
          { name: "clock", value: "0x6" }
        ],
        typeArguments: [coinConfig.syCoinType, coinConfig.coinType]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
    case "0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55::cert::CERT": {
      moveCall = {
        target: `${coinConfig.oraclePackageId}::volo::get_price_voucher_from_volo`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          { name: "native_pool", value: VOLO.NATIVE_POOL },
          { name: "metadata", value: VOLO.METADATA },
          { name: "sy_state", value: coinConfig.syStateId }
        ],
        typeArguments: [coinConfig.syCoinType]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
    case "0x790f258062909e3a0ffc78b3c53ac2f62d7084c3bab95644bdeb05add7250001::super_sui::SUPER_SUI": {
      moveCall = {
        target: `0x83949cdb90510f02ed3aee7a686cd0b1390de073afcadad9aa41d3016eb13463::aftermath::get_meta_coin_price_voucher`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          { name: "registry", value: SUPER_SUI.REGISTRY },
          { name: "vault", value: SUPER_SUI.VAULT },
          { name: "sy_state", value: coinConfig.syStateId }
        ],
        typeArguments: [coinConfig.syCoinType, coinConfig.coinType]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
    case "0xf325ce1300e8dac124071d3152c5c5ee6174914f8bc2161e88329cf579246efc::afsui::AFSUI": {
      moveCall = {
        target: `${coinConfig.oraclePackageId}::aftermath::get_price_voucher_from_aftermath`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          {
            name: "aftermath_staked_sui_vault",
            value: AFTERMATH.STAKED_SUI_VAULT
          },
          { name: "aftermath_safe", value: AFTERMATH.SAFE },
          { name: "sy_state", value: coinConfig.syStateId }
        ],
        typeArguments: [coinConfig.syCoinType, coinConfig.coinType]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
    case "0xbde4ba4c2e274a60ce15c1cfff9e5c42e41654ac8b6d906a57efa4bd3c29f47d::hasui::HASUI": {
      moveCall = {
        target: `${coinConfig.oraclePackageId}::haedal::get_price_voucher_from_haSui`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          { name: "haedal_staking", value: HAEDAL.HAEDAL_STAKING_ID },
          { name: "sy_state", value: coinConfig.syStateId }
        ],
        typeArguments: [coinConfig.syCoinType, coinConfig.coinType]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
    case "0xd1b72982e40348d069bb1ff701e634c117bb5f741f44dff91e472d3b01461e55::stsui::STSUI": {
      moveCall = {
        target: `${coinConfig.oraclePackageId}::alphafi::get_price_voucher_from_spring`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          {
            name: "lst_info",
            value: ALPAHFI.LIQUID_STAKING_INFO
          },
          { name: "sy_state", value: coinConfig.syStateId }
        ],
        typeArguments: [coinConfig.syCoinType, coinConfig.coinType]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
    case "0x0c8a5fcbe32b9fc88fe1d758d33dd32586143998f68656f43f3a6ced95ea4dc3::lp_token::LP_TOKEN": {
      moveCall = {
        target: `${coinConfig.oraclePackageId}::aftermath::get_price_voucher_from_cetus_vault`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          {
            name: "stake_vault",
            value: AFTERMATH.STAKED_SUI_VAULT
          },
          {
            name: "safe",
            value: AFTERMATH.SAFE
          },
          {
            name: "vault",
            value: "0xff4cc0af0ad9d50d4a3264dfaafd534437d8b66c8ebe9f92b4c39d898d6870a3"
          },
          {
            name: "pool",
            value: "0xa528b26eae41bcfca488a9feaa3dca614b2a1d9b9b5c78c256918ced051d4c50"
          },
          { name: "sy_state", value: coinConfig.syStateId }
        ],
        typeArguments: [
          coinConfig.syCoinType,
          coinConfig.yieldTokenType,
          coinConfig.coinType
        ]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
    case "0xb490d6fa9ead588a9d72da07a02914da42f6b5b1339b8118a90011a42b67a44f::lp_token::LP_TOKEN": {
      moveCall = {
        target: `${coinConfig.oraclePackageId}::volo::get_price_voucher_from_cetus_vault`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          {
            name: "native_pool",
            value: VOLO.NATIVE_POOL
          },
          {
            name: "metadata",
            value: VOLO.METADATA
          },
          {
            name: "vault",
            value: "0x5732b81e659bd2db47a5b55755743dde15be99490a39717abc80d62ec812bcb6"
          },
          {
            name: "pool",
            value: "0x6c545e78638c8c1db7a48b282bb8ca79da107993fcb185f75cedc1f5adb2f535"
          },
          { name: "sy_state", value: coinConfig.syStateId }
        ],
        typeArguments: [
          coinConfig.syCoinType,
          coinConfig.yieldTokenType,
          coinConfig.coinType
        ]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
    default: {
      moveCall = {
        target: `${coinConfig.oraclePackageId}::scallop::get_price_voucher_from_x_oracle`,
        arguments: [
          {
            name: "price_oracle_config",
            value: coinConfig.priceOracleConfigId
          },
          {
            name: "price_ticket_cap",
            value: coinConfig.oracleTicket
          },
          { name: "provider_version", value: coinConfig.providerVersion },
          { name: "provider_market", value: coinConfig.providerMarket },
          { name: "sy_state", value: coinConfig.syStateId },
          { name: "clock", value: "0x6" }
        ],
        typeArguments: [coinConfig.syCoinType, coinConfig.underlyingCoinType]
      };
      const [priceVoucher] = tx.moveCall({
        target: moveCall.target,
        arguments: moveCall.arguments.map((arg) => tx.object(arg.value)),
        typeArguments: moveCall.typeArguments
      });
      return returnDebugInfo ? [priceVoucher, moveCall] : priceVoucher;
    }
  }
};

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/utils/suins.js
var SUI_NS_NAME_REGEX = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
var SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
function normalizeSuiNSName(name, format = "at") {
  const lowerCase = name.toLowerCase();
  let parts;
  if (lowerCase.includes("@")) {
    if (!SUI_NS_NAME_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name}`);
    }
    const [labels, domain] = lowerCase.split("@");
    parts = [...labels ? labels.split(".") : [], domain];
  } else {
    if (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name}`);
    }
    parts = lowerCase.split(".").slice(0, -1);
  }
  if (format === "dot") {
    return `${parts.join(".")}.sui`;
  }
  return `${parts.slice(0, -1).join(".")}@${parts[parts.length - 1]}`;
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/utils/constants.js
var MIST_PER_SUI = BigInt(1e9);
var MOVE_STDLIB_ADDRESS = "0x1";
var SUI_FRAMEWORK_ADDRESS = "0x2";
var SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId("0x6");
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId("0x5");

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min3 = instance.outputLen;
  if (out.length < min3) {
    throw new Error("digestInto() expects output buffer of length at least " + min3);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
var swap8IfBE = isLE ? (n) => n : (n) => byteSwap(n);
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
  return arr;
}
var swap32IfBE = isLE ? (u) => u : byteSwap32;
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
var Hash = class {
};
function createOptHasher(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_blake.js
var BSIGMA = /* @__PURE__ */ Uint8Array.from([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le2 = false) {
  if (le2)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
function add2(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake2.js
var B2B_IV = /* @__PURE__ */ Uint32Array.from([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BBUF = /* @__PURE__ */ new Uint32Array(32);
function G1b(a, b2, c, d, msg, x2) {
  const Xl = msg[x2], Xh = msg[x2 + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b2], Bh = BBUF[2 * b2 + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = add2(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b2] = Bl, BBUF[2 * b2 + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function G2b(a, b2, c, d, msg, x2) {
  const Xl = msg[x2], Xh = msg[x2 + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b2], Bh = BBUF[2 * b2 + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = add2(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b2] = Bl, BBUF[2 * b2 + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
  anumber(keyLen);
  if (outputLen < 0 || outputLen > keyLen)
    throw new Error("outputLen bigger than keyLen");
  const { key, salt, personalization } = opts;
  if (key !== void 0 && (key.length < 1 || key.length > keyLen))
    throw new Error("key length must be undefined or 1.." + keyLen);
  if (salt !== void 0 && salt.length !== saltLen)
    throw new Error("salt must be undefined or " + saltLen);
  if (personalization !== void 0 && personalization.length !== persLen)
    throw new Error("personalization must be undefined or " + persLen);
}
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen) {
    super();
    this.finished = false;
    this.destroyed = false;
    this.length = 0;
    this.pos = 0;
    anumber(blockLen);
    anumber(outputLen);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.buffer = new Uint8Array(blockLen);
    this.buffer32 = u32(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { blockLen, buffer, buffer32 } = this;
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        swap32IfBE(buffer32);
        this.compress(buffer32, 0, false);
        swap32IfBE(buffer32);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        swap32IfBE(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        swap32IfBE(data32);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    clean(this.buffer.subarray(pos));
    swap32IfBE(buffer32);
    this.compress(buffer32, 0, true);
    swap32IfBE(buffer32);
    const out32 = u32(out);
    this.get().forEach((v, i) => out32[i] = swap8IfBE(v));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to || (to = new this.constructor({ dkLen: outputLen }));
    to.set(...this.get());
    to.buffer.set(buffer);
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    to.outputLen = outputLen;
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
    super(128, olen);
    this.v0l = B2B_IV[0] | 0;
    this.v0h = B2B_IV[1] | 0;
    this.v1l = B2B_IV[2] | 0;
    this.v1h = B2B_IV[3] | 0;
    this.v2l = B2B_IV[4] | 0;
    this.v2h = B2B_IV[5] | 0;
    this.v3l = B2B_IV[6] | 0;
    this.v3h = B2B_IV[7] | 0;
    this.v4l = B2B_IV[8] | 0;
    this.v4h = B2B_IV[9] | 0;
    this.v5l = B2B_IV[10] | 0;
    this.v5h = B2B_IV[11] | 0;
    this.v6l = B2B_IV[12] | 0;
    this.v6h = B2B_IV[13] | 0;
    this.v7l = B2B_IV[14] | 0;
    this.v7h = B2B_IV[15] | 0;
    checkBlake2Opts(olen, opts, 64, 16, 16);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes(key);
      keyLength = key.length;
    }
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes(salt);
      const slt = u32(salt);
      this.v4l ^= swap8IfBE(slt[0]);
      this.v4h ^= swap8IfBE(slt[1]);
      this.v5l ^= swap8IfBE(slt[2]);
      this.v5h ^= swap8IfBE(slt[3]);
    }
    if (personalization !== void 0) {
      personalization = toBytes(personalization);
      const pers = u32(personalization);
      this.v6l ^= swap8IfBE(pers[0]);
      this.v6h ^= swap8IfBE(pers[1]);
      this.v7l ^= swap8IfBE(pers[2]);
      this.v7h ^= swap8IfBE(pers[3]);
    }
    if (key !== void 0) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i) => BBUF[i] = v);
    BBUF.set(B2B_IV, 16);
    let { h, l } = fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l;
    BBUF[25] = B2B_IV[9] ^ h;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j2 = 0;
    const s = BSIGMA;
    for (let i = 0; i < 12; i++) {
      G1b(0, 4, 8, 12, msg, offset + 2 * s[j2++]);
      G2b(0, 4, 8, 12, msg, offset + 2 * s[j2++]);
      G1b(1, 5, 9, 13, msg, offset + 2 * s[j2++]);
      G2b(1, 5, 9, 13, msg, offset + 2 * s[j2++]);
      G1b(2, 6, 10, 14, msg, offset + 2 * s[j2++]);
      G2b(2, 6, 10, 14, msg, offset + 2 * s[j2++]);
      G1b(3, 7, 11, 15, msg, offset + 2 * s[j2++]);
      G2b(3, 7, 11, 15, msg, offset + 2 * s[j2++]);
      G1b(0, 5, 10, 15, msg, offset + 2 * s[j2++]);
      G2b(0, 5, 10, 15, msg, offset + 2 * s[j2++]);
      G1b(1, 6, 11, 12, msg, offset + 2 * s[j2++]);
      G2b(1, 6, 11, 12, msg, offset + 2 * s[j2++]);
      G1b(2, 7, 8, 13, msg, offset + 2 * s[j2++]);
      G2b(2, 7, 8, 13, msg, offset + 2 * s[j2++]);
      G1b(3, 4, 9, 14, msg, offset + 2 * s[j2++]);
      G2b(3, 4, 9, 14, msg, offset + 2 * s[j2++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    clean(BBUF);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = /* @__PURE__ */ createOptHasher((opts) => new BLAKE2b(opts));

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake2b.js
var blake2b2 = blake2b;

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/serializer.js
var OBJECT_MODULE_NAME = "object";
var ID_STRUCT_NAME = "ID";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
function isTxContext(param) {
  const struct = typeof param.body === "object" && "datatype" in param.body ? param.body.datatype : null;
  return !!struct && normalizeSuiAddress(struct.package) === normalizeSuiAddress("0x2") && struct.module === "tx_context" && struct.type === "TxContext";
}
function getPureBcsSchema(typeSignature) {
  if (typeof typeSignature === "string") {
    switch (typeSignature) {
      case "address":
        return suiBcs.Address;
      case "bool":
        return suiBcs.Bool;
      case "u8":
        return suiBcs.U8;
      case "u16":
        return suiBcs.U16;
      case "u32":
        return suiBcs.U32;
      case "u64":
        return suiBcs.U64;
      case "u128":
        return suiBcs.U128;
      case "u256":
        return suiBcs.U256;
      default:
        throw new Error(`Unknown type signature ${typeSignature}`);
    }
  }
  if ("vector" in typeSignature) {
    if (typeSignature.vector === "u8") {
      return suiBcs.vector(suiBcs.U8).transform({
        input: (val) => typeof val === "string" ? new TextEncoder().encode(val) : val,
        output: (val) => val
      });
    }
    const type = getPureBcsSchema(typeSignature.vector);
    return type ? suiBcs.vector(type) : null;
  }
  if ("datatype" in typeSignature) {
    const pkg = normalizeSuiAddress(typeSignature.datatype.package);
    if (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {
      if (typeSignature.datatype.module === STD_ASCII_MODULE_NAME && typeSignature.datatype.type === STD_ASCII_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_UTF8_MODULE_NAME && typeSignature.datatype.type === STD_UTF8_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_OPTION_MODULE_NAME && typeSignature.datatype.type === STD_OPTION_STRUCT_NAME) {
        const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);
        return type ? suiBcs.vector(type) : null;
      }
    }
    if (pkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) && typeSignature.datatype.module === OBJECT_MODULE_NAME && typeSignature.datatype.type === ID_STRUCT_NAME) {
      return suiBcs.Address;
    }
  }
  return null;
}
function normalizedTypeToMoveTypeSignature(type) {
  if (typeof type === "object" && "Reference" in type) {
    return {
      ref: "&",
      body: normalizedTypeToMoveTypeSignatureBody(type.Reference)
    };
  }
  if (typeof type === "object" && "MutableReference" in type) {
    return {
      ref: "&mut",
      body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference)
    };
  }
  return {
    ref: null,
    body: normalizedTypeToMoveTypeSignatureBody(type)
  };
}
function normalizedTypeToMoveTypeSignatureBody(type) {
  if (typeof type === "string") {
    switch (type) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${type}`);
    }
  }
  if ("Vector" in type) {
    return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };
  }
  if ("Struct" in type) {
    return {
      datatype: {
        package: type.Struct.address,
        module: type.Struct.module,
        type: type.Struct.name,
        typeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody)
      }
    };
  }
  if ("TypeParameter" in type) {
    return { typeParameter: type.TypeParameter };
  }
  throw new Error(`Unexpected type ${JSON.stringify(type)}`);
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/Inputs.js
function Pure(data) {
  return {
    $kind: "Pure",
    Pure: {
      bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64()
    }
  };
}
var Inputs = {
  Pure,
  ObjectRef({ objectId, digest, version }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "ImmOrOwnedObject",
        ImmOrOwnedObject: {
          digest,
          version,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  SharedObjectRef({
    objectId,
    mutable,
    initialSharedVersion
  }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "SharedObject",
        SharedObject: {
          mutable,
          initialSharedVersion,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  ReceivingRef({ objectId, digest, version }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "Receiving",
        Receiving: {
          digest,
          version,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  }
};

// ../../node_modules/.pnpm/valibot@0.36.0/node_modules/valibot/dist/index.js
var store;
function getGlobalConfig(config22) {
  var _a7, _b3, _c;
  return {
    lang: (_a7 = config22 == null ? void 0 : config22.lang) != null ? _a7 : store == null ? void 0 : store.lang,
    message: config22 == null ? void 0 : config22.message,
    abortEarly: (_b3 = config22 == null ? void 0 : config22.abortEarly) != null ? _b3 : store == null ? void 0 : store.abortEarly,
    abortPipeEarly: (_c = config22 == null ? void 0 : config22.abortPipeEarly) != null ? _c : store == null ? void 0 : store.abortPipeEarly
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2 == null ? void 0 : store2.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3 == null ? void 0 : store3.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  var _a7;
  return (_a7 = store4 == null ? void 0 : store4.get(reference)) == null ? void 0 : _a7.get(lang);
}
function _stringify(input) {
  var _a7, _b3, _c;
  const type = typeof input;
  if (type === "string") {
    return `"${input}"`;
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return `${input}`;
  }
  if (type === "object" || type === "function") {
    return (_c = input && ((_b3 = (_a7 = Object.getPrototypeOf(input)) == null ? void 0 : _a7.constructor) == null ? void 0 : _b3.name)) != null ? _c : "null";
  }
  return type;
}
function _addIssue(context, label, dataset, config22, other) {
  var _a7, _b3, _c, _d, _e3, _f, _g, _h;
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = (_b3 = (_a7 = other == null ? void 0 : other.expected) != null ? _a7 : context.expects) != null ? _b3 : null;
  const received = (_c = other == null ? void 0 : other.received) != null ? _c : _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    // @ts-expect-error
    requirement: context.requirement,
    path: other == null ? void 0 : other.path,
    issues: other == null ? void 0 : other.issues,
    lang: config22.lang,
    abortEarly: config22.abortEarly,
    abortPipeEarly: config22.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message = (_h = (_g = (_f = (_e3 = (_d = other == null ? void 0 : other.message) != null ? _d : (
    // @ts-expect-error
    context.message
  )) != null ? _e3 : getSpecificMessage(context.reference, issue.lang)) != null ? _f : isSchema ? getSchemaMessage(issue.lang) : null) != null ? _g : config22.message) != null ? _h : getGlobalMessage(issue.lang);
  if (message) {
    issue.message = typeof message === "function" ? message(issue) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
function _isValidObjectKey(object2, key) {
  return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    /**
     * The error issues.
     */
    __publicField(this, "issues");
    this.name = "ValiError";
    this.issues = issues;
  }
};
function check(requirement, message) {
  return {
    kind: "validation",
    type: "check",
    reference: check,
    async: false,
    expects: null,
    requirement,
    message,
    _run(dataset, config22) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "input", dataset, config22);
      }
      return dataset;
    }
  };
}
function integer(message) {
  return {
    kind: "validation",
    type: "integer",
    reference: integer,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message,
    _run(dataset, config22) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "integer", dataset, config22);
      }
      return dataset;
    }
  };
}
function transform(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transform,
    async: false,
    operation,
    _run(dataset) {
      dataset.value = this.operation(dataset.value);
      return dataset;
    }
  };
}
function getDefault(schema, dataset, config22) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config22)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function is(schema, input) {
  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;
}
function array(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message,
    _run(dataset, config22) {
      var _a7;
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < input.length; key++) {
          const value2 = input[key];
          const itemDataset = this.item._run({ typed: false, value: value2 }, config22);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              (_a7 = dataset.issues) == null ? void 0 : _a7.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config22.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config22);
      }
      return dataset;
    }
  };
}
function bigint(message) {
  return {
    kind: "schema",
    type: "bigint",
    reference: bigint,
    expects: "bigint",
    async: false,
    message,
    _run(dataset, config22) {
      if (typeof dataset.value === "bigint") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config22);
      }
      return dataset;
    }
  };
}
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message,
    _run(dataset, config22) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config22);
      }
      return dataset;
    }
  };
}
function lazy(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazy,
    expects: "unknown",
    async: false,
    getter,
    _run(dataset, config22) {
      return this.getter(dataset.value)._run(dataset, config22);
    }
  };
}
function literal(literal_, message) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(literal_),
    async: false,
    literal: literal_,
    message,
    _run(dataset, config22) {
      if (dataset.value === this.literal) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config22);
      }
      return dataset;
    }
  };
}
function nullable(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "nullable",
    reference: nullable,
    expects: `${wrapped.expects} | null`,
    async: false,
    wrapped,
    _run(dataset, config22) {
      if (dataset.value === null) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config22
          );
        }
        if (dataset.value === null) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config22);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function nullish(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `${wrapped.expects} | null | undefined`,
    async: false,
    wrapped,
    _run(dataset, config22) {
      if (dataset.value === null || dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config22
          );
        }
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config22);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function number(message) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message,
    _run(dataset, config22) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config22);
      }
      return dataset;
    }
  };
}
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries,
    message,
    _run(dataset, config22) {
      var _a7;
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const value2 = input[key];
          const valueDataset = this.entries[key]._run(
            { typed: false, value: value2 },
            config22
          );
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              (_a7 = dataset.issues) == null ? void 0 : _a7.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config22.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
      } else {
        _addIssue(this, "type", dataset, config22);
      }
      return dataset;
    }
  };
}
function optional(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${wrapped.expects} | undefined`,
    async: false,
    wrapped,
    _run(dataset, config22) {
      if (dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config22
          );
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config22);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function record(key, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: false,
    key,
    value: value2,
    message,
    _run(dataset, config22) {
      var _a7, _b3;
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const entryKey in input) {
          if (_isValidObjectKey(input, entryKey)) {
            const entryValue = input[entryKey];
            const keyDataset = this.key._run(
              { typed: false, value: entryKey },
              config22
            );
            if (keyDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "key",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of keyDataset.issues) {
                issue.path = [pathItem];
                (_a7 = dataset.issues) == null ? void 0 : _a7.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (config22.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            const valueDataset = this.value._run(
              { typed: false, value: entryValue },
              config22
            );
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_b3 = dataset.issues) == null ? void 0 : _b3.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config22.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!keyDataset.typed || !valueDataset.typed) {
              dataset.typed = false;
            }
            if (keyDataset.typed) {
              dataset.value[keyDataset.value] = valueDataset.value;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config22);
      }
      return dataset;
    }
  };
}
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message,
    _run(dataset, config22) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config22);
      }
      return dataset;
    }
  };
}
function tuple(items, message) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tuple,
    expects: "Array",
    async: false,
    items,
    message,
    _run(dataset, config22) {
      var _a7;
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < this.items.length; key++) {
          const value2 = input[key];
          const itemDataset = this.items[key]._run(
            { typed: false, value: value2 },
            config22
          );
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              (_a7 = dataset.issues) == null ? void 0 : _a7.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config22.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config22);
      }
      return dataset;
    }
  };
}
function _subIssues(datasets) {
  let issues;
  if (datasets) {
    for (const dataset of datasets) {
      if (issues) {
        issues.push(...dataset.issues);
      } else {
        issues = dataset.issues;
      }
    }
  }
  return issues;
}
function union(options, message) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: [...new Set(options.map((option) => option.expects))].join(" | ") || "never",
    async: false,
    options,
    message,
    _run(dataset, config22) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = schema._run(
          { typed: false, value: dataset.value },
          config22
        );
        if (optionDataset.typed) {
          if (optionDataset.issues) {
            if (typedDatasets) {
              typedDatasets.push(optionDataset);
            } else {
              typedDatasets = [optionDataset];
            }
          } else {
            validDataset = optionDataset;
            break;
          }
        } else {
          if (untypedDatasets) {
            untypedDatasets.push(optionDataset);
          } else {
            untypedDatasets = [optionDataset];
          }
        }
      }
      if (validDataset) {
        return validDataset;
      }
      if (typedDatasets) {
        if (typedDatasets.length === 1) {
          return typedDatasets[0];
        }
        _addIssue(this, "type", dataset, config22, {
          issues: _subIssues(typedDatasets)
        });
        dataset.typed = true;
      } else if ((untypedDatasets == null ? void 0 : untypedDatasets.length) === 1) {
        return untypedDatasets[0];
      } else {
        _addIssue(this, "type", dataset, config22, {
          issues: _subIssues(untypedDatasets)
        });
      }
      return dataset;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    _run(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
function parse(schema, input, config22) {
  const dataset = schema._run(
    { typed: false, value: input },
    getGlobalConfig(config22)
  );
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}
function pipe(...pipe2) {
  return __spreadProps(__spreadValues({}, pipe2[0]), {
    pipe: pipe2,
    _run(dataset, config22) {
      for (let index = 0; index < pipe2.length; index++) {
        if (dataset.issues && (pipe2[index].kind === "schema" || pipe2[index].kind === "transformation")) {
          dataset.typed = false;
          break;
        }
        if (!dataset.issues || !config22.abortEarly && !config22.abortPipeEarly) {
          dataset = pipe2[index]._run(dataset, config22);
        }
      }
      return dataset;
    }
  });
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/data/internal.js
function safeEnum(options) {
  const unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));
  return pipe(
    union(unionOptions),
    transform((value) => __spreadProps(__spreadValues({}, value), {
      $kind: Object.keys(value)[0]
    }))
  );
}
var SuiAddress = pipe(
  string(),
  transform((value) => normalizeSuiAddress(value)),
  check(isValidSuiAddress)
);
var ObjectID = SuiAddress;
var BCSBytes = string();
var JsonU64 = pipe(
  union([string(), pipe(number(), integer())]),
  check((val) => {
    try {
      BigInt(val);
      return BigInt(val) >= 0 && BigInt(val) <= /* @__PURE__ */ BigInt("18446744073709551615");
    } catch (e) {
      return false;
    }
  }, "Invalid u64")
);
var ObjectRef = object({
  objectId: SuiAddress,
  version: JsonU64,
  digest: string()
});
var Argument2 = pipe(
  union([
    object({ GasCoin: literal(true) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("pure")) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("object")) }),
    object({ Result: pipe(number(), integer()) }),
    object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) })
  ]),
  transform((value) => __spreadProps(__spreadValues({}, value), {
    $kind: Object.keys(value)[0]
  }))
  // Defined manually to add `type?: 'pure' | 'object'` to Input
);
var GasData2 = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRef))
});
var StructTag2 = object({
  address: string(),
  module: string(),
  name: string(),
  // type_params in rust, should be updated to use camelCase
  typeParams: array(string())
});
var OpenMoveTypeSignatureBody = union([
  literal("address"),
  literal("bool"),
  literal("u8"),
  literal("u16"),
  literal("u32"),
  literal("u64"),
  literal("u128"),
  literal("u256"),
  object({ vector: lazy(() => OpenMoveTypeSignatureBody) }),
  object({
    datatype: object({
      package: string(),
      module: string(),
      type: string(),
      typeParameters: array(lazy(() => OpenMoveTypeSignatureBody))
    })
  }),
  object({ typeParameter: pipe(number(), integer()) })
]);
var OpenMoveTypeSignature = object({
  ref: nullable(union([literal("&"), literal("&mut")])),
  body: OpenMoveTypeSignatureBody
});
var ProgrammableMoveCall2 = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument2),
  _argumentTypes: optional(nullable(array(OpenMoveTypeSignature)))
});
var $Intent = object({
  name: string(),
  inputs: record(string(), union([Argument2, array(Argument2)])),
  data: record(string(), unknown())
});
var Command2 = safeEnum({
  MoveCall: ProgrammableMoveCall2,
  TransferObjects: object({
    objects: array(Argument2),
    address: Argument2
  }),
  SplitCoins: object({
    coin: Argument2,
    amounts: array(Argument2)
  }),
  MergeCoins: object({
    destination: Argument2,
    sources: array(Argument2)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument2)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: Argument2
  }),
  $Intent
});
var ObjectArg2 = safeEnum({
  ImmOrOwnedObject: ObjectRef,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef
});
var CallArg2 = safeEnum({
  Object: ObjectArg2,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64))
  })
});
var NormalizedCallArg = safeEnum({
  Object: ObjectArg2,
  Pure: object({
    bytes: BCSBytes
  })
});
var TransactionExpiration2 = safeEnum({
  None: literal(true),
  Epoch: JsonU64
});
var TransactionData2 = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration2),
  gasData: GasData2,
  inputs: array(CallArg2),
  commands: array(Command2)
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/Commands.js
var Commands = {
  MoveCall(input) {
    var _a7, _b3;
    const [pkg, mod3 = "", fn3 = ""] = "target" in input ? input.target.split("::") : [input.package, input.module, input.function];
    return {
      $kind: "MoveCall",
      MoveCall: {
        package: pkg,
        module: mod3,
        function: fn3,
        typeArguments: (_a7 = input.typeArguments) != null ? _a7 : [],
        arguments: (_b3 = input.arguments) != null ? _b3 : []
      }
    };
  },
  TransferObjects(objects, address) {
    return {
      $kind: "TransferObjects",
      TransferObjects: {
        objects: objects.map((o) => parse(Argument2, o)),
        address: parse(Argument2, address)
      }
    };
  },
  SplitCoins(coin, amounts) {
    return {
      $kind: "SplitCoins",
      SplitCoins: {
        coin: parse(Argument2, coin),
        amounts: amounts.map((o) => parse(Argument2, o))
      }
    };
  },
  MergeCoins(destination, sources) {
    return {
      $kind: "MergeCoins",
      MergeCoins: {
        destination: parse(Argument2, destination),
        sources: sources.map((o) => parse(Argument2, o))
      }
    };
  },
  Publish({
    modules,
    dependencies
  }) {
    return {
      $kind: "Publish",
      Publish: {
        modules: modules.map(
          (module2) => typeof module2 === "string" ? module2 : toBase64(new Uint8Array(module2))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))
      }
    };
  },
  Upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return {
      $kind: "Upgrade",
      Upgrade: {
        modules: modules.map(
          (module2) => typeof module2 === "string" ? module2 : toBase64(new Uint8Array(module2))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),
        package: packageId,
        ticket: parse(Argument2, ticket)
      }
    };
  },
  MakeMoveVec({
    type,
    elements
  }) {
    return {
      $kind: "MakeMoveVec",
      MakeMoveVec: {
        type: type != null ? type : null,
        elements: elements.map((o) => parse(Argument2, o))
      }
    };
  },
  Intent({
    name,
    inputs = {},
    data = {}
  }) {
    return {
      $kind: "$Intent",
      $Intent: {
        name,
        inputs: Object.fromEntries(
          Object.entries(inputs).map(([key, value]) => [
            key,
            Array.isArray(value) ? value.map((o) => parse(Argument2, o)) : parse(Argument2, value)
          ])
        ),
        data
      }
    };
  }
};

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/data/v1.js
var ObjectRef2 = object({
  digest: string(),
  objectId: string(),
  version: union([pipe(number(), integer()), string(), bigint()])
});
var ObjectArg3 = safeEnum({
  ImmOrOwned: ObjectRef2,
  Shared: object({
    objectId: ObjectID,
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef2
});
var NormalizedCallArg2 = safeEnum({
  Object: ObjectArg3,
  Pure: array(pipe(number(), integer()))
});
var TransactionInput = union([
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: optional(literal("object"))
  }),
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: literal("pure")
  })
]);
var TransactionExpiration3 = union([
  object({ Epoch: pipe(number(), integer()) }),
  object({ None: nullable(literal(true)) })
]);
var StringEncodedBigint = pipe(
  union([number(), string(), bigint()]),
  check((val) => {
    if (!["string", "number", "bigint"].includes(typeof val)) return false;
    try {
      BigInt(val);
      return true;
    } catch (e) {
      return false;
    }
  })
);
var TypeTag2 = union([
  object({ bool: nullable(literal(true)) }),
  object({ u8: nullable(literal(true)) }),
  object({ u64: nullable(literal(true)) }),
  object({ u128: nullable(literal(true)) }),
  object({ address: nullable(literal(true)) }),
  object({ signer: nullable(literal(true)) }),
  object({ vector: lazy(() => TypeTag2) }),
  object({ struct: lazy(() => StructTag3) }),
  object({ u16: nullable(literal(true)) }),
  object({ u32: nullable(literal(true)) }),
  object({ u256: nullable(literal(true)) })
]);
var StructTag3 = object({
  address: string(),
  module: string(),
  name: string(),
  typeParams: array(TypeTag2)
});
var GasConfig = object({
  budget: optional(StringEncodedBigint),
  price: optional(StringEncodedBigint),
  payment: optional(array(ObjectRef2)),
  owner: optional(string())
});
var TransactionArgumentTypes = [
  TransactionInput,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: pipe(number(), integer()) }),
  object({
    kind: literal("NestedResult"),
    index: pipe(number(), integer()),
    resultIndex: pipe(number(), integer())
  })
];
var TransactionArgument = union([...TransactionArgumentTypes]);
var MoveCallTransaction = object({
  kind: literal("MoveCall"),
  target: pipe(
    string(),
    check((target) => target.split("::").length === 3)
  ),
  typeArguments: array(string()),
  arguments: array(TransactionArgument)
});
var TransferObjectsTransaction = object({
  kind: literal("TransferObjects"),
  objects: array(TransactionArgument),
  address: TransactionArgument
});
var SplitCoinsTransaction = object({
  kind: literal("SplitCoins"),
  coin: TransactionArgument,
  amounts: array(TransactionArgument)
});
var MergeCoinsTransaction = object({
  kind: literal("MergeCoins"),
  destination: TransactionArgument,
  sources: array(TransactionArgument)
});
var MakeMoveVecTransaction = object({
  kind: literal("MakeMoveVec"),
  type: union([object({ Some: TypeTag2 }), object({ None: nullable(literal(true)) })]),
  objects: array(TransactionArgument)
});
var PublishTransaction = object({
  kind: literal("Publish"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string())
});
var UpgradeTransaction = object({
  kind: literal("Upgrade"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string()),
  packageId: string(),
  ticket: TransactionArgument
});
var TransactionTypes = [
  MoveCallTransaction,
  TransferObjectsTransaction,
  SplitCoinsTransaction,
  MergeCoinsTransaction,
  PublishTransaction,
  UpgradeTransaction,
  MakeMoveVecTransaction
];
var TransactionType = union([...TransactionTypes]);
var SerializedTransactionDataV1 = object({
  version: literal(1),
  sender: optional(string()),
  expiration: nullish(TransactionExpiration3),
  gasConfig: GasConfig,
  inputs: array(TransactionInput),
  transactions: array(TransactionType)
});
function serializeV1TransactionData(transactionData) {
  var _a7, _b3, _c, _d, _e3, _f;
  const inputs = transactionData.inputs.map(
    (input, index) => {
      if (input.Object) {
        return {
          kind: "Input",
          index,
          value: {
            Object: input.Object.ImmOrOwnedObject ? {
              ImmOrOwned: input.Object.ImmOrOwnedObject
            } : input.Object.Receiving ? {
              Receiving: {
                digest: input.Object.Receiving.digest,
                version: input.Object.Receiving.version,
                objectId: input.Object.Receiving.objectId
              }
            } : {
              Shared: {
                mutable: input.Object.SharedObject.mutable,
                initialSharedVersion: input.Object.SharedObject.initialSharedVersion,
                objectId: input.Object.SharedObject.objectId
              }
            }
          },
          type: "object"
        };
      }
      if (input.Pure) {
        return {
          kind: "Input",
          index,
          value: {
            Pure: Array.from(fromBase64(input.Pure.bytes))
          },
          type: "pure"
        };
      }
      if (input.UnresolvedPure) {
        return {
          kind: "Input",
          type: "pure",
          index,
          value: input.UnresolvedPure.value
        };
      }
      if (input.UnresolvedObject) {
        return {
          kind: "Input",
          type: "object",
          index,
          value: input.UnresolvedObject.objectId
        };
      }
      throw new Error("Invalid input");
    }
  );
  return {
    version: 1,
    sender: (_a7 = transactionData.sender) != null ? _a7 : void 0,
    expiration: ((_b3 = transactionData.expiration) == null ? void 0 : _b3.$kind) === "Epoch" ? { Epoch: Number(transactionData.expiration.Epoch) } : transactionData.expiration ? { None: true } : null,
    gasConfig: {
      owner: (_c = transactionData.gasData.owner) != null ? _c : void 0,
      budget: (_d = transactionData.gasData.budget) != null ? _d : void 0,
      price: (_e3 = transactionData.gasData.price) != null ? _e3 : void 0,
      payment: (_f = transactionData.gasData.payment) != null ? _f : void 0
    },
    inputs,
    transactions: transactionData.commands.map((command) => {
      if (command.MakeMoveVec) {
        return {
          kind: "MakeMoveVec",
          type: command.MakeMoveVec.type === null ? { None: true } : { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },
          objects: command.MakeMoveVec.elements.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.MergeCoins) {
        return {
          kind: "MergeCoins",
          destination: convertTransactionArgument(command.MergeCoins.destination, inputs),
          sources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.MoveCall) {
        return {
          kind: "MoveCall",
          target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,
          typeArguments: command.MoveCall.typeArguments,
          arguments: command.MoveCall.arguments.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.Publish) {
        return {
          kind: "Publish",
          modules: command.Publish.modules.map((mod3) => Array.from(fromBase64(mod3))),
          dependencies: command.Publish.dependencies
        };
      }
      if (command.SplitCoins) {
        return {
          kind: "SplitCoins",
          coin: convertTransactionArgument(command.SplitCoins.coin, inputs),
          amounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.TransferObjects) {
        return {
          kind: "TransferObjects",
          objects: command.TransferObjects.objects.map(
            (arg) => convertTransactionArgument(arg, inputs)
          ),
          address: convertTransactionArgument(command.TransferObjects.address, inputs)
        };
      }
      if (command.Upgrade) {
        return {
          kind: "Upgrade",
          modules: command.Upgrade.modules.map((mod3) => Array.from(fromBase64(mod3))),
          dependencies: command.Upgrade.dependencies,
          packageId: command.Upgrade.package,
          ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)
        };
      }
      throw new Error(`Unknown transaction ${Object.keys(command)}`);
    })
  };
}
function convertTransactionArgument(arg, inputs) {
  if (arg.$kind === "GasCoin") {
    return { kind: "GasCoin" };
  }
  if (arg.$kind === "Result") {
    return { kind: "Result", index: arg.Result };
  }
  if (arg.$kind === "NestedResult") {
    return { kind: "NestedResult", index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };
  }
  if (arg.$kind === "Input") {
    return inputs[arg.Input];
  }
  throw new Error(`Invalid argument ${Object.keys(arg)}`);
}
function transactionDataFromV1(data) {
  var _a7, _b3, _c, _d, _e3, _f, _g, _h;
  return parse(TransactionData2, {
    version: 2,
    sender: (_a7 = data.sender) != null ? _a7 : null,
    expiration: data.expiration ? "Epoch" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,
    gasData: {
      owner: (_b3 = data.gasConfig.owner) != null ? _b3 : null,
      budget: (_d = (_c = data.gasConfig.budget) == null ? void 0 : _c.toString()) != null ? _d : null,
      price: (_f = (_e3 = data.gasConfig.price) == null ? void 0 : _e3.toString()) != null ? _f : null,
      payment: (_h = (_g = data.gasConfig.payment) == null ? void 0 : _g.map((ref) => ({
        digest: ref.digest,
        objectId: ref.objectId,
        version: ref.version.toString()
      }))) != null ? _h : null
    },
    inputs: data.inputs.map((input) => {
      var _a8;
      if (input.kind === "Input") {
        if (is(NormalizedCallArg2, input.value)) {
          const value = parse(NormalizedCallArg2, input.value);
          if (value.Object) {
            if (value.Object.ImmOrOwned) {
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: value.Object.ImmOrOwned.objectId,
                    version: String(value.Object.ImmOrOwned.version),
                    digest: value.Object.ImmOrOwned.digest
                  }
                }
              };
            }
            if (value.Object.Shared) {
              return {
                Object: {
                  SharedObject: {
                    mutable: (_a8 = value.Object.Shared.mutable) != null ? _a8 : null,
                    initialSharedVersion: value.Object.Shared.initialSharedVersion,
                    objectId: value.Object.Shared.objectId
                  }
                }
              };
            }
            if (value.Object.Receiving) {
              return {
                Object: {
                  Receiving: {
                    digest: value.Object.Receiving.digest,
                    version: String(value.Object.Receiving.version),
                    objectId: value.Object.Receiving.objectId
                  }
                }
              };
            }
            throw new Error("Invalid object input");
          }
          return {
            Pure: {
              bytes: toBase64(new Uint8Array(value.Pure))
            }
          };
        }
        if (input.type === "object") {
          return {
            UnresolvedObject: {
              objectId: input.value
            }
          };
        }
        return {
          UnresolvedPure: {
            value: input.value
          }
        };
      }
      throw new Error("Invalid input");
    }),
    commands: data.transactions.map((transaction) => {
      switch (transaction.kind) {
        case "MakeMoveVec":
          return {
            MakeMoveVec: {
              type: "Some" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,
              elements: transaction.objects.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        case "MergeCoins": {
          return {
            MergeCoins: {
              destination: parseV1TransactionArgument(transaction.destination),
              sources: transaction.sources.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "MoveCall": {
          const [pkg, mod3, fn3] = transaction.target.split("::");
          return {
            MoveCall: {
              package: pkg,
              module: mod3,
              function: fn3,
              typeArguments: transaction.typeArguments,
              arguments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "Publish": {
          return {
            Publish: {
              modules: transaction.modules.map((mod3) => toBase64(Uint8Array.from(mod3))),
              dependencies: transaction.dependencies
            }
          };
        }
        case "SplitCoins": {
          return {
            SplitCoins: {
              coin: parseV1TransactionArgument(transaction.coin),
              amounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "TransferObjects": {
          return {
            TransferObjects: {
              objects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),
              address: parseV1TransactionArgument(transaction.address)
            }
          };
        }
        case "Upgrade": {
          return {
            Upgrade: {
              modules: transaction.modules.map((mod3) => toBase64(Uint8Array.from(mod3))),
              dependencies: transaction.dependencies,
              package: transaction.packageId,
              ticket: parseV1TransactionArgument(transaction.ticket)
            }
          };
        }
      }
      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);
    })
  });
}
function parseV1TransactionArgument(arg) {
  switch (arg.kind) {
    case "GasCoin": {
      return { GasCoin: true };
    }
    case "Result":
      return { Result: arg.index };
    case "NestedResult": {
      return { NestedResult: [arg.index, arg.resultIndex] };
    }
    case "Input": {
      return { Input: arg.index };
    }
  }
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/data/v2.js
function enumUnion(options) {
  return union(
    Object.entries(options).map(([key, value]) => object({ [key]: value }))
  );
}
var Argument3 = enumUnion({
  GasCoin: literal(true),
  Input: pipe(number(), integer()),
  Result: pipe(number(), integer()),
  NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())])
});
var GasData3 = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRef))
});
var ProgrammableMoveCall3 = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument3)
});
var $Intent2 = object({
  name: string(),
  inputs: record(string(), union([Argument3, array(Argument3)])),
  data: record(string(), unknown())
});
var Command3 = enumUnion({
  MoveCall: ProgrammableMoveCall3,
  TransferObjects: object({
    objects: array(Argument3),
    address: Argument3
  }),
  SplitCoins: object({
    coin: Argument3,
    amounts: array(Argument3)
  }),
  MergeCoins: object({
    destination: Argument3,
    sources: array(Argument3)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument3)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: Argument3
  }),
  $Intent: $Intent2
});
var ObjectArg4 = enumUnion({
  ImmOrOwnedObject: ObjectRef,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef
});
var CallArg3 = enumUnion({
  Object: ObjectArg4,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64))
  })
});
var TransactionExpiration4 = enumUnion({
  None: literal(true),
  Epoch: JsonU64
});
var SerializedTransactionDataV2 = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration4),
  gasData: GasData3,
  inputs: array(CallArg3),
  commands: array(Command3)
});

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/json-rpc-resolver.js
var MAX_OBJECTS_PER_FETCH = 50;
var GAS_SAFE_OVERHEAD = /* @__PURE__ */ BigInt("1000");
var MAX_GAS = 5e10;
async function resolveTransactionData(transactionData, options, next) {
  await normalizeInputs(transactionData, options);
  await resolveObjectReferences(transactionData, options);
  if (!options.onlyTransactionKind) {
    await setGasPrice(transactionData, options);
    await setGasBudget(transactionData, options);
    await setGasPayment(transactionData, options);
  }
  await validate(transactionData);
  return await next();
}
async function setGasPrice(transactionData, options) {
  if (!transactionData.gasConfig.price) {
    transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());
  }
}
async function setGasBudget(transactionData, options) {
  if (transactionData.gasConfig.budget) {
    return;
  }
  const dryRunResult = await getClient(options).dryRunTransactionBlock({
    transactionBlock: transactionData.build({
      overrides: {
        gasData: {
          budget: String(MAX_GAS),
          payment: []
        }
      }
    })
  });
  if (dryRunResult.effects.status.status !== "success") {
    throw new Error(
      `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,
      { cause: dryRunResult }
    );
  }
  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || /* @__PURE__ */ BigInt("1"));
  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;
  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);
  transactionData.gasConfig.budget = String(
    gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead
  );
}
async function setGasPayment(transactionData, options) {
  if (!transactionData.gasConfig.payment) {
    const coins = await getClient(options).getCoins({
      owner: transactionData.gasConfig.owner || transactionData.sender,
      coinType: SUI_TYPE_ARG
    });
    const paymentCoins = coins.data.filter((coin) => {
      const matchingInput = transactionData.inputs.find((input) => {
        var _a7;
        if ((_a7 = input.Object) == null ? void 0 : _a7.ImmOrOwnedObject) {
          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;
        }
        return false;
      });
      return !matchingInput;
    }).map((coin) => ({
      objectId: coin.coinObjectId,
      digest: coin.digest,
      version: coin.version
    }));
    if (!paymentCoins.length) {
      throw new Error("No valid gas coins found for the transaction.");
    }
    transactionData.gasConfig.payment = paymentCoins.map((payment) => parse(ObjectRef, payment));
  }
}
async function resolveObjectReferences(transactionData, options) {
  var _a7, _b3, _c, _d, _e3;
  const objectsToResolve = transactionData.inputs.filter((input) => {
    var _a8;
    return input.UnresolvedObject && !(input.UnresolvedObject.version || ((_a8 = input.UnresolvedObject) == null ? void 0 : _a8.initialSharedVersion));
  });
  const dedupedIds = [
    ...new Set(
      objectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId))
    )
  ];
  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];
  const resolved = (await Promise.all(
    objectChunks.map(
      (chunk2) => getClient(options).multiGetObjects({
        ids: chunk2,
        options: { showOwner: true }
      })
    )
  )).flat();
  const responsesById = new Map(
    dedupedIds.map((id, index) => {
      return [id, resolved[index]];
    })
  );
  const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));
  if (invalidObjects.length) {
    throw new Error(`The following input objects are invalid: ${invalidObjects.join(", ")}`);
  }
  const objects = resolved.map((object2) => {
    if (object2.error || !object2.data) {
      throw new Error(`Failed to fetch object: ${object2.error}`);
    }
    const owner = object2.data.owner;
    const initialSharedVersion = owner && typeof owner === "object" && "Shared" in owner ? owner.Shared.initial_shared_version : null;
    return {
      objectId: object2.data.objectId,
      digest: object2.data.digest,
      version: object2.data.version,
      initialSharedVersion
    };
  });
  const objectsById = new Map(
    dedupedIds.map((id, index) => {
      return [id, objects[index]];
    })
  );
  for (const [index, input] of transactionData.inputs.entries()) {
    if (!input.UnresolvedObject) {
      continue;
    }
    let updated;
    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);
    const object2 = objectsById.get(id);
    if ((_a7 = input.UnresolvedObject.initialSharedVersion) != null ? _a7 : object2 == null ? void 0 : object2.initialSharedVersion) {
      updated = Inputs.SharedObjectRef({
        objectId: id,
        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || (object2 == null ? void 0 : object2.initialSharedVersion),
        mutable: isUsedAsMutable(transactionData, index)
      });
    } else if (isUsedAsReceiving(transactionData, index)) {
      updated = Inputs.ReceivingRef(
        {
          objectId: id,
          digest: (_b3 = input.UnresolvedObject.digest) != null ? _b3 : object2 == null ? void 0 : object2.digest,
          version: (_c = input.UnresolvedObject.version) != null ? _c : object2 == null ? void 0 : object2.version
        }
      );
    }
    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated != null ? updated : Inputs.ObjectRef({
      objectId: id,
      digest: (_d = input.UnresolvedObject.digest) != null ? _d : object2 == null ? void 0 : object2.digest,
      version: (_e3 = input.UnresolvedObject.version) != null ? _e3 : object2 == null ? void 0 : object2.version
    });
  }
}
async function normalizeInputs(transactionData, options) {
  const { inputs, commands } = transactionData;
  const moveCallsToResolve = [];
  const moveFunctionsToResolve = /* @__PURE__ */ new Set();
  commands.forEach((command) => {
    if (command.MoveCall) {
      if (command.MoveCall._argumentTypes) {
        return;
      }
      const inputs2 = command.MoveCall.arguments.map((arg) => {
        if (arg.$kind === "Input") {
          return transactionData.inputs[arg.Input];
        }
        return null;
      });
      const needsResolution = inputs2.some(
        (input) => (input == null ? void 0 : input.UnresolvedPure) || (input == null ? void 0 : input.UnresolvedObject)
      );
      if (needsResolution) {
        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;
        moveFunctionsToResolve.add(functionName);
        moveCallsToResolve.push(command.MoveCall);
      }
    }
    switch (command.$kind) {
      case "SplitCoins":
        command.SplitCoins.amounts.forEach((amount) => {
          normalizeRawArgument(amount, suiBcs.U64, transactionData);
        });
        break;
      case "TransferObjects":
        normalizeRawArgument(command.TransferObjects.address, suiBcs.Address, transactionData);
        break;
    }
  });
  const moveFunctionParameters = /* @__PURE__ */ new Map();
  if (moveFunctionsToResolve.size > 0) {
    const client = getClient(options);
    await Promise.all(
      [...moveFunctionsToResolve].map(async (functionName) => {
        const [packageId, moduleId, functionId] = functionName.split("::");
        const def = await client.getNormalizedMoveFunction({
          package: packageId,
          module: moduleId,
          function: functionId
        });
        moveFunctionParameters.set(
          functionName,
          def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param))
        );
      })
    );
  }
  if (moveCallsToResolve.length) {
    await Promise.all(
      moveCallsToResolve.map(async (moveCall) => {
        const parameters = moveFunctionParameters.get(
          `${moveCall.package}::${moveCall.module}::${moveCall.function}`
        );
        if (!parameters) {
          return;
        }
        const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));
        const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;
        moveCall._argumentTypes = params;
      })
    );
  }
  commands.forEach((command) => {
    if (!command.MoveCall) {
      return;
    }
    const moveCall = command.MoveCall;
    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;
    const params = moveCall._argumentTypes;
    if (!params) {
      return;
    }
    if (params.length !== command.MoveCall.arguments.length) {
      throw new Error(`Incorrect number of arguments for ${fnName}`);
    }
    params.forEach((param, i) => {
      var _a7, _b3, _c;
      const arg = moveCall.arguments[i];
      if (arg.$kind !== "Input") return;
      const input = inputs[arg.Input];
      if (!input.UnresolvedPure && !input.UnresolvedObject) {
        return;
      }
      const inputValue = (_c = (_a7 = input.UnresolvedPure) == null ? void 0 : _a7.value) != null ? _c : (_b3 = input.UnresolvedObject) == null ? void 0 : _b3.objectId;
      const schema = getPureBcsSchema(param.body);
      if (schema) {
        arg.type = "pure";
        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));
        return;
      }
      if (typeof inputValue !== "string") {
        throw new Error(
          `Expect the argument to be an object id string, got ${JSON.stringify(
            inputValue,
            null,
            2
          )}`
        );
      }
      arg.type = "object";
      const unresolvedObject = input.UnresolvedPure ? {
        $kind: "UnresolvedObject",
        UnresolvedObject: {
          objectId: inputValue
        }
      } : input;
      inputs[arg.Input] = unresolvedObject;
    });
  });
}
function validate(transactionData) {
  transactionData.inputs.forEach((input, index) => {
    if (input.$kind !== "Object" && input.$kind !== "Pure") {
      throw new Error(
        `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
          input
        )}`
      );
    }
  });
}
function normalizeRawArgument(arg, schema, transactionData) {
  if (arg.$kind !== "Input") {
    return;
  }
  const input = transactionData.inputs[arg.Input];
  if (input.$kind !== "UnresolvedPure") {
    return;
  }
  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));
}
function isUsedAsMutable(transactionData, index) {
  let usedAsMutable = false;
  transactionData.getInputUses(index, (arg, tx) => {
    if (tx.MoveCall && tx.MoveCall._argumentTypes) {
      const argIndex = tx.MoveCall.arguments.indexOf(arg);
      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== "&" || usedAsMutable;
    }
    if (tx.$kind === "MakeMoveVec" || tx.$kind === "MergeCoins" || tx.$kind === "SplitCoins") {
      usedAsMutable = true;
    }
  });
  return usedAsMutable;
}
function isUsedAsReceiving(transactionData, index) {
  let usedAsReceiving = false;
  transactionData.getInputUses(index, (arg, tx) => {
    if (tx.MoveCall && tx.MoveCall._argumentTypes) {
      const argIndex = tx.MoveCall.arguments.indexOf(arg);
      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;
    }
  });
  return usedAsReceiving;
}
function isReceivingType(type) {
  if (typeof type.body !== "object" || !("datatype" in type.body)) {
    return false;
  }
  return type.body.datatype.package === "0x2" && type.body.datatype.module === "transfer" && type.body.datatype.type === "Receiving";
}
function getClient(options) {
  if (!options.client) {
    throw new Error(
      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return options.client;
}
function chunk(arr, size) {
  return Array.from(
    { length: Math.ceil(arr.length / size) },
    (_, i) => arr.slice(i * size, i * size + size)
  );
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/object.js
function createObjectMethods(makeObject) {
  function object2(value) {
    return makeObject(value);
  }
  object2.system = () => object2("0x5");
  object2.clock = () => object2("0x6");
  object2.random = () => object2("0x8");
  object2.denyList = () => object2("0x403");
  object2.option = ({ type, value }) => (tx) => tx.moveCall({
    typeArguments: [type],
    target: `0x1::option::${value === null ? "none" : "some"}`,
    arguments: value === null ? [] : [tx.object(value)]
  });
  return object2;
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/pure.js
function createPure(makePure) {
  function pure(typeOrSerializedValue, value) {
    if (typeof typeOrSerializedValue === "string") {
      return makePure(schemaFromName(typeOrSerializedValue).serialize(value));
    }
    if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {
      return makePure(typeOrSerializedValue);
    }
    throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value");
  }
  pure.u8 = (value) => makePure(suiBcs.U8.serialize(value));
  pure.u16 = (value) => makePure(suiBcs.U16.serialize(value));
  pure.u32 = (value) => makePure(suiBcs.U32.serialize(value));
  pure.u64 = (value) => makePure(suiBcs.U64.serialize(value));
  pure.u128 = (value) => makePure(suiBcs.U128.serialize(value));
  pure.u256 = (value) => makePure(suiBcs.U256.serialize(value));
  pure.bool = (value) => makePure(suiBcs.Bool.serialize(value));
  pure.string = (value) => makePure(suiBcs.String.serialize(value));
  pure.address = (value) => makePure(suiBcs.Address.serialize(value));
  pure.id = pure.address;
  pure.vector = (type, value) => {
    return makePure(suiBcs.vector(schemaFromName(type)).serialize(value));
  };
  pure.option = (type, value) => {
    return makePure(suiBcs.option(schemaFromName(type)).serialize(value));
  };
  return pure;
}
function schemaFromName(name) {
  switch (name) {
    case "u8":
      return suiBcs.u8();
    case "u16":
      return suiBcs.u16();
    case "u32":
      return suiBcs.u32();
    case "u64":
      return suiBcs.u64();
    case "u128":
      return suiBcs.u128();
    case "u256":
      return suiBcs.u256();
    case "bool":
      return suiBcs.bool();
    case "string":
      return suiBcs.string();
    case "id":
    case "address":
      return suiBcs.Address;
  }
  const generic = name.match(/^(vector|option)<(.+)>$/);
  if (generic) {
    const [kind, inner] = generic.slice(1);
    if (kind === "vector") {
      return suiBcs.vector(schemaFromName(inner));
    } else {
      return suiBcs.option(schemaFromName(inner));
    }
  }
  throw new Error(`Invalid Pure type name: ${name}`);
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/hash.js
function hashTypedData(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b2(dataWithTag, { dkLen: 32 });
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js
function prepareSuiAddress(address) {
  return normalizeSuiAddress(address).replace("0x", "");
}
var TransactionDataBuilder = class _TransactionDataBuilder {
  constructor(clone3) {
    var _a7, _b3, _c, _d, _e3;
    this.version = 2;
    this.sender = (_a7 = clone3 == null ? void 0 : clone3.sender) != null ? _a7 : null;
    this.expiration = (_b3 = clone3 == null ? void 0 : clone3.expiration) != null ? _b3 : null;
    this.inputs = (_c = clone3 == null ? void 0 : clone3.inputs) != null ? _c : [];
    this.commands = (_d = clone3 == null ? void 0 : clone3.commands) != null ? _d : [];
    this.gasData = (_e3 = clone3 == null ? void 0 : clone3.gasData) != null ? _e3 : {
      budget: null,
      price: null,
      owner: null,
      payment: null
    };
  }
  static fromKindBytes(bytes) {
    const kind = suiBcs.TransactionKind.parse(bytes);
    const programmableTx = kind.ProgrammableTransaction;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return _TransactionDataBuilder.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: {
        budget: null,
        owner: null,
        payment: null,
        price: null
      },
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static fromBytes(bytes) {
    const rawData = suiBcs.TransactionData.parse(bytes);
    const data = rawData == null ? void 0 : rawData.V1;
    const programmableTx = data.kind.ProgrammableTransaction;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return _TransactionDataBuilder.restore({
      version: 2,
      sender: data.sender,
      expiration: data.expiration,
      gasData: data.gasData,
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static restore(data) {
    if (data.version === 2) {
      return new _TransactionDataBuilder(parse(TransactionData2, data));
    } else {
      return new _TransactionDataBuilder(parse(TransactionData2, transactionDataFromV1(data)));
    }
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes) {
    const hash = hashTypedData("TransactionData", bytes);
    return toBase58(hash);
  }
  // @deprecated use gasData instead
  get gasConfig() {
    return this.gasData;
  }
  // @deprecated use gasData instead
  set gasConfig(value) {
    this.gasData = value;
  }
  build({
    maxSizeBytes = Infinity,
    overrides,
    onlyTransactionKind
  } = {}) {
    var _a7, _b3, _c;
    const inputs = this.inputs;
    const commands = this.commands;
    const kind = {
      ProgrammableTransaction: {
        inputs,
        commands
      }
    };
    if (onlyTransactionKind) {
      return suiBcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();
    }
    const expiration = (_a7 = overrides == null ? void 0 : overrides.expiration) != null ? _a7 : this.expiration;
    const sender = (_b3 = overrides == null ? void 0 : overrides.sender) != null ? _b3 : this.sender;
    const gasData = __spreadValues(__spreadValues(__spreadValues({}, this.gasData), overrides == null ? void 0 : overrides.gasConfig), overrides == null ? void 0 : overrides.gasData);
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasData.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasData.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasData.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasData.payment,
        owner: prepareSuiAddress((_c = this.gasData.owner) != null ? _c : sender),
        price: BigInt(gasData.price),
        budget: BigInt(gasData.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          commands
        }
      }
    };
    return suiBcs.TransactionData.serialize(
      { V1: transactionData },
      { maxSize: maxSizeBytes }
    ).toBytes();
  }
  addInput(type, arg) {
    const index = this.inputs.length;
    this.inputs.push(arg);
    return { Input: index, type, $kind: "Input" };
  }
  getInputUses(index, fn3) {
    this.mapArguments((arg, command) => {
      if (arg.$kind === "Input" && arg.Input === index) {
        fn3(arg, command);
      }
      return arg;
    });
  }
  mapArguments(fn3) {
    for (const command of this.commands) {
      switch (command.$kind) {
        case "MoveCall":
          command.MoveCall.arguments = command.MoveCall.arguments.map((arg) => fn3(arg, command));
          break;
        case "TransferObjects":
          command.TransferObjects.objects = command.TransferObjects.objects.map(
            (arg) => fn3(arg, command)
          );
          command.TransferObjects.address = fn3(command.TransferObjects.address, command);
          break;
        case "SplitCoins":
          command.SplitCoins.coin = fn3(command.SplitCoins.coin, command);
          command.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) => fn3(arg, command));
          break;
        case "MergeCoins":
          command.MergeCoins.destination = fn3(command.MergeCoins.destination, command);
          command.MergeCoins.sources = command.MergeCoins.sources.map((arg) => fn3(arg, command));
          break;
        case "MakeMoveVec":
          command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(
            (arg) => fn3(arg, command)
          );
          break;
        case "Upgrade":
          command.Upgrade.ticket = fn3(command.Upgrade.ticket, command);
          break;
        case "$Intent":
          const inputs = command.$Intent.inputs;
          command.$Intent.inputs = {};
          for (const [key, value] of Object.entries(inputs)) {
            command.$Intent.inputs[key] = Array.isArray(value) ? value.map((arg) => fn3(arg, command)) : fn3(value, command);
          }
          break;
        case "Publish":
          break;
        default:
          throw new Error(`Unexpected transaction kind: ${command.$kind}`);
      }
    }
  }
  replaceCommand(index, replacement) {
    if (!Array.isArray(replacement)) {
      this.commands[index] = replacement;
      return;
    }
    const sizeDiff = replacement.length - 1;
    this.commands.splice(index, 1, ...replacement);
    if (sizeDiff !== 0) {
      this.mapArguments((arg) => {
        switch (arg.$kind) {
          case "Result":
            if (arg.Result > index) {
              arg.Result += sizeDiff;
            }
            break;
          case "NestedResult":
            if (arg.NestedResult[0] > index) {
              arg.NestedResult[0] += sizeDiff;
            }
            break;
        }
        return arg;
      });
    }
  }
  getDigest() {
    const bytes = this.build({ onlyTransactionKind: false });
    return _TransactionDataBuilder.getDigestFromBytes(bytes);
  }
  snapshot() {
    return parse(TransactionData2, this);
  }
};

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/utils.js
function getIdFromCallArg(arg) {
  if (typeof arg === "string") {
    return normalizeSuiAddress(arg);
  }
  if (arg.Object) {
    if (arg.Object.ImmOrOwnedObject) {
      return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);
    }
    if (arg.Object.Receiving) {
      return normalizeSuiAddress(arg.Object.Receiving.objectId);
    }
    return normalizeSuiAddress(arg.Object.SharedObject.objectId);
  }
  if (arg.UnresolvedObject) {
    return normalizeSuiAddress(arg.UnresolvedObject.objectId);
  }
  return void 0;
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/Transaction.js
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet3 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck3(obj, member, "access private method"), method);
var _serializationPlugins;
var _buildPlugins;
var _intentResolvers;
var _data;
var _Transaction_instances;
var normalizeTransactionArgument_fn;
var resolveArgument_fn;
var prepareBuild_fn;
var runPlugins_fn;
function createTransactionResult(index, length = Infinity) {
  const baseResult = { $kind: "Result", Result: index };
  const nestedResults = [];
  const nestedResultFor = (resultIndex) => {
    var _a7;
    return (_a7 = nestedResults[resultIndex]) != null ? _a7 : nestedResults[resultIndex] = {
      $kind: "NestedResult",
      NestedResult: [index, resultIndex]
    };
  };
  return new Proxy(baseResult, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(target, property) {
      if (property in target) {
        return Reflect.get(target, property);
      }
      if (property === Symbol.iterator) {
        return function* () {
          let i = 0;
          while (i < length) {
            yield nestedResultFor(i);
            i++;
          }
        };
      }
      if (typeof property === "symbol") return;
      const resultIndex = parseInt(property, 10);
      if (Number.isNaN(resultIndex) || resultIndex < 0) return;
      return nestedResultFor(resultIndex);
    }
  });
}
var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
function isTransaction(obj) {
  return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
}
var modulePluginRegistry = {
  buildPlugins: /* @__PURE__ */ new Map(),
  serializationPlugins: /* @__PURE__ */ new Map()
};
var TRANSACTION_REGISTRY_KEY = Symbol.for("@mysten/transaction/registry");
function getGlobalPluginRegistry() {
  try {
    const target = globalThis;
    if (!target[TRANSACTION_REGISTRY_KEY]) {
      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;
    }
    return target[TRANSACTION_REGISTRY_KEY];
  } catch (e) {
    return modulePluginRegistry;
  }
}
var _Transaction = class _Transaction2 {
  constructor() {
    __privateAdd3(this, _Transaction_instances);
    __privateAdd3(this, _serializationPlugins);
    __privateAdd3(this, _buildPlugins);
    __privateAdd3(this, _intentResolvers, /* @__PURE__ */ new Map());
    __privateAdd3(this, _data);
    this.object = createObjectMethods(
      (value) => {
        var _a7, _b3;
        if (typeof value === "function") {
          return this.object(value(this));
        }
        if (typeof value === "object" && is(Argument2, value)) {
          return value;
        }
        const id = getIdFromCallArg(value);
        const inserted = __privateGet3(this, _data).inputs.find((i) => id === getIdFromCallArg(i));
        if (((_a7 = inserted == null ? void 0 : inserted.Object) == null ? void 0 : _a7.SharedObject) && typeof value === "object" && ((_b3 = value.Object) == null ? void 0 : _b3.SharedObject)) {
          inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;
        }
        return inserted ? { $kind: "Input", Input: __privateGet3(this, _data).inputs.indexOf(inserted), type: "object" } : __privateGet3(this, _data).addInput(
          "object",
          typeof value === "string" ? {
            $kind: "UnresolvedObject",
            UnresolvedObject: { objectId: normalizeSuiAddress(value) }
          } : value
        );
      }
    );
    const globalPlugins = getGlobalPluginRegistry();
    __privateSet3(this, _data, new TransactionDataBuilder());
    __privateSet3(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);
    __privateSet3(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(serialized) {
    const tx = new _Transaction2();
    __privateSet3(tx, _data, TransactionDataBuilder.fromKindBytes(
      typeof serialized === "string" ? fromBase64(serialized) : serialized
    ));
    return tx;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(transaction) {
    const newTransaction = new _Transaction2();
    if (isTransaction(transaction)) {
      __privateSet3(newTransaction, _data, new TransactionDataBuilder(transaction.getData()));
    } else if (typeof transaction !== "string" || !transaction.startsWith("{")) {
      __privateSet3(newTransaction, _data, TransactionDataBuilder.fromBytes(
        typeof transaction === "string" ? fromBase64(transaction) : transaction
      ));
    } else {
      __privateSet3(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));
    }
    return newTransaction;
  }
  static registerGlobalSerializationPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().serializationPlugins.set(
      stepOrStep,
      step != null ? step : stepOrStep
    );
  }
  static unregisterGlobalSerializationPlugin(name) {
    getGlobalPluginRegistry().serializationPlugins.delete(name);
  }
  static registerGlobalBuildPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().buildPlugins.set(
      stepOrStep,
      step != null ? step : stepOrStep
    );
  }
  static unregisterGlobalBuildPlugin(name) {
    getGlobalPluginRegistry().buildPlugins.delete(name);
  }
  addSerializationPlugin(step) {
    __privateGet3(this, _serializationPlugins).push(step);
  }
  addBuildPlugin(step) {
    __privateGet3(this, _buildPlugins).push(step);
  }
  addIntentResolver(intent, resolver) {
    if (__privateGet3(this, _intentResolvers).has(intent) && __privateGet3(this, _intentResolvers).get(intent) !== resolver) {
      throw new Error(`Intent resolver for ${intent} already exists`);
    }
    __privateGet3(this, _intentResolvers).set(intent, resolver);
  }
  setSender(sender) {
    __privateGet3(this, _data).sender = sender;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(sender) {
    if (!__privateGet3(this, _data).sender) {
      __privateGet3(this, _data).sender = sender;
    }
  }
  setExpiration(expiration) {
    __privateGet3(this, _data).expiration = expiration ? parse(TransactionExpiration2, expiration) : null;
  }
  setGasPrice(price) {
    __privateGet3(this, _data).gasConfig.price = String(price);
  }
  setGasBudget(budget) {
    __privateGet3(this, _data).gasConfig.budget = String(budget);
  }
  setGasBudgetIfNotSet(budget) {
    if (__privateGet3(this, _data).gasData.budget == null) {
      __privateGet3(this, _data).gasConfig.budget = String(budget);
    }
  }
  setGasOwner(owner) {
    __privateGet3(this, _data).gasConfig.owner = owner;
  }
  setGasPayment(payments) {
    __privateGet3(this, _data).gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));
  }
  /** @deprecated Use `getData()` instead. */
  get blockData() {
    return serializeV1TransactionData(__privateGet3(this, _data).snapshot());
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  getData() {
    return __privateGet3(this, _data).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [TRANSACTION_BRAND]() {
    return true;
  }
  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage
  get pure() {
    Object.defineProperty(this, "pure", {
      enumerable: false,
      value: createPure((value) => {
        if (isSerializedBcs(value)) {
          return __privateGet3(this, _data).addInput("pure", {
            $kind: "Pure",
            Pure: {
              bytes: value.toBase64()
            }
          });
        }
        return __privateGet3(this, _data).addInput(
          "pure",
          is(NormalizedCallArg, value) ? parse(NormalizedCallArg, value) : value instanceof Uint8Array ? Inputs.Pure(value) : { $kind: "UnresolvedPure", UnresolvedPure: { value } }
        );
      })
    });
    return this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { $kind: "GasCoin", GasCoin: true };
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...args) {
    return this.object(Inputs.ObjectRef(...args));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...args) {
    return this.object(Inputs.ReceivingRef(...args));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...args) {
    return this.object(Inputs.SharedObjectRef(...args));
  }
  /** Add a transaction to the transaction */
  add(command) {
    if (typeof command === "function") {
      return command(this);
    }
    const index = __privateGet3(this, _data).commands.push(command);
    return createTransactionResult(index - 1);
  }
  // Method shorthands:
  splitCoins(coin, amounts) {
    const command = Commands.SplitCoins(
      typeof coin === "string" ? this.object(coin) : __privateMethod2(this, _Transaction_instances, resolveArgument_fn).call(this, coin),
      amounts.map(
        (amount) => typeof amount === "number" || typeof amount === "bigint" || typeof amount === "string" ? this.pure.u64(amount) : __privateMethod2(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)
      )
    );
    const index = __privateGet3(this, _data).commands.push(command);
    return createTransactionResult(index - 1, amounts.length);
  }
  mergeCoins(destination, sources) {
    return this.add(
      Commands.MergeCoins(
        this.object(destination),
        sources.map((src) => this.object(src))
      )
    );
  }
  publish({ modules, dependencies }) {
    return this.add(
      Commands.Publish({
        modules,
        dependencies
      })
    );
  }
  upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return this.add(
      Commands.Upgrade({
        modules,
        dependencies,
        package: packageId,
        ticket: this.object(ticket)
      })
    );
  }
  moveCall(_a7) {
    var _b3 = _a7, {
      arguments: args
    } = _b3, input = __objRest(_b3, [
      "arguments"
    ]);
    return this.add(
      Commands.MoveCall(__spreadProps(__spreadValues({}, input), {
        arguments: args == null ? void 0 : args.map((arg) => __privateMethod2(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))
      }))
    );
  }
  transferObjects(objects, address) {
    return this.add(
      Commands.TransferObjects(
        objects.map((obj) => this.object(obj)),
        typeof address === "string" ? this.pure.address(address) : __privateMethod2(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)
      )
    );
  }
  makeMoveVec({
    type,
    elements
  }) {
    return this.add(
      Commands.MakeMoveVec({
        type,
        elements: elements.map((obj) => this.object(obj))
      })
    );
  }
  /**
   * @deprecated Use toJSON instead.
   * For synchronous serialization, you can use `getData()`
   * */
  serialize() {
    return JSON.stringify(serializeV1TransactionData(__privateGet3(this, _data).snapshot()));
  }
  async toJSON(options = {}) {
    await this.prepareForSerialization(options);
    return JSON.stringify(
      parse(SerializedTransactionDataV2, __privateGet3(this, _data).snapshot()),
      (_key, value) => typeof value === "bigint" ? value.toString() : value,
      2
    );
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(options) {
    const _a7 = options, { signer } = _a7, buildOptions = __objRest(_a7, ["signer"]);
    const bytes = await this.build(buildOptions);
    return signer.signTransaction(bytes);
  }
  /** Build the transaction to BCS bytes. */
  async build(options = {}) {
    await this.prepareForSerialization(options);
    await __privateMethod2(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet3(this, _data).build({
      onlyTransactionKind: options.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(options = {}) {
    await __privateMethod2(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet3(this, _data).getDigest();
  }
  async prepareForSerialization(options) {
    var _a7;
    const intents = /* @__PURE__ */ new Set();
    for (const command of __privateGet3(this, _data).commands) {
      if (command.$Intent) {
        intents.add(command.$Intent.name);
      }
    }
    const steps = [...__privateGet3(this, _serializationPlugins)];
    for (const intent of intents) {
      if ((_a7 = options.supportedIntents) == null ? void 0 : _a7.includes(intent)) {
        continue;
      }
      if (!__privateGet3(this, _intentResolvers).has(intent)) {
        throw new Error(`Missing intent resolver for ${intent}`);
      }
      steps.push(__privateGet3(this, _intentResolvers).get(intent));
    }
    await __privateMethod2(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);
  }
};
_serializationPlugins = /* @__PURE__ */ new WeakMap();
_buildPlugins = /* @__PURE__ */ new WeakMap();
_intentResolvers = /* @__PURE__ */ new WeakMap();
_data = /* @__PURE__ */ new WeakMap();
_Transaction_instances = /* @__PURE__ */ new WeakSet();
normalizeTransactionArgument_fn = function(arg) {
  if (isSerializedBcs(arg)) {
    return this.pure(arg);
  }
  return __privateMethod2(this, _Transaction_instances, resolveArgument_fn).call(this, arg);
};
resolveArgument_fn = function(arg) {
  if (typeof arg === "function") {
    return parse(Argument2, arg(this));
  }
  return parse(Argument2, arg);
};
prepareBuild_fn = async function(options) {
  if (!options.onlyTransactionKind && !__privateGet3(this, _data).sender) {
    throw new Error("Missing transaction sender");
  }
  await __privateMethod2(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet3(this, _buildPlugins), resolveTransactionData], options);
};
runPlugins_fn = async function(plugins, options) {
  const createNext = (i) => {
    if (i >= plugins.length) {
      return () => {
      };
    }
    const plugin = plugins[i];
    return async () => {
      const next = createNext(i + 1);
      let calledNext = false;
      let nextResolved = false;
      await plugin(__privateGet3(this, _data), options, async () => {
        if (calledNext) {
          throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);
        }
        calledNext = true;
        await next();
        nextResolved = true;
      });
      if (!calledNext) {
        throw new Error(`next() was not called in TransactionPlugin ${i}`);
      }
      if (!nextResolved) {
        throw new Error(`next() was not awaited in TransactionPlugin ${i}`);
      }
    };
  };
  await createNext(0)();
};
var Transaction = _Transaction;

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/transactions/intents/CoinWithBalance.js
var COIN_WITH_BALANCE = "CoinWithBalance";
var SUI_TYPE = normalizeStructTag("0x2::sui::SUI");
function coinWithBalance({
  type = SUI_TYPE,
  balance,
  useGasCoin = true
}) {
  return (tx) => {
    tx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);
    const coinType = type === "gas" ? type : normalizeStructTag(type);
    return tx.add(
      Commands.Intent({
        name: COIN_WITH_BALANCE,
        inputs: {},
        data: {
          type: coinType === SUI_TYPE && useGasCoin ? "gas" : coinType,
          balance: BigInt(balance)
        }
      })
    );
  };
}
var CoinWithBalanceData = object({
  type: string(),
  balance: bigint()
});
async function resolveCoinBalance(transactionData, buildOptions, next) {
  var _a7, _b3, _c;
  const coinTypes = /* @__PURE__ */ new Set();
  const totalByType = /* @__PURE__ */ new Map();
  if (!transactionData.sender) {
    throw new Error("Sender must be set to resolve CoinWithBalance");
  }
  for (const command of transactionData.commands) {
    if (command.$kind === "$Intent" && command.$Intent.name === COIN_WITH_BALANCE) {
      const { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);
      if (type !== "gas" && balance > /* @__PURE__ */ BigInt("0")) {
        coinTypes.add(type);
      }
      totalByType.set(type, ((_a7 = totalByType.get(type)) != null ? _a7 : /* @__PURE__ */ BigInt("0")) + balance);
    }
  }
  const usedIds = /* @__PURE__ */ new Set();
  for (const input of transactionData.inputs) {
    if ((_b3 = input.Object) == null ? void 0 : _b3.ImmOrOwnedObject) {
      usedIds.add(input.Object.ImmOrOwnedObject.objectId);
    }
    if ((_c = input.UnresolvedObject) == null ? void 0 : _c.objectId) {
      usedIds.add(input.UnresolvedObject.objectId);
    }
  }
  const coinsByType = /* @__PURE__ */ new Map();
  const client = getClient(buildOptions);
  await Promise.all(
    [...coinTypes].map(async (coinType) => {
      coinsByType.set(
        coinType,
        await getCoinsOfType({
          coinType,
          balance: totalByType.get(coinType),
          client,
          owner: transactionData.sender,
          usedIds
        })
      );
    })
  );
  const mergedCoins = /* @__PURE__ */ new Map();
  mergedCoins.set("gas", { $kind: "GasCoin", GasCoin: true });
  for (const [index, transaction] of transactionData.commands.entries()) {
    if (transaction.$kind !== "$Intent" || transaction.$Intent.name !== COIN_WITH_BALANCE) {
      continue;
    }
    const { type, balance } = transaction.$Intent.data;
    if (balance === /* @__PURE__ */ BigInt("0")) {
      transactionData.replaceCommand(
        index,
        Commands.MoveCall({ target: "0x2::coin::zero", typeArguments: [type] })
      );
      continue;
    }
    const commands = [];
    if (!mergedCoins.has(type)) {
      const [first, ...rest] = coinsByType.get(type).map(
        (coin) => transactionData.addInput(
          "object",
          Inputs.ObjectRef({
            objectId: coin.coinObjectId,
            digest: coin.digest,
            version: coin.version
          })
        )
      );
      if (rest.length > 0) {
        commands.push(Commands.MergeCoins(first, rest));
      }
      mergedCoins.set(type, first);
    }
    commands.push(
      Commands.SplitCoins(mergedCoins.get(type), [
        transactionData.addInput("pure", Inputs.Pure(suiBcs.u64().serialize(balance)))
      ])
    );
    transactionData.replaceCommand(index, commands);
    transactionData.mapArguments((arg) => {
      if (arg.$kind === "Result" && arg.Result === index) {
        return {
          $kind: "NestedResult",
          NestedResult: [index + commands.length - 1, 0]
        };
      }
      return arg;
    });
  }
  return next();
}
async function getCoinsOfType({
  coinType,
  balance,
  client,
  owner,
  usedIds
}) {
  let remainingBalance = balance;
  const coins = [];
  return loadMoreCoins();
  async function loadMoreCoins(cursor = null) {
    const { data, hasNextPage, nextCursor } = await client.getCoins({ owner, coinType, cursor });
    const sortedCoins = data.sort((a, b2) => Number(BigInt(b2.balance) - BigInt(a.balance)));
    for (const coin of sortedCoins) {
      if (usedIds.has(coin.coinObjectId)) {
        continue;
      }
      const coinBalance = BigInt(coin.balance);
      coins.push(coin);
      remainingBalance -= coinBalance;
      if (remainingBalance <= 0) {
        return coins;
      }
    }
    if (hasNextPage) {
      return loadMoreCoins(nextCursor);
    }
    throw new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);
  }
}

// ../../node_modules/.pnpm/@nemoprotocol+wallet-kit@0.1.13_@mysten+sui@1.18.0_typescript@5.8.3__@types+react@18.3.21_rea_ubqeo4owumzpdcfyi2ksvjq2fy/node_modules/@nemoprotocol/wallet-kit/dist/index.js
var W = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/version.js
var PACKAGE_VERSION = "1.18.0";
var TARGETED_RPC_VERSION = "1.40.0";

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/client/errors.js
var CODE_TO_ERROR_TYPE = {
  "-32700": "ParseError",
  "-32701": "OversizedRequest",
  "-32702": "OversizedResponse",
  "-32600": "InvalidRequest",
  "-32601": "MethodNotFound",
  "-32602": "InvalidParams",
  "-32603": "InternalError",
  "-32604": "ServerBusy",
  "-32000": "CallExecutionFailed",
  "-32001": "UnknownError",
  "-32003": "SubscriptionClosed",
  "-32004": "SubscriptionClosedWithError",
  "-32005": "BatchesNotSupported",
  "-32006": "TooManySubscriptions",
  "-32050": "TransientError",
  "-32002": "TransactionExecutionClientError"
};
var SuiHTTPTransportError = class extends Error {
};
var JsonRpcError = class extends SuiHTTPTransportError {
  constructor(message, code) {
    var _a7;
    super(message);
    this.code = code;
    this.type = (_a7 = CODE_TO_ERROR_TYPE[code]) != null ? _a7 : "ServerError";
  }
};
var SuiHTTPStatusError = class extends SuiHTTPTransportError {
  constructor(message, status, statusText) {
    super(message);
    this.status = status;
    this.statusText = statusText;
  }
};

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/client/rpc-websocket-client.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet4 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
var __privateWrapper2 = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet4(obj, member, value, setter);
  },
  get _() {
    return __privateGet4(obj, member, getter);
  }
});
var _requestId;
var _disconnects;
var _webSocket;
var _connectionPromise;
var _subscriptions;
var _pendingRequests;
var _WebsocketClient_instances;
var setupWebSocket_fn;
var reconnect_fn;
function getWebsocketUrl(httpUrl) {
  const url = new URL(httpUrl);
  url.protocol = url.protocol.replace("http", "ws");
  return url.toString();
}
var DEFAULT_CLIENT_OPTIONS = {
  // We fudge the typing because we also check for undefined in the constructor:
  WebSocketConstructor: typeof WebSocket !== "undefined" ? WebSocket : void 0,
  callTimeout: 3e4,
  reconnectTimeout: 3e3,
  maxReconnects: 5
};
var WebsocketClient = class {
  constructor(endpoint, options = {}) {
    __privateAdd4(this, _WebsocketClient_instances);
    __privateAdd4(this, _requestId, 0);
    __privateAdd4(this, _disconnects, 0);
    __privateAdd4(this, _webSocket, null);
    __privateAdd4(this, _connectionPromise, null);
    __privateAdd4(this, _subscriptions, /* @__PURE__ */ new Set());
    __privateAdd4(this, _pendingRequests, /* @__PURE__ */ new Map());
    this.endpoint = endpoint;
    this.options = __spreadValues(__spreadValues({}, DEFAULT_CLIENT_OPTIONS), options);
    if (!this.options.WebSocketConstructor) {
      throw new Error("Missing WebSocket constructor");
    }
    if (this.endpoint.startsWith("http")) {
      this.endpoint = getWebsocketUrl(this.endpoint);
    }
  }
  async makeRequest(method, params) {
    const webSocket = await __privateMethod3(this, _WebsocketClient_instances, setupWebSocket_fn).call(this);
    return new Promise((resolve, reject) => {
      __privateSet4(this, _requestId, __privateGet4(this, _requestId) + 1);
      __privateGet4(this, _pendingRequests).set(__privateGet4(this, _requestId), {
        resolve,
        reject,
        timeout: setTimeout(() => {
          __privateGet4(this, _pendingRequests).delete(__privateGet4(this, _requestId));
          reject(new Error(`Request timeout: ${method}`));
        }, this.options.callTimeout)
      });
      webSocket.send(JSON.stringify({ jsonrpc: "2.0", id: __privateGet4(this, _requestId), method, params }));
    }).then(({ error, result }) => {
      if (error) {
        throw new JsonRpcError(error.message, error.code);
      }
      return result;
    });
  }
  async subscribe(input) {
    const subscription = new RpcSubscription(input);
    __privateGet4(this, _subscriptions).add(subscription);
    await subscription.subscribe(this);
    return () => subscription.unsubscribe(this);
  }
};
_requestId = /* @__PURE__ */ new WeakMap();
_disconnects = /* @__PURE__ */ new WeakMap();
_webSocket = /* @__PURE__ */ new WeakMap();
_connectionPromise = /* @__PURE__ */ new WeakMap();
_subscriptions = /* @__PURE__ */ new WeakMap();
_pendingRequests = /* @__PURE__ */ new WeakMap();
_WebsocketClient_instances = /* @__PURE__ */ new WeakSet();
setupWebSocket_fn = function() {
  if (__privateGet4(this, _connectionPromise)) {
    return __privateGet4(this, _connectionPromise);
  }
  __privateSet4(this, _connectionPromise, new Promise((resolve) => {
    var _a7;
    (_a7 = __privateGet4(this, _webSocket)) == null ? void 0 : _a7.close();
    __privateSet4(this, _webSocket, new this.options.WebSocketConstructor(this.endpoint));
    __privateGet4(this, _webSocket).addEventListener("open", () => {
      __privateSet4(this, _disconnects, 0);
      resolve(__privateGet4(this, _webSocket));
    });
    __privateGet4(this, _webSocket).addEventListener("close", () => {
      __privateWrapper2(this, _disconnects)._++;
      if (__privateGet4(this, _disconnects) <= this.options.maxReconnects) {
        setTimeout(() => {
          __privateMethod3(this, _WebsocketClient_instances, reconnect_fn).call(this);
        }, this.options.reconnectTimeout);
      }
    });
    __privateGet4(this, _webSocket).addEventListener("message", ({ data }) => {
      let json;
      try {
        json = JSON.parse(data);
      } catch (error) {
        console.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error }));
        return;
      }
      if ("id" in json && json.id != null && __privateGet4(this, _pendingRequests).has(json.id)) {
        const { resolve: resolve2, timeout } = __privateGet4(this, _pendingRequests).get(json.id);
        clearTimeout(timeout);
        resolve2(json);
      } else if ("params" in json) {
        const { params } = json;
        __privateGet4(this, _subscriptions).forEach((subscription) => {
          if (subscription.subscriptionId === params.subscription) {
            if (params.subscription === subscription.subscriptionId) {
              subscription.onMessage(params.result);
            }
          }
        });
      }
    });
  }));
  return __privateGet4(this, _connectionPromise);
};
reconnect_fn = async function() {
  var _a7;
  (_a7 = __privateGet4(this, _webSocket)) == null ? void 0 : _a7.close();
  __privateSet4(this, _connectionPromise, null);
  return Promise.allSettled(
    [...__privateGet4(this, _subscriptions)].map((subscription) => subscription.subscribe(this))
  );
};
var RpcSubscription = class {
  constructor(input) {
    this.subscriptionId = null;
    this.subscribed = false;
    this.input = input;
  }
  onMessage(message) {
    if (this.subscribed) {
      this.input.onMessage(message);
    }
  }
  async unsubscribe(client) {
    const { subscriptionId } = this;
    this.subscribed = false;
    if (subscriptionId == null) return false;
    this.subscriptionId = null;
    return client.makeRequest(this.input.unsubscribe, [subscriptionId]);
  }
  async subscribe(client) {
    this.subscriptionId = null;
    this.subscribed = true;
    const newSubscriptionId = await client.makeRequest(
      this.input.method,
      this.input.params
    );
    if (this.subscribed) {
      this.subscriptionId = newSubscriptionId;
    }
  }
};

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/client/http-transport.js
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet5 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var _requestId2;
var _options;
var _websocketClient;
var _SuiHTTPTransport_instances;
var getWebsocketClient_fn;
var SuiHTTPTransport = class {
  constructor(options) {
    __privateAdd5(this, _SuiHTTPTransport_instances);
    __privateAdd5(this, _requestId2, 0);
    __privateAdd5(this, _options);
    __privateAdd5(this, _websocketClient);
    __privateSet5(this, _options, options);
  }
  fetch(input, init) {
    var _a7;
    const fetchFn = (_a7 = __privateGet5(this, _options).fetch) != null ? _a7 : fetch;
    if (!fetchFn) {
      throw new Error(
        "The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport."
      );
    }
    return fetchFn(input, init);
  }
  async request(input) {
    var _a7, _b3, _c;
    __privateSet5(this, _requestId2, __privateGet5(this, _requestId2) + 1);
    const res = await this.fetch((_b3 = (_a7 = __privateGet5(this, _options).rpc) == null ? void 0 : _a7.url) != null ? _b3 : __privateGet5(this, _options).url, {
      method: "POST",
      headers: __spreadValues({
        "Content-Type": "application/json",
        "Client-Sdk-Type": "typescript",
        "Client-Sdk-Version": PACKAGE_VERSION,
        "Client-Target-Api-Version": TARGETED_RPC_VERSION,
        "Client-Request-Method": input.method
      }, (_c = __privateGet5(this, _options).rpc) == null ? void 0 : _c.headers),
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: __privateGet5(this, _requestId2),
        method: input.method,
        params: input.params
      })
    });
    if (!res.ok) {
      throw new SuiHTTPStatusError(
        `Unexpected status code: ${res.status}`,
        res.status,
        res.statusText
      );
    }
    const data = await res.json();
    if ("error" in data && data.error != null) {
      throw new JsonRpcError(data.error.message, data.error.code);
    }
    return data.result;
  }
  async subscribe(input) {
    const unsubscribe = await __privateMethod4(this, _SuiHTTPTransport_instances, getWebsocketClient_fn).call(this).subscribe(input);
    return async () => !!await unsubscribe();
  }
};
_requestId2 = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
_websocketClient = /* @__PURE__ */ new WeakMap();
_SuiHTTPTransport_instances = /* @__PURE__ */ new WeakSet();
getWebsocketClient_fn = function() {
  var _a7, _b3, _c;
  if (!__privateGet5(this, _websocketClient)) {
    const WebSocketConstructor = (_a7 = __privateGet5(this, _options).WebSocketConstructor) != null ? _a7 : WebSocket;
    if (!WebSocketConstructor) {
      throw new Error(
        "The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport."
      );
    }
    __privateSet5(this, _websocketClient, new WebsocketClient(
      (_c = (_b3 = __privateGet5(this, _options).websocket) == null ? void 0 : _b3.url) != null ? _c : __privateGet5(this, _options).url,
      __spreadValues({
        WebSocketConstructor
      }, __privateGet5(this, _options).websocket)
    ));
  }
  return __privateGet5(this, _websocketClient);
};

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/client/network.js
function getFullnodeUrl(network) {
  switch (network) {
    case "mainnet":
      return "https://fullnode.mainnet.sui.io:443";
    case "testnet":
      return "https://fullnode.testnet.sui.io:443";
    case "devnet":
      return "https://fullnode.devnet.sui.io:443";
    case "localnet":
      return "http://127.0.0.1:9000";
    default:
      throw new Error(`Unknown network: ${network}`);
  }
}

// ../../node_modules/.pnpm/@mysten+sui@1.18.0_typescript@5.8.3/node_modules/@mysten/sui/dist/esm/client/client.js
var SUI_CLIENT_BRAND = Symbol.for("@mysten/SuiClient");
var SuiClient = class {
  get [SUI_CLIENT_BRAND]() {
    return true;
  }
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(options) {
    var _a7;
    this.transport = (_a7 = options.transport) != null ? _a7 : new SuiHTTPTransport({ url: options.url });
  }
  async getRpcApiVersion() {
    const resp = await this.transport.request({
      method: "rpc.discover",
      params: []
    });
    return resp.info.version;
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getCoins",
      params: [input.owner, input.coinType, input.cursor, input.limit]
    });
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getAllCoins",
      params: [input.owner, input.cursor, input.limit]
    });
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getBalance",
      params: [input.owner, input.coinType]
    });
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({ method: "suix_getAllBalances", params: [input.owner] });
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata(input) {
    return await this.transport.request({
      method: "suix_getCoinMetadata",
      params: [input.coinType]
    });
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply(input) {
    return await this.transport.request({
      method: "suix_getTotalSupply",
      params: [input.coinType]
    });
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(method, params) {
    return await this.transport.request({ method, params });
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes(input) {
    return await this.transport.request({
      method: "sui_getMoveFunctionArgTypes",
      params: [input.package, input.module, input.function]
    });
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModulesByPackage",
      params: [input.package]
    });
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModule",
      params: [input.package, input.module]
    });
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveFunction",
      params: [input.package, input.module, input.function]
    });
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveStruct",
      params: [input.package, input.module, input.struct]
    });
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getOwnedObjects",
      params: [
        input.owner,
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit
      ]
    });
  }
  /**
   * Get details about an object
   */
  async getObject(input) {
    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "sui_getObject",
      params: [input.id, input.options]
    });
  }
  async tryGetPastObject(input) {
    return await this.transport.request({
      method: "sui_tryGetPastObject",
      params: [input.id, input.version, input.options]
    });
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(input) {
    input.ids.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Object id ${id}`);
      }
    });
    const hasDuplicates = input.ids.length !== new Set(input.ids).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate object ids in batch call ${input.ids}`);
    }
    return await this.transport.request({
      method: "sui_multiGetObjects",
      params: [input.ids, input.options]
    });
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks(input) {
    return await this.transport.request({
      method: "suix_queryTransactionBlocks",
      params: [
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ]
    });
  }
  async getTransactionBlock(input) {
    if (!isValidTransactionDigest(input.digest)) {
      throw new Error("Invalid Transaction digest");
    }
    return await this.transport.request({
      method: "sui_getTransactionBlock",
      params: [input.digest, input.options]
    });
  }
  async multiGetTransactionBlocks(input) {
    input.digests.forEach((d) => {
      if (!isValidTransactionDigest(d)) {
        throw new Error(`Invalid Transaction digest ${d}`);
      }
    });
    const hasDuplicates = input.digests.length !== new Set(input.digests).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate digests in batch call ${input.digests}`);
    }
    return await this.transport.request({
      method: "sui_multiGetTransactionBlocks",
      params: [input.digests, input.options]
    });
  }
  async executeTransactionBlock({
    transactionBlock,
    signature,
    options,
    requestType
  }) {
    const result = await this.transport.request({
      method: "sui_executeTransactionBlock",
      params: [
        typeof transactionBlock === "string" ? transactionBlock : toBase64(transactionBlock),
        Array.isArray(signature) ? signature : [signature],
        options
      ]
    });
    if (requestType === "WaitForLocalExecution") {
      try {
        await this.waitForTransaction({
          digest: result.digest
        });
      } catch (_) {
      }
    }
    return result;
  }
  async signAndExecuteTransaction(_a7) {
    var _b3 = _a7, {
      transaction,
      signer
    } = _b3, input = __objRest(_b3, [
      "transaction",
      "signer"
    ]);
    let transactionBytes;
    if (transaction instanceof Uint8Array) {
      transactionBytes = transaction;
    } else {
      transaction.setSenderIfNotSet(signer.toSuiAddress());
      transactionBytes = await transaction.build({ client: this });
    }
    const { signature, bytes } = await signer.signTransaction(transactionBytes);
    return this.executeTransactionBlock(__spreadValues({
      transactionBlock: bytes,
      signature
    }, input));
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks() {
    const resp = await this.transport.request({
      method: "sui_getTotalTransactionBlocks",
      params: []
    });
    return BigInt(resp);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice() {
    const resp = await this.transport.request({
      method: "suix_getReferenceGasPrice",
      params: []
    });
    return BigInt(resp);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({ method: "suix_getStakes", params: [input.owner] });
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(input) {
    input.stakedSuiIds.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Stake id ${id}`);
      }
    });
    return await this.transport.request({
      method: "suix_getStakesByIds",
      params: [input.stakedSuiIds]
    });
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState() {
    return await this.transport.request({ method: "suix_getLatestSuiSystemState", params: [] });
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents(input) {
    return await this.transport.request({
      method: "suix_queryEvents",
      params: [
        input.query,
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ]
    });
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   *
   * @deprecated
   */
  async subscribeEvent(input) {
    return this.transport.subscribe({
      method: "suix_subscribeEvent",
      unsubscribe: "suix_unsubscribeEvent",
      params: [input.filter],
      onMessage: input.onMessage
    });
  }
  /**
   * @deprecated
   */
  async subscribeTransaction(input) {
    return this.transport.subscribe({
      method: "suix_subscribeTransaction",
      unsubscribe: "suix_unsubscribeTransaction",
      params: [input.filter],
      onMessage: input.onMessage
    });
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(input) {
    var _a7;
    let devInspectTxBytes;
    if (isTransaction(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(input.sender);
      devInspectTxBytes = toBase64(
        await input.transactionBlock.build({
          client: this,
          onlyTransactionKind: true
        })
      );
    } else if (typeof input.transactionBlock === "string") {
      devInspectTxBytes = input.transactionBlock;
    } else if (input.transactionBlock instanceof Uint8Array) {
      devInspectTxBytes = toBase64(input.transactionBlock);
    } else {
      throw new Error("Unknown transaction block format.");
    }
    return await this.transport.request({
      method: "sui_devInspectTransactionBlock",
      params: [input.sender, devInspectTxBytes, (_a7 = input.gasPrice) == null ? void 0 : _a7.toString(), input.epoch]
    });
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(input) {
    return await this.transport.request({
      method: "sui_dryRunTransactionBlock",
      params: [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toBase64(input.transactionBlock)
      ]
    });
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(input) {
    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "suix_getDynamicFields",
      params: [input.parentId, input.cursor, input.limit]
    });
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(input) {
    return await this.transport.request({
      method: "suix_getDynamicFieldObject",
      params: [input.parentId, input.name]
    });
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber() {
    const resp = await this.transport.request({
      method: "sui_getLatestCheckpointSequenceNumber",
      params: []
    });
    return String(resp);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(input) {
    return await this.transport.request({ method: "sui_getCheckpoint", params: [input.id] });
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(input) {
    return await this.transport.request({
      method: "sui_getCheckpoints",
      params: [input.cursor, input == null ? void 0 : input.limit, input.descendingOrder]
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(input) {
    return await this.transport.request({
      method: "suix_getCommitteeInfo",
      params: [input == null ? void 0 : input.epoch]
    });
  }
  async getNetworkMetrics() {
    return await this.transport.request({ method: "suix_getNetworkMetrics", params: [] });
  }
  async getAddressMetrics() {
    return await this.transport.request({ method: "suix_getLatestAddressMetrics", params: [] });
  }
  async getEpochMetrics(input) {
    return await this.transport.request({
      method: "suix_getEpochMetrics",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder]
    });
  }
  async getAllEpochAddressMetrics(input) {
    return await this.transport.request({
      method: "suix_getAllEpochAddressMetrics",
      params: [input == null ? void 0 : input.descendingOrder]
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(input) {
    return await this.transport.request({
      method: "suix_getEpochs",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder]
    });
  }
  /**
   * Returns list of top move calls by usage
   */
  async getMoveCallMetrics() {
    return await this.transport.request({ method: "suix_getMoveCallMetrics", params: [] });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch() {
    return await this.transport.request({ method: "suix_getCurrentEpoch", params: [] });
  }
  /**
   * Return the Validators APYs
   */
  async getValidatorsApy() {
    return await this.transport.request({ method: "suix_getValidatorsApy", params: [] });
  }
  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.
  async getChainIdentifier() {
    const checkpoint = await this.getCheckpoint({ id: "0" });
    const bytes = fromBase58(checkpoint.digest);
    return toHex(bytes.slice(0, 4));
  }
  async resolveNameServiceAddress(input) {
    return await this.transport.request({
      method: "suix_resolveNameServiceAddress",
      params: [input.name]
    });
  }
  async resolveNameServiceNames(_c) {
    var _d = _c, {
      format = "dot"
    } = _d, input = __objRest(_d, [
      "format"
    ]);
    const { nextCursor, hasNextPage, data } = await this.transport.request({
      method: "suix_resolveNameServiceNames",
      params: [input.address, input.cursor, input.limit]
    });
    return {
      hasNextPage,
      nextCursor,
      data: data.map((name) => normalizeSuiNSName(name, format))
    };
  }
  async getProtocolConfig(input) {
    return await this.transport.request({
      method: "sui_getProtocolConfig",
      params: [input == null ? void 0 : input.version]
    });
  }
  /**
   * Wait for a transaction block result to be available over the API.
   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
   * be available via the API.
   * This currently polls the `getTransactionBlock` API to check for the transaction.
   */
  async waitForTransaction(_e3) {
    var _f = _e3, {
      signal,
      timeout = 60 * 1e3,
      pollInterval = 2 * 1e3
    } = _f, input = __objRest(_f, [
      "signal",
      "timeout",
      "pollInterval"
    ]);
    const timeoutSignal = AbortSignal.timeout(timeout);
    const timeoutPromise = new Promise((_, reject) => {
      timeoutSignal.addEventListener("abort", () => reject(timeoutSignal.reason));
    });
    timeoutPromise.catch(() => {
    });
    while (!timeoutSignal.aborted) {
      signal == null ? void 0 : signal.throwIfAborted();
      try {
        return await this.getTransactionBlock(input);
      } catch (e) {
        await Promise.race([
          new Promise((resolve) => setTimeout(resolve, pollInterval)),
          timeoutPromise
        ]);
      }
    }
    timeoutSignal.throwIfAborted();
    throw new Error("Unexpected error while waiting for transaction block.");
  }
};

// ../../node_modules/.pnpm/@nemoprotocol+wallet-kit@0.1.13_@mysten+sui@1.18.0_typescript@5.8.3__@types+react@18.3.21_rea_ubqeo4owumzpdcfyi2ksvjq2fy/node_modules/@nemoprotocol/wallet-kit/dist/index.js
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var Yo = Object.defineProperty;
var Fo = (e, t, n) => t in e ? Yo(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var J = (e, t, n) => (Fo(e, typeof t != "symbol" ? t + "" : t, n), n);
var Zo = class extends TypeError {
  constructor(t, n) {
    let r2;
    const _a7 = t, { message: o, explanation: s } = _a7, l = __objRest(_a7, ["message", "explanation"]), { path: c } = t, f = c.length === 0 ? o : `At path: ${c.join(".")} -- ${o}`;
    super(s != null ? s : f), s != null && (this.cause = f), Object.assign(this, l), this.name = this.constructor.name, this.failures = () => r2 != null ? r2 : r2 = [t, ...n()];
  }
};
function Go(e) {
  return je(e) && typeof e[Symbol.iterator] == "function";
}
function je(e) {
  return typeof e == "object" && e != null;
}
function Ue(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function Vo(e) {
  const { done: t, value: n } = e.next();
  return t ? void 0 : n;
}
function qo(e, t, n, r2) {
  if (e === true)
    return;
  e === false ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: o, branch: s } = t, { type: l } = n, { refinement: c, message: f = `Expected a value of type \`${l}\`${c ? ` with refinement \`${c}\`` : ""}, but received: \`${Ue(r2)}\`` } = e;
  return __spreadProps(__spreadValues({
    value: r2,
    type: l,
    refinement: c,
    key: o[o.length - 1],
    path: o,
    branch: s
  }, e), {
    message: f
  });
}
function* _r(e, t, n, r2) {
  Go(e) || (e = [e]);
  for (const o of e) {
    const s = qo(o, t, n, r2);
    s && (yield s);
  }
}
function* Lr(e, t, n = {}) {
  const { path: r2 = [], branch: o = [e], coerce: s = false, mask: l = false } = n, c = { path: r2, branch: o };
  if (s && (e = t.coercer(e, c), l && t.type !== "type" && je(t.schema) && je(e) && !Array.isArray(e)))
    for (const h in e)
      t.schema[h] === void 0 && delete e[h];
  let f = "valid";
  for (const h of t.validator(e, c))
    h.explanation = n.message, f = "not_valid", yield [h, void 0];
  for (let [h, g, M2] of t.entries(e, c)) {
    const A = Lr(g, M2, {
      path: h === void 0 ? r2 : [...r2, h],
      branch: h === void 0 ? o : [...o, g],
      coerce: s,
      mask: l,
      message: n.message
    });
    for (const N of A)
      N[0] ? (f = N[0].refinement != null ? "not_refined" : "not_valid", yield [N[0], void 0]) : s && (g = N[1], h === void 0 ? e = g : e instanceof Map ? e.set(h, g) : e instanceof Set ? e.add(g) : je(e) && (g !== void 0 || h in e) && (e[h] = g));
  }
  if (f !== "not_valid")
    for (const h of t.refiner(e, c))
      h.explanation = n.message, f = "not_refined", yield [h, void 0];
  f === "valid" && (yield [void 0, e]);
}
var Be = class {
  constructor(t) {
    const { type: n, schema: r2, validator: o, refiner: s, coercer: l = (f) => f, entries: c = function* () {
    } } = t;
    this.type = n, this.schema = r2, this.entries = c, this.coercer = l, o ? this.validator = (f, h) => {
      const g = o(f, h);
      return _r(g, h, this, f);
    } : this.validator = () => [], s ? this.refiner = (f, h) => {
      const g = s(f, h);
      return _r(g, h, this, f);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t, n) {
    return Xo(t, this, n);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t, n) {
    return _o(t, this, n);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t) {
    return Ko(t, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t, n) {
    return Ho(t, this, n);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t, n = {}) {
    return Yt(t, this, n);
  }
};
function Xo(e, t, n) {
  const r2 = Yt(e, t, { message: n });
  if (r2[0])
    throw r2[0];
}
function _o(e, t, n) {
  const r2 = Yt(e, t, { coerce: true, message: n });
  if (r2[0])
    throw r2[0];
  return r2[1];
}
function Ho(e, t, n) {
  const r2 = Yt(e, t, { coerce: true, mask: true, message: n });
  if (r2[0])
    throw r2[0];
  return r2[1];
}
function Ko(e, t) {
  return !Yt(e, t)[0];
}
function Yt(e, t, n = {}) {
  const r2 = Lr(e, t, n), o = Vo(r2);
  return o[0] ? [new Zo(o[0], function* () {
    for (const s of r2)
      s[0] && (yield s[0]);
  }), void 0] : [void 0, o[1]];
}
function Qt(...e) {
  const t = e[0].type === "type", n = e.map((o) => o.schema), r2 = Object.assign({}, ...n);
  return t ? ts(r2) : U(r2);
}
function et(e, t) {
  return new Be({ type: e, schema: null, validator: t });
}
function Jo() {
  return et("any", () => true);
}
function Sr(e) {
  return new Be({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [n, r2] of t.entries())
          yield [n, r2, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array value, but received: ${Ue(t)}`;
    }
  });
}
function $o() {
  return et("bigint", (e) => typeof e == "bigint");
}
function xe() {
  return et("boolean", (e) => typeof e == "boolean");
}
function ve(e) {
  const t = Ue(e), n = typeof e;
  return new Be({
    type: "literal",
    schema: n === "string" || n === "number" || n === "boolean" ? e : null,
    validator(r2) {
      return r2 === e || `Expected the literal \`${t}\`, but received: ${Ue(r2)}`;
    }
  });
}
function Ti() {
  return et("never", () => false);
}
function H(e) {
  return new Be(__spreadProps(__spreadValues({}, e), {
    validator: (t, n) => t === null || e.validator(t, n),
    refiner: (t, n) => t === null || e.refiner(t, n)
  }));
}
function xt() {
  return et("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${Ue(e)}`);
}
function U(e) {
  const t = e ? Object.keys(e) : [], n = Ti();
  return new Be({
    type: "object",
    schema: e || null,
    *entries(r2) {
      if (e && je(r2)) {
        const o = new Set(Object.keys(r2));
        for (const s of t)
          o.delete(s), yield [s, r2[s], e[s]];
        for (const s of o)
          yield [s, r2[s], n];
      }
    },
    validator(r2) {
      return je(r2) || `Expected an object, but received: ${Ue(r2)}`;
    },
    coercer(r2) {
      return je(r2) ? __spreadValues({}, r2) : r2;
    }
  });
}
function F(e) {
  return new Be(__spreadProps(__spreadValues({}, e), {
    validator: (t, n) => t === void 0 || e.validator(t, n),
    refiner: (t, n) => t === void 0 || e.refiner(t, n)
  }));
}
function at(e, t) {
  return new Be({
    type: "record",
    schema: null,
    *entries(n) {
      if (je(n))
        for (const r2 in n) {
          const o = n[r2];
          yield [r2, r2, e], yield [r2, o, t];
        }
    },
    validator(n) {
      return je(n) || `Expected an object, but received: ${Ue(n)}`;
    }
  });
}
function j() {
  return et("string", (e) => typeof e == "string" || `Expected a string, but received: ${Ue(e)}`);
}
function es(e) {
  const t = Ti();
  return new Be({
    type: "tuple",
    schema: null,
    *entries(n) {
      if (Array.isArray(n)) {
        const r2 = Math.max(e.length, n.length);
        for (let o = 0; o < r2; o++)
          yield [o, n[o], e[o] || t];
      }
    },
    validator(n) {
      return Array.isArray(n) || `Expected an array, but received: ${Ue(n)}`;
    }
  });
}
function ts(e) {
  const t = Object.keys(e);
  return new Be({
    type: "type",
    schema: e,
    *entries(n) {
      if (je(n))
        for (const r2 of t)
          yield [r2, n[r2], e[r2]];
    },
    validator(n) {
      return je(n) || `Expected an object, but received: ${Ue(n)}`;
    },
    coercer(n) {
      return je(n) ? __spreadValues({}, n) : n;
    }
  });
}
function Ze(e) {
  const t = e.map((n) => n.type).join(" | ");
  return new Be({
    type: "union",
    schema: null,
    coercer(n) {
      for (const r2 of e) {
        const [o, s] = r2.validate(n, { coerce: true });
        if (!o)
          return s;
      }
      return n;
    },
    validator(n, r2) {
      const o = [];
      for (const s of e) {
        const [...l] = Lr(n, s, r2), [c] = l;
        if (c[0])
          for (const [f] of l)
            f && o.push(f);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t}\`, but received: ${Ue(n)}`,
        ...o
      ];
    }
  });
}
function ns() {
  return et("unknown", () => true);
}
var Or = Ze([
  U({
    AddressOwner: j()
  }),
  U({
    ObjectOwner: j()
  }),
  U({
    Shared: U({
      initial_shared_version: H(j())
    })
  }),
  ve("Immutable")
]);
et("SuiJsonValue", () => true);
var rs = Ze([
  U({ u32: j() }),
  U({ u64: j() }),
  U({ f64: j() })
]);
U({
  attributes: at(j(), H(rs)),
  featureFlags: at(j(), xe()),
  maxSupportedProtocolVersion: j(),
  minSupportedProtocolVersion: j(),
  protocolVersion: j()
});
Ze([j(), ve("package")]);
var Qn = U({
  /** Base64 string representing the object digest */
  digest: j(),
  /** Hex code as string representing the object id */
  objectId: j(),
  /** Object version */
  version: Ze([xt(), j(), $o()])
});
U({
  owner: Or,
  reference: Qn
});
U({
  objectId: j(),
  sequenceNumber: j()
});
U({
  payment: Sr(Qn),
  /** Gas Object's owner */
  owner: j(),
  price: j(),
  budget: j()
});
var is2 = Qt(
  Qn,
  U({
    type: j(),
    owner: Or,
    previousTransaction: j()
  })
);
var os = at(j(), Jo());
var ss = at(j(), ns());
var as = U({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: j(),
  /** Fields and values stored inside the Move object */
  fields: os,
  hasPublicTransfer: xe()
});
var cs = U({
  /** A mapping from module name to disassembled Move bytecode */
  disassembled: ss
});
var us = Ze([
  Qt(as, U({ dataType: ve("moveObject") })),
  Qt(cs, U({ dataType: ve("package") }))
]);
var ls = U({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: j(),
  hasPublicTransfer: xe(),
  version: j(),
  bcsBytes: j()
});
var fs = U({
  id: j(),
  /** A mapping from module name to Move bytecode enocded in base64*/
  moduleMap: at(j(), j())
});
var ds = Ze([
  Qt(ls, U({ dataType: ve("moveObject") })),
  Qt(fs, U({ dataType: ve("package") }))
]);
BigInt(1e9);
var Ci = U({
  code: j(),
  error: F(j()),
  object_id: F(j()),
  parent_object_id: F(j()),
  version: F(j()),
  digest: F(j())
});
var hs = U({
  data: H(F(at(j(), j()))),
  error: H(F(Ci))
});
var gs = Ze([
  hs,
  F(at(j(), j()))
]);
var Li = U({
  objectId: j(),
  version: j(),
  digest: j(),
  /**
   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true
   */
  type: H(F(j())),
  /**
   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true
   */
  content: H(F(us)),
  /**
   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true
   */
  bcs: H(F(ds)),
  /**
   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true
   */
  owner: H(F(Or)),
  /**
   * The digest of the transaction that created or last mutated this object.
   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true
   */
  previousTransaction: H(F(j())),
  /**
   * The amount of SUI we would rebate if this object gets deleted.
   * This number is re-calculated each time the object is mutated based on
   * the present storage gas price.
   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true
   */
  storageRebate: H(F(j())),
  /**
   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true
   * This can also be None if the struct type does not have Display defined
   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872
   */
  display: H(F(gs))
});
U({
  /* Whether to fetch the object type, default to be true */
  showType: H(F(xe())),
  /* Whether to fetch the object content, default to be false */
  showContent: H(F(xe())),
  /* Whether to fetch the object content in BCS bytes, default to be false */
  showBcs: H(F(xe())),
  /* Whether to fetch the object owner, default to be false */
  showOwner: H(F(xe())),
  /* Whether to fetch the previous transaction digest, default to be false */
  showPreviousTransaction: H(F(xe())),
  /* Whether to fetch the storage rebate, default to be false */
  showStorageRebate: H(F(xe())),
  /* Whether to fetch the display metadata, default to be false */
  showDisplay: H(F(xe()))
});
Ze([
  ve("Exists"),
  ve("notExists"),
  ve("Deleted")
]);
Sr(is2);
var ys = U({
  data: H(F(Li)),
  error: H(F(Ci))
});
U({
  objectId: j(),
  atCheckpoint: F(xt())
});
U({
  data: Sr(ys),
  nextCursor: F(H(j())),
  hasNextPage: xe()
});
Ze([
  U({
    details: Li,
    status: ve("VersionFound")
  }),
  U({
    details: j(),
    status: ve("ObjectNotExists")
  }),
  U({
    details: Qn,
    status: ve("ObjectDeleted")
  }),
  U({
    details: es([j(), xt()]),
    status: ve("VersionNotFound")
  }),
  U({
    details: U({
      asked_version: xt(),
      latest_version: xt(),
      object_id: j()
    }),
    status: ve("VersionTooHigh")
  })
]);
var Oe = /* @__PURE__ */ ((e) => (e.DISCONNECTED = "disconnected", e.CONNECTED = "connected", e.CONNECTING = "connecting", e))(Oe || {});
var $t = {};
var Wn = {};
Wn.byteLength = Ps;
Wn.toByteArray = Ws;
Wn.fromByteArray = Fs;
var Qe = [];
var De = [];
var Us = typeof Uint8Array < "u" ? Uint8Array : Array;
var Jn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (gt2 = 0, ks = Jn.length; gt2 < ks; ++gt2)
  Qe[gt2] = Jn[gt2], De[Jn.charCodeAt(gt2)] = gt2;
var gt2;
var ks;
De[45] = 62;
De[95] = 63;
function ki(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e.indexOf("=");
  n === -1 && (n = t);
  var r2 = n === t ? 0 : 4 - n % 4;
  return [n, r2];
}
function Ps(e) {
  var t = ki(e), n = t[0], r2 = t[1];
  return (n + r2) * 3 / 4 - r2;
}
function Qs(e, t, n) {
  return (t + n) * 3 / 4 - n;
}
function Ws(e) {
  var t, n = ki(e), r2 = n[0], o = n[1], s = new Us(Qs(e, r2, o)), l = 0, c = o > 0 ? r2 - 4 : r2, f;
  for (f = 0; f < c; f += 4)
    t = De[e.charCodeAt(f)] << 18 | De[e.charCodeAt(f + 1)] << 12 | De[e.charCodeAt(f + 2)] << 6 | De[e.charCodeAt(f + 3)], s[l++] = t >> 16 & 255, s[l++] = t >> 8 & 255, s[l++] = t & 255;
  return o === 2 && (t = De[e.charCodeAt(f)] << 2 | De[e.charCodeAt(f + 1)] >> 4, s[l++] = t & 255), o === 1 && (t = De[e.charCodeAt(f)] << 10 | De[e.charCodeAt(f + 1)] << 4 | De[e.charCodeAt(f + 2)] >> 2, s[l++] = t >> 8 & 255, s[l++] = t & 255), s;
}
function Bs(e) {
  return Qe[e >> 18 & 63] + Qe[e >> 12 & 63] + Qe[e >> 6 & 63] + Qe[e & 63];
}
function Ys(e, t, n) {
  for (var r2, o = [], s = t; s < n; s += 3)
    r2 = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), o.push(Bs(r2));
  return o.join("");
}
function Fs(e) {
  for (var t, n = e.length, r2 = n % 3, o = [], s = 16383, l = 0, c = n - r2; l < c; l += s)
    o.push(Ys(e, l, l + s > c ? c : l + s));
  return r2 === 1 ? (t = e[n - 1], o.push(
    Qe[t >> 2] + Qe[t << 4 & 63] + "=="
  )) : r2 === 2 && (t = (e[n - 2] << 8) + e[n - 1], o.push(
    Qe[t >> 10] + Qe[t >> 4 & 63] + Qe[t << 2 & 63] + "="
  )), o.join("");
}
var zr = {};
zr.read = function(e, t, n, r2, o) {
  var s, l, c = o * 8 - r2 - 1, f = (1 << c) - 1, h = f >> 1, g = -7, M2 = n ? o - 1 : 0, A = n ? -1 : 1, N = e[t + M2];
  for (M2 += A, s = N & (1 << -g) - 1, N >>= -g, g += c; g > 0; s = s * 256 + e[t + M2], M2 += A, g -= 8)
    ;
  for (l = s & (1 << -g) - 1, s >>= -g, g += r2; g > 0; l = l * 256 + e[t + M2], M2 += A, g -= 8)
    ;
  if (s === 0)
    s = 1 - h;
  else {
    if (s === f)
      return l ? NaN : (N ? -1 : 1) * (1 / 0);
    l = l + Math.pow(2, r2), s = s - h;
  }
  return (N ? -1 : 1) * l * Math.pow(2, s - r2);
};
zr.write = function(e, t, n, r2, o, s) {
  var l, c, f, h = s * 8 - o - 1, g = (1 << h) - 1, M2 = g >> 1, A = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, N = r2 ? 0 : s - 1, I2 = r2 ? 1 : -1, v = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (c = isNaN(t) ? 1 : 0, l = g) : (l = Math.floor(Math.log(t) / Math.LN2), t * (f = Math.pow(2, -l)) < 1 && (l--, f *= 2), l + M2 >= 1 ? t += A / f : t += A * Math.pow(2, 1 - M2), t * f >= 2 && (l++, f /= 2), l + M2 >= g ? (c = 0, l = g) : l + M2 >= 1 ? (c = (t * f - 1) * Math.pow(2, o), l = l + M2) : (c = t * Math.pow(2, M2 - 1) * Math.pow(2, o), l = 0)); o >= 8; e[n + N] = c & 255, N += I2, c /= 256, o -= 8)
    ;
  for (l = l << o | c, h += o; h > 0; e[n + N] = l & 255, N += I2, l /= 256, h -= 8)
    ;
  e[n + N - I2] |= v * 128;
};
(function(e) {
  const t = Wn, n = zr, r2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = c, e.SlowBuffer = x2, e.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  e.kMaxLength = o, c.TYPED_ARRAY_SUPPORT = s(), !c.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const i = new Uint8Array(1), a = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(a, Uint8Array.prototype), Object.setPrototypeOf(i, a), i.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(c.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (c.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(c.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (c.isBuffer(this))
        return this.byteOffset;
    }
  });
  function l(i) {
    if (i > o)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
    const a = new Uint8Array(i);
    return Object.setPrototypeOf(a, c.prototype), a;
  }
  function c(i, a, u) {
    if (typeof i == "number") {
      if (typeof a == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return M2(i);
    }
    return f(i, a, u);
  }
  c.poolSize = 8192;
  function f(i, a, u) {
    if (typeof i == "string")
      return A(i, a);
    if (ArrayBuffer.isView(i))
      return I2(i);
    if (i == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i
      );
    if (ke2(i, ArrayBuffer) || i && ke2(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ke2(i, SharedArrayBuffer) || i && ke2(i.buffer, SharedArrayBuffer)))
      return v(i, a, u);
    if (typeof i == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const d = i.valueOf && i.valueOf();
    if (d != null && d !== i)
      return c.from(d, a, u);
    const y = b2(i);
    if (y)
      return y;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
      return c.from(i[Symbol.toPrimitive]("string"), a, u);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i
    );
  }
  c.from = function(i, a, u) {
    return f(i, a, u);
  }, Object.setPrototypeOf(c.prototype, Uint8Array.prototype), Object.setPrototypeOf(c, Uint8Array);
  function h(i) {
    if (typeof i != "number")
      throw new TypeError('"size" argument must be of type number');
    if (i < 0)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
  }
  function g(i, a, u) {
    return h(i), i <= 0 ? l(i) : a !== void 0 ? typeof u == "string" ? l(i).fill(a, u) : l(i).fill(a) : l(i);
  }
  c.alloc = function(i, a, u) {
    return g(i, a, u);
  };
  function M2(i) {
    return h(i), l(i < 0 ? 0 : D(i) | 0);
  }
  c.allocUnsafe = function(i) {
    return M2(i);
  }, c.allocUnsafeSlow = function(i) {
    return M2(i);
  };
  function A(i, a) {
    if ((typeof a != "string" || a === "") && (a = "utf8"), !c.isEncoding(a))
      throw new TypeError("Unknown encoding: " + a);
    const u = E2(i, a) | 0;
    let d = l(u);
    const y = d.write(i, a);
    return y !== u && (d = d.slice(0, y)), d;
  }
  function N(i) {
    const a = i.length < 0 ? 0 : D(i.length) | 0, u = l(a);
    for (let d = 0; d < a; d += 1)
      u[d] = i[d] & 255;
    return u;
  }
  function I2(i) {
    if (ke2(i, Uint8Array)) {
      const a = new Uint8Array(i);
      return v(a.buffer, a.byteOffset, a.byteLength);
    }
    return N(i);
  }
  function v(i, a, u) {
    if (a < 0 || i.byteLength < a)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (i.byteLength < a + (u || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let d;
    return a === void 0 && u === void 0 ? d = new Uint8Array(i) : u === void 0 ? d = new Uint8Array(i, a) : d = new Uint8Array(i, a, u), Object.setPrototypeOf(d, c.prototype), d;
  }
  function b2(i) {
    if (c.isBuffer(i)) {
      const a = D(i.length) | 0, u = l(a);
      return u.length === 0 || i.copy(u, 0, 0, a), u;
    }
    if (i.length !== void 0)
      return typeof i.length != "number" || qn2(i.length) ? l(0) : N(i);
    if (i.type === "Buffer" && Array.isArray(i.data))
      return N(i.data);
  }
  function D(i) {
    if (i >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return i | 0;
  }
  function x2(i) {
    return +i != i && (i = 0), c.alloc(+i);
  }
  c.isBuffer = function(i) {
    return i != null && i._isBuffer === true && i !== c.prototype;
  }, c.compare = function(i, a) {
    if (ke2(i, Uint8Array) && (i = c.from(i, i.offset, i.byteLength)), ke2(a, Uint8Array) && (a = c.from(a, a.offset, a.byteLength)), !c.isBuffer(i) || !c.isBuffer(a))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (i === a)
      return 0;
    let u = i.length, d = a.length;
    for (let y = 0, p = Math.min(u, d); y < p; ++y)
      if (i[y] !== a[y]) {
        u = i[y], d = a[y];
        break;
      }
    return u < d ? -1 : d < u ? 1 : 0;
  }, c.isEncoding = function(i) {
    switch (String(i).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, c.concat = function(i, a) {
    if (!Array.isArray(i))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (i.length === 0)
      return c.alloc(0);
    let u;
    if (a === void 0)
      for (a = 0, u = 0; u < i.length; ++u)
        a += i[u].length;
    const d = c.allocUnsafe(a);
    let y = 0;
    for (u = 0; u < i.length; ++u) {
      let p = i[u];
      if (ke2(p, Uint8Array))
        y + p.length > d.length ? (c.isBuffer(p) || (p = c.from(p)), p.copy(d, y)) : Uint8Array.prototype.set.call(
          d,
          p,
          y
        );
      else if (c.isBuffer(p))
        p.copy(d, y);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      y += p.length;
    }
    return d;
  };
  function E2(i, a) {
    if (c.isBuffer(i))
      return i.length;
    if (ArrayBuffer.isView(i) || ke2(i, ArrayBuffer))
      return i.byteLength;
    if (typeof i != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i
      );
    const u = i.length, d = arguments.length > 2 && arguments[2] === true;
    if (!d && u === 0)
      return 0;
    let y = false;
    for (; ; )
      switch (a) {
        case "ascii":
        case "latin1":
        case "binary":
          return u;
        case "utf8":
        case "utf-8":
          return Vn(i).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return u * 2;
        case "hex":
          return u >>> 1;
        case "base64":
          return Xr(i).length;
        default:
          if (y)
            return d ? -1 : Vn(i).length;
          a = ("" + a).toLowerCase(), y = true;
      }
  }
  c.byteLength = E2;
  function L(i, a, u) {
    let d = false;
    if ((a === void 0 || a < 0) && (a = 0), a > this.length || ((u === void 0 || u > this.length) && (u = this.length), u <= 0) || (u >>>= 0, a >>>= 0, u <= a))
      return "";
    for (i || (i = "utf8"); ; )
      switch (i) {
        case "hex":
          return O2(this, a, u);
        case "utf8":
        case "utf-8":
          return Ae2(this, a, u);
        case "ascii":
          return T2(this, a, u);
        case "latin1":
        case "binary":
          return S2(this, a, u);
        case "base64":
          return Ce2(this, a, u);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return V2(this, a, u);
        default:
          if (d)
            throw new TypeError("Unknown encoding: " + i);
          i = (i + "").toLowerCase(), d = true;
      }
  }
  c.prototype._isBuffer = true;
  function z(i, a, u) {
    const d = i[a];
    i[a] = i[u], i[u] = d;
  }
  c.prototype.swap16 = function() {
    const i = this.length;
    if (i % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let a = 0; a < i; a += 2)
      z(this, a, a + 1);
    return this;
  }, c.prototype.swap32 = function() {
    const i = this.length;
    if (i % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let a = 0; a < i; a += 4)
      z(this, a, a + 3), z(this, a + 1, a + 2);
    return this;
  }, c.prototype.swap64 = function() {
    const i = this.length;
    if (i % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let a = 0; a < i; a += 8)
      z(this, a, a + 7), z(this, a + 1, a + 6), z(this, a + 2, a + 5), z(this, a + 3, a + 4);
    return this;
  }, c.prototype.toString = function() {
    const i = this.length;
    return i === 0 ? "" : arguments.length === 0 ? Ae2(this, 0, i) : L.apply(this, arguments);
  }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(i) {
    if (!c.isBuffer(i))
      throw new TypeError("Argument must be a Buffer");
    return this === i ? true : c.compare(this, i) === 0;
  }, c.prototype.inspect = function() {
    let i = "";
    const a = e.INSPECT_MAX_BYTES;
    return i = this.toString("hex", 0, a).replace(/(.{2})/g, "$1 ").trim(), this.length > a && (i += " ... "), "<Buffer " + i + ">";
  }, r2 && (c.prototype[r2] = c.prototype.inspect), c.prototype.compare = function(i, a, u, d, y) {
    if (ke2(i, Uint8Array) && (i = c.from(i, i.offset, i.byteLength)), !c.isBuffer(i))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof i
      );
    if (a === void 0 && (a = 0), u === void 0 && (u = i ? i.length : 0), d === void 0 && (d = 0), y === void 0 && (y = this.length), a < 0 || u > i.length || d < 0 || y > this.length)
      throw new RangeError("out of range index");
    if (d >= y && a >= u)
      return 0;
    if (d >= y)
      return -1;
    if (a >= u)
      return 1;
    if (a >>>= 0, u >>>= 0, d >>>= 0, y >>>= 0, this === i)
      return 0;
    let p = y - d, m = u - a;
    const Z2 = Math.min(p, m), ce2 = this.slice(d, y), G = i.slice(a, u);
    for (let Y = 0; Y < Z2; ++Y)
      if (ce2[Y] !== G[Y]) {
        p = ce2[Y], m = G[Y];
        break;
      }
    return p < m ? -1 : m < p ? 1 : 0;
  };
  function k2(i, a, u, d, y) {
    if (i.length === 0)
      return -1;
    if (typeof u == "string" ? (d = u, u = 0) : u > 2147483647 ? u = 2147483647 : u < -2147483648 && (u = -2147483648), u = +u, qn2(u) && (u = y ? 0 : i.length - 1), u < 0 && (u = i.length + u), u >= i.length) {
      if (y)
        return -1;
      u = i.length - 1;
    } else if (u < 0)
      if (y)
        u = 0;
      else
        return -1;
    if (typeof a == "string" && (a = c.from(a, d)), c.isBuffer(a))
      return a.length === 0 ? -1 : ee2(i, a, u, d, y);
    if (typeof a == "number")
      return a = a & 255, typeof Uint8Array.prototype.indexOf == "function" ? y ? Uint8Array.prototype.indexOf.call(i, a, u) : Uint8Array.prototype.lastIndexOf.call(i, a, u) : ee2(i, [a], u, d, y);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ee2(i, a, u, d, y) {
    let p = 1, m = i.length, Z2 = a.length;
    if (d !== void 0 && (d = String(d).toLowerCase(), d === "ucs2" || d === "ucs-2" || d === "utf16le" || d === "utf-16le")) {
      if (i.length < 2 || a.length < 2)
        return -1;
      p = 2, m /= 2, Z2 /= 2, u /= 2;
    }
    function ce2(Y, te2) {
      return p === 1 ? Y[te2] : Y.readUInt16BE(te2 * p);
    }
    let G;
    if (y) {
      let Y = -1;
      for (G = u; G < m; G++)
        if (ce2(i, G) === ce2(a, Y === -1 ? 0 : G - Y)) {
          if (Y === -1 && (Y = G), G - Y + 1 === Z2)
            return Y * p;
        } else
          Y !== -1 && (G -= G - Y), Y = -1;
    } else
      for (u + Z2 > m && (u = m - Z2), G = u; G >= 0; G--) {
        let Y = true;
        for (let te2 = 0; te2 < Z2; te2++)
          if (ce2(i, G + te2) !== ce2(a, te2)) {
            Y = false;
            break;
          }
        if (Y)
          return G;
      }
    return -1;
  }
  c.prototype.includes = function(i, a, u) {
    return this.indexOf(i, a, u) !== -1;
  }, c.prototype.indexOf = function(i, a, u) {
    return k2(this, i, a, u, true);
  }, c.prototype.lastIndexOf = function(i, a, u) {
    return k2(this, i, a, u, false);
  };
  function P4(i, a, u, d) {
    u = Number(u) || 0;
    const y = i.length - u;
    d ? (d = Number(d), d > y && (d = y)) : d = y;
    const p = a.length;
    d > p / 2 && (d = p / 2);
    let m;
    for (m = 0; m < d; ++m) {
      const Z2 = parseInt(a.substr(m * 2, 2), 16);
      if (qn2(Z2))
        return m;
      i[u + m] = Z2;
    }
    return m;
  }
  function ue2(i, a, u, d) {
    return Vt(Vn(a, i.length - u), i, u, d);
  }
  function oe2(i, a, u, d) {
    return Vt(zo(a), i, u, d);
  }
  function Ne2(i, a, u, d) {
    return Vt(Xr(a), i, u, d);
  }
  function Te2(i, a, u, d) {
    return Vt(Ro2(a, i.length - u), i, u, d);
  }
  c.prototype.write = function(i, a, u, d) {
    if (a === void 0)
      d = "utf8", u = this.length, a = 0;
    else if (u === void 0 && typeof a == "string")
      d = a, u = this.length, a = 0;
    else if (isFinite(a))
      a = a >>> 0, isFinite(u) ? (u = u >>> 0, d === void 0 && (d = "utf8")) : (d = u, u = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const y = this.length - a;
    if ((u === void 0 || u > y) && (u = y), i.length > 0 && (u < 0 || a < 0) || a > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    d || (d = "utf8");
    let p = false;
    for (; ; )
      switch (d) {
        case "hex":
          return P4(this, i, a, u);
        case "utf8":
        case "utf-8":
          return ue2(this, i, a, u);
        case "ascii":
        case "latin1":
        case "binary":
          return oe2(this, i, a, u);
        case "base64":
          return Ne2(this, i, a, u);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Te2(this, i, a, u);
        default:
          if (p)
            throw new TypeError("Unknown encoding: " + d);
          d = ("" + d).toLowerCase(), p = true;
      }
  }, c.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Ce2(i, a, u) {
    return a === 0 && u === i.length ? t.fromByteArray(i) : t.fromByteArray(i.slice(a, u));
  }
  function Ae2(i, a, u) {
    u = Math.min(i.length, u);
    const d = [];
    let y = a;
    for (; y < u; ) {
      const p = i[y];
      let m = null, Z2 = p > 239 ? 4 : p > 223 ? 3 : p > 191 ? 2 : 1;
      if (y + Z2 <= u) {
        let ce2, G, Y, te2;
        switch (Z2) {
          case 1:
            p < 128 && (m = p);
            break;
          case 2:
            ce2 = i[y + 1], (ce2 & 192) === 128 && (te2 = (p & 31) << 6 | ce2 & 63, te2 > 127 && (m = te2));
            break;
          case 3:
            ce2 = i[y + 1], G = i[y + 2], (ce2 & 192) === 128 && (G & 192) === 128 && (te2 = (p & 15) << 12 | (ce2 & 63) << 6 | G & 63, te2 > 2047 && (te2 < 55296 || te2 > 57343) && (m = te2));
            break;
          case 4:
            ce2 = i[y + 1], G = i[y + 2], Y = i[y + 3], (ce2 & 192) === 128 && (G & 192) === 128 && (Y & 192) === 128 && (te2 = (p & 15) << 18 | (ce2 & 63) << 12 | (G & 63) << 6 | Y & 63, te2 > 65535 && te2 < 1114112 && (m = te2));
        }
      }
      m === null ? (m = 65533, Z2 = 1) : m > 65535 && (m -= 65536, d.push(m >>> 10 & 1023 | 55296), m = 56320 | m & 1023), d.push(m), y += Z2;
    }
    return Me2(d);
  }
  const Le2 = 4096;
  function Me2(i) {
    const a = i.length;
    if (a <= Le2)
      return String.fromCharCode.apply(String, i);
    let u = "", d = 0;
    for (; d < a; )
      u += String.fromCharCode.apply(
        String,
        i.slice(d, d += Le2)
      );
    return u;
  }
  function T2(i, a, u) {
    let d = "";
    u = Math.min(i.length, u);
    for (let y = a; y < u; ++y)
      d += String.fromCharCode(i[y] & 127);
    return d;
  }
  function S2(i, a, u) {
    let d = "";
    u = Math.min(i.length, u);
    for (let y = a; y < u; ++y)
      d += String.fromCharCode(i[y]);
    return d;
  }
  function O2(i, a, u) {
    const d = i.length;
    (!a || a < 0) && (a = 0), (!u || u < 0 || u > d) && (u = d);
    let y = "";
    for (let p = a; p < u; ++p)
      y += Uo[i[p]];
    return y;
  }
  function V2(i, a, u) {
    const d = i.slice(a, u);
    let y = "";
    for (let p = 0; p < d.length - 1; p += 2)
      y += String.fromCharCode(d[p] + d[p + 1] * 256);
    return y;
  }
  c.prototype.slice = function(i, a) {
    const u = this.length;
    i = ~~i, a = a === void 0 ? u : ~~a, i < 0 ? (i += u, i < 0 && (i = 0)) : i > u && (i = u), a < 0 ? (a += u, a < 0 && (a = 0)) : a > u && (a = u), a < i && (a = i);
    const d = this.subarray(i, a);
    return Object.setPrototypeOf(d, c.prototype), d;
  };
  function R2(i, a, u) {
    if (i % 1 !== 0 || i < 0)
      throw new RangeError("offset is not uint");
    if (i + a > u)
      throw new RangeError("Trying to access beyond buffer length");
  }
  c.prototype.readUintLE = c.prototype.readUIntLE = function(i, a, u) {
    i = i >>> 0, a = a >>> 0, u || R2(i, a, this.length);
    let d = this[i], y = 1, p = 0;
    for (; ++p < a && (y *= 256); )
      d += this[i + p] * y;
    return d;
  }, c.prototype.readUintBE = c.prototype.readUIntBE = function(i, a, u) {
    i = i >>> 0, a = a >>> 0, u || R2(i, a, this.length);
    let d = this[i + --a], y = 1;
    for (; a > 0 && (y *= 256); )
      d += this[i + --a] * y;
    return d;
  }, c.prototype.readUint8 = c.prototype.readUInt8 = function(i, a) {
    return i = i >>> 0, a || R2(i, 1, this.length), this[i];
  }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function(i, a) {
    return i = i >>> 0, a || R2(i, 2, this.length), this[i] | this[i + 1] << 8;
  }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function(i, a) {
    return i = i >>> 0, a || R2(i, 2, this.length), this[i] << 8 | this[i + 1];
  }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function(i, a) {
    return i = i >>> 0, a || R2(i, 4, this.length), (this[i] | this[i + 1] << 8 | this[i + 2] << 16) + this[i + 3] * 16777216;
  }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function(i, a) {
    return i = i >>> 0, a || R2(i, 4, this.length), this[i] * 16777216 + (this[i + 1] << 16 | this[i + 2] << 8 | this[i + 3]);
  }, c.prototype.readBigUInt64LE = Ve(function(i) {
    i = i >>> 0, ht2(i, "offset");
    const a = this[i], u = this[i + 7];
    (a === void 0 || u === void 0) && Tt(i, this.length - 8);
    const d = a + this[++i] * 2 ** 8 + this[++i] * 2 ** 16 + this[++i] * 2 ** 24, y = this[++i] + this[++i] * 2 ** 8 + this[++i] * 2 ** 16 + u * 2 ** 24;
    return BigInt(d) + (BigInt(y) << BigInt(32));
  }), c.prototype.readBigUInt64BE = Ve(function(i) {
    i = i >>> 0, ht2(i, "offset");
    const a = this[i], u = this[i + 7];
    (a === void 0 || u === void 0) && Tt(i, this.length - 8);
    const d = a * 2 ** 24 + this[++i] * 2 ** 16 + this[++i] * 2 ** 8 + this[++i], y = this[++i] * 2 ** 24 + this[++i] * 2 ** 16 + this[++i] * 2 ** 8 + u;
    return (BigInt(d) << BigInt(32)) + BigInt(y);
  }), c.prototype.readIntLE = function(i, a, u) {
    i = i >>> 0, a = a >>> 0, u || R2(i, a, this.length);
    let d = this[i], y = 1, p = 0;
    for (; ++p < a && (y *= 256); )
      d += this[i + p] * y;
    return y *= 128, d >= y && (d -= Math.pow(2, 8 * a)), d;
  }, c.prototype.readIntBE = function(i, a, u) {
    i = i >>> 0, a = a >>> 0, u || R2(i, a, this.length);
    let d = a, y = 1, p = this[i + --d];
    for (; d > 0 && (y *= 256); )
      p += this[i + --d] * y;
    return y *= 128, p >= y && (p -= Math.pow(2, 8 * a)), p;
  }, c.prototype.readInt8 = function(i, a) {
    return i = i >>> 0, a || R2(i, 1, this.length), this[i] & 128 ? (255 - this[i] + 1) * -1 : this[i];
  }, c.prototype.readInt16LE = function(i, a) {
    i = i >>> 0, a || R2(i, 2, this.length);
    const u = this[i] | this[i + 1] << 8;
    return u & 32768 ? u | 4294901760 : u;
  }, c.prototype.readInt16BE = function(i, a) {
    i = i >>> 0, a || R2(i, 2, this.length);
    const u = this[i + 1] | this[i] << 8;
    return u & 32768 ? u | 4294901760 : u;
  }, c.prototype.readInt32LE = function(i, a) {
    return i = i >>> 0, a || R2(i, 4, this.length), this[i] | this[i + 1] << 8 | this[i + 2] << 16 | this[i + 3] << 24;
  }, c.prototype.readInt32BE = function(i, a) {
    return i = i >>> 0, a || R2(i, 4, this.length), this[i] << 24 | this[i + 1] << 16 | this[i + 2] << 8 | this[i + 3];
  }, c.prototype.readBigInt64LE = Ve(function(i) {
    i = i >>> 0, ht2(i, "offset");
    const a = this[i], u = this[i + 7];
    (a === void 0 || u === void 0) && Tt(i, this.length - 8);
    const d = this[i + 4] + this[i + 5] * 2 ** 8 + this[i + 6] * 2 ** 16 + (u << 24);
    return (BigInt(d) << BigInt(32)) + BigInt(a + this[++i] * 2 ** 8 + this[++i] * 2 ** 16 + this[++i] * 2 ** 24);
  }), c.prototype.readBigInt64BE = Ve(function(i) {
    i = i >>> 0, ht2(i, "offset");
    const a = this[i], u = this[i + 7];
    (a === void 0 || u === void 0) && Tt(i, this.length - 8);
    const d = (a << 24) + // Overflow
    this[++i] * 2 ** 16 + this[++i] * 2 ** 8 + this[++i];
    return (BigInt(d) << BigInt(32)) + BigInt(this[++i] * 2 ** 24 + this[++i] * 2 ** 16 + this[++i] * 2 ** 8 + u);
  }), c.prototype.readFloatLE = function(i, a) {
    return i = i >>> 0, a || R2(i, 4, this.length), n.read(this, i, true, 23, 4);
  }, c.prototype.readFloatBE = function(i, a) {
    return i = i >>> 0, a || R2(i, 4, this.length), n.read(this, i, false, 23, 4);
  }, c.prototype.readDoubleLE = function(i, a) {
    return i = i >>> 0, a || R2(i, 8, this.length), n.read(this, i, true, 52, 8);
  }, c.prototype.readDoubleBE = function(i, a) {
    return i = i >>> 0, a || R2(i, 8, this.length), n.read(this, i, false, 52, 8);
  };
  function Q2(i, a, u, d, y, p) {
    if (!c.isBuffer(i))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (a > y || a < p)
      throw new RangeError('"value" argument is out of bounds');
    if (u + d > i.length)
      throw new RangeError("Index out of range");
  }
  c.prototype.writeUintLE = c.prototype.writeUIntLE = function(i, a, u, d) {
    if (i = +i, a = a >>> 0, u = u >>> 0, !d) {
      const m = Math.pow(2, 8 * u) - 1;
      Q2(this, i, a, u, m, 0);
    }
    let y = 1, p = 0;
    for (this[a] = i & 255; ++p < u && (y *= 256); )
      this[a + p] = i / y & 255;
    return a + u;
  }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function(i, a, u, d) {
    if (i = +i, a = a >>> 0, u = u >>> 0, !d) {
      const m = Math.pow(2, 8 * u) - 1;
      Q2(this, i, a, u, m, 0);
    }
    let y = u - 1, p = 1;
    for (this[a + y] = i & 255; --y >= 0 && (p *= 256); )
      this[a + y] = i / p & 255;
    return a + u;
  }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function(i, a, u) {
    return i = +i, a = a >>> 0, u || Q2(this, i, a, 1, 255, 0), this[a] = i & 255, a + 1;
  }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || Q2(this, i, a, 2, 65535, 0), this[a] = i & 255, this[a + 1] = i >>> 8, a + 2;
  }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || Q2(this, i, a, 2, 65535, 0), this[a] = i >>> 8, this[a + 1] = i & 255, a + 2;
  }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || Q2(this, i, a, 4, 4294967295, 0), this[a + 3] = i >>> 24, this[a + 2] = i >>> 16, this[a + 1] = i >>> 8, this[a] = i & 255, a + 4;
  }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || Q2(this, i, a, 4, 4294967295, 0), this[a] = i >>> 24, this[a + 1] = i >>> 16, this[a + 2] = i >>> 8, this[a + 3] = i & 255, a + 4;
  };
  function lt2(i, a, u, d, y) {
    qr(a, d, y, i, u, 7);
    let p = Number(a & BigInt(4294967295));
    i[u++] = p, p = p >> 8, i[u++] = p, p = p >> 8, i[u++] = p, p = p >> 8, i[u++] = p;
    let m = Number(a >> BigInt(32) & BigInt(4294967295));
    return i[u++] = m, m = m >> 8, i[u++] = m, m = m >> 8, i[u++] = m, m = m >> 8, i[u++] = m, u;
  }
  function ft2(i, a, u, d, y) {
    qr(a, d, y, i, u, 7);
    let p = Number(a & BigInt(4294967295));
    i[u + 7] = p, p = p >> 8, i[u + 6] = p, p = p >> 8, i[u + 5] = p, p = p >> 8, i[u + 4] = p;
    let m = Number(a >> BigInt(32) & BigInt(4294967295));
    return i[u + 3] = m, m = m >> 8, i[u + 2] = m, m = m >> 8, i[u + 1] = m, m = m >> 8, i[u] = m, u + 8;
  }
  c.prototype.writeBigUInt64LE = Ve(function(i, a = 0) {
    return lt2(this, i, a, BigInt(0), BigInt("0xffffffffffffffff"));
  }), c.prototype.writeBigUInt64BE = Ve(function(i, a = 0) {
    return ft2(this, i, a, BigInt(0), BigInt("0xffffffffffffffff"));
  }), c.prototype.writeIntLE = function(i, a, u, d) {
    if (i = +i, a = a >>> 0, !d) {
      const Z2 = Math.pow(2, 8 * u - 1);
      Q2(this, i, a, u, Z2 - 1, -Z2);
    }
    let y = 0, p = 1, m = 0;
    for (this[a] = i & 255; ++y < u && (p *= 256); )
      i < 0 && m === 0 && this[a + y - 1] !== 0 && (m = 1), this[a + y] = (i / p >> 0) - m & 255;
    return a + u;
  }, c.prototype.writeIntBE = function(i, a, u, d) {
    if (i = +i, a = a >>> 0, !d) {
      const Z2 = Math.pow(2, 8 * u - 1);
      Q2(this, i, a, u, Z2 - 1, -Z2);
    }
    let y = u - 1, p = 1, m = 0;
    for (this[a + y] = i & 255; --y >= 0 && (p *= 256); )
      i < 0 && m === 0 && this[a + y + 1] !== 0 && (m = 1), this[a + y] = (i / p >> 0) - m & 255;
    return a + u;
  }, c.prototype.writeInt8 = function(i, a, u) {
    return i = +i, a = a >>> 0, u || Q2(this, i, a, 1, 127, -128), i < 0 && (i = 255 + i + 1), this[a] = i & 255, a + 1;
  }, c.prototype.writeInt16LE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || Q2(this, i, a, 2, 32767, -32768), this[a] = i & 255, this[a + 1] = i >>> 8, a + 2;
  }, c.prototype.writeInt16BE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || Q2(this, i, a, 2, 32767, -32768), this[a] = i >>> 8, this[a + 1] = i & 255, a + 2;
  }, c.prototype.writeInt32LE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || Q2(this, i, a, 4, 2147483647, -2147483648), this[a] = i & 255, this[a + 1] = i >>> 8, this[a + 2] = i >>> 16, this[a + 3] = i >>> 24, a + 4;
  }, c.prototype.writeInt32BE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || Q2(this, i, a, 4, 2147483647, -2147483648), i < 0 && (i = 4294967295 + i + 1), this[a] = i >>> 24, this[a + 1] = i >>> 16, this[a + 2] = i >>> 8, this[a + 3] = i & 255, a + 4;
  }, c.prototype.writeBigInt64LE = Ve(function(i, a = 0) {
    return lt2(this, i, a, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), c.prototype.writeBigInt64BE = Ve(function(i, a = 0) {
    return ft2(this, i, a, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function tt2(i, a, u, d, y, p) {
    if (u + d > i.length)
      throw new RangeError("Index out of range");
    if (u < 0)
      throw new RangeError("Index out of range");
  }
  function nt2(i, a, u, d, y) {
    return a = +a, u = u >>> 0, y || tt2(i, a, u, 4), n.write(i, a, u, d, 23, 4), u + 4;
  }
  c.prototype.writeFloatLE = function(i, a, u) {
    return nt2(this, i, a, true, u);
  }, c.prototype.writeFloatBE = function(i, a, u) {
    return nt2(this, i, a, false, u);
  };
  function Ge2(i, a, u, d, y) {
    return a = +a, u = u >>> 0, y || tt2(i, a, u, 8), n.write(i, a, u, d, 52, 8), u + 8;
  }
  c.prototype.writeDoubleLE = function(i, a, u) {
    return Ge2(this, i, a, true, u);
  }, c.prototype.writeDoubleBE = function(i, a, u) {
    return Ge2(this, i, a, false, u);
  }, c.prototype.copy = function(i, a, u, d) {
    if (!c.isBuffer(i))
      throw new TypeError("argument should be a Buffer");
    if (u || (u = 0), !d && d !== 0 && (d = this.length), a >= i.length && (a = i.length), a || (a = 0), d > 0 && d < u && (d = u), d === u || i.length === 0 || this.length === 0)
      return 0;
    if (a < 0)
      throw new RangeError("targetStart out of bounds");
    if (u < 0 || u >= this.length)
      throw new RangeError("Index out of range");
    if (d < 0)
      throw new RangeError("sourceEnd out of bounds");
    d > this.length && (d = this.length), i.length - a < d - u && (d = i.length - a + u);
    const y = d - u;
    return this === i && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(a, u, d) : Uint8Array.prototype.set.call(
      i,
      this.subarray(u, d),
      a
    ), y;
  }, c.prototype.fill = function(i, a, u, d) {
    if (typeof i == "string") {
      if (typeof a == "string" ? (d = a, a = 0, u = this.length) : typeof u == "string" && (d = u, u = this.length), d !== void 0 && typeof d != "string")
        throw new TypeError("encoding must be a string");
      if (typeof d == "string" && !c.isEncoding(d))
        throw new TypeError("Unknown encoding: " + d);
      if (i.length === 1) {
        const p = i.charCodeAt(0);
        (d === "utf8" && p < 128 || d === "latin1") && (i = p);
      }
    } else
      typeof i == "number" ? i = i & 255 : typeof i == "boolean" && (i = Number(i));
    if (a < 0 || this.length < a || this.length < u)
      throw new RangeError("Out of range index");
    if (u <= a)
      return this;
    a = a >>> 0, u = u === void 0 ? this.length : u >>> 0, i || (i = 0);
    let y;
    if (typeof i == "number")
      for (y = a; y < u; ++y)
        this[y] = i;
    else {
      const p = c.isBuffer(i) ? i : c.from(i, d), m = p.length;
      if (m === 0)
        throw new TypeError('The value "' + i + '" is invalid for argument "value"');
      for (y = 0; y < u - a; ++y)
        this[y + a] = p[y % m];
    }
    return this;
  };
  const dt2 = {};
  function Gn(i, a, u) {
    dt2[i] = class extends u {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: a.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
      }
      get code() {
        return i;
      }
      set code(d) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: d,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${i}]: ${this.message}`;
      }
    };
  }
  Gn(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(i) {
      return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Gn(
    "ERR_INVALID_ARG_TYPE",
    function(i, a) {
      return `The "${i}" argument must be of type number. Received type ${typeof a}`;
    },
    TypeError
  ), Gn(
    "ERR_OUT_OF_RANGE",
    function(i, a, u) {
      let d = `The value of "${i}" is out of range.`, y = u;
      return Number.isInteger(u) && Math.abs(u) > 2 ** 32 ? y = Vr(String(u)) : typeof u == "bigint" && (y = String(u), (u > BigInt(2) ** BigInt(32) || u < -(BigInt(2) ** BigInt(32))) && (y = Vr(y)), y += "n"), d += ` It must be ${a}. Received ${y}`, d;
    },
    RangeError
  );
  function Vr(i) {
    let a = "", u = i.length;
    const d = i[0] === "-" ? 1 : 0;
    for (; u >= d + 4; u -= 3)
      a = `_${i.slice(u - 3, u)}${a}`;
    return `${i.slice(0, u)}${a}`;
  }
  function So(i, a, u) {
    ht2(a, "offset"), (i[a] === void 0 || i[a + u] === void 0) && Tt(a, i.length - (u + 1));
  }
  function qr(i, a, u, d, y, p) {
    if (i > u || i < a) {
      const m = typeof a == "bigint" ? "n" : "";
      let Z2;
      throw a === 0 || a === BigInt(0) ? Z2 = `>= 0${m} and < 2${m} ** ${(p + 1) * 8}${m}` : Z2 = `>= -(2${m} ** ${(p + 1) * 8 - 1}${m}) and < 2 ** ${(p + 1) * 8 - 1}${m}`, new dt2.ERR_OUT_OF_RANGE("value", Z2, i);
    }
    So(d, y, p);
  }
  function ht2(i, a) {
    if (typeof i != "number")
      throw new dt2.ERR_INVALID_ARG_TYPE(a, "number", i);
  }
  function Tt(i, a, u) {
    throw Math.floor(i) !== i ? (ht2(i, u), new dt2.ERR_OUT_OF_RANGE("offset", "an integer", i)) : a < 0 ? new dt2.ERR_BUFFER_OUT_OF_BOUNDS() : new dt2.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${a}`,
      i
    );
  }
  const Oo2 = /[^+/0-9A-Za-z-_]/g;
  function xo(i) {
    if (i = i.split("=")[0], i = i.trim().replace(Oo2, ""), i.length < 2)
      return "";
    for (; i.length % 4 !== 0; )
      i = i + "=";
    return i;
  }
  function Vn(i, a) {
    a = a || 1 / 0;
    let u;
    const d = i.length;
    let y = null;
    const p = [];
    for (let m = 0; m < d; ++m) {
      if (u = i.charCodeAt(m), u > 55295 && u < 57344) {
        if (!y) {
          if (u > 56319) {
            (a -= 3) > -1 && p.push(239, 191, 189);
            continue;
          } else if (m + 1 === d) {
            (a -= 3) > -1 && p.push(239, 191, 189);
            continue;
          }
          y = u;
          continue;
        }
        if (u < 56320) {
          (a -= 3) > -1 && p.push(239, 191, 189), y = u;
          continue;
        }
        u = (y - 55296 << 10 | u - 56320) + 65536;
      } else
        y && (a -= 3) > -1 && p.push(239, 191, 189);
      if (y = null, u < 128) {
        if ((a -= 1) < 0)
          break;
        p.push(u);
      } else if (u < 2048) {
        if ((a -= 2) < 0)
          break;
        p.push(
          u >> 6 | 192,
          u & 63 | 128
        );
      } else if (u < 65536) {
        if ((a -= 3) < 0)
          break;
        p.push(
          u >> 12 | 224,
          u >> 6 & 63 | 128,
          u & 63 | 128
        );
      } else if (u < 1114112) {
        if ((a -= 4) < 0)
          break;
        p.push(
          u >> 18 | 240,
          u >> 12 & 63 | 128,
          u >> 6 & 63 | 128,
          u & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return p;
  }
  function zo(i) {
    const a = [];
    for (let u = 0; u < i.length; ++u)
      a.push(i.charCodeAt(u) & 255);
    return a;
  }
  function Ro2(i, a) {
    let u, d, y;
    const p = [];
    for (let m = 0; m < i.length && !((a -= 2) < 0); ++m)
      u = i.charCodeAt(m), d = u >> 8, y = u % 256, p.push(y), p.push(d);
    return p;
  }
  function Xr(i) {
    return t.toByteArray(xo(i));
  }
  function Vt(i, a, u, d) {
    let y;
    for (y = 0; y < d && !(y + u >= a.length || y >= i.length); ++y)
      a[y + u] = i[y];
    return y;
  }
  function ke2(i, a) {
    return i instanceof a || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === a.name;
  }
  function qn2(i) {
    return i !== i;
  }
  const Uo = function() {
    const i = "0123456789abcdef", a = new Array(256);
    for (let u = 0; u < 16; ++u) {
      const d = u * 16;
      for (let y = 0; y < 16; ++y)
        a[d + y] = i[u] + i[y];
    }
    return a;
  }();
  function Ve(i) {
    return typeof BigInt > "u" ? ko : i;
  }
  function ko() {
    throw new Error("BigInt not supported");
  }
})($t);
var ie = /* @__PURE__ */ ((e) => (e.UNKNOWN_ERROR = "UNKNOWN_ERROR", e.KIT__UNKNOWN_ERROR = "KIT.UNKNOWN_ERROR", e.WALLET__UNKNOWN_ERROR = "WALLET.UNKNOWN_ERROR", e.WALLET__CONNECT_ERROR = "WALLET.CONNECT_ERROR", e.WALLET__CONNECT_ERROR__USER_REJECTED = "WALLET.CONNECT_ERROR.USER_REJECTED", e.WALLET__DISCONNECT_ERROR = "WALLET.DISCONNECT_ERROR", e.WALLET__SIGN_TX_ERROR = "WALLET.SIGN_TX_ERROR", e.WALLET__SIGN_MSG_ERROR = "WALLET.SIGN_MSG_ERROR", e.WALLET__SIGN_PERSONAL_MSG_ERROR = "WALLET.SIGN_PERSONAL_MSG_ERROR", e.WALLET__LISTEN_TO_EVENT_ERROR = "WALLET.LISTEN_TO_EVENT_ERROR", e.WALLET__METHOD_NOT_IMPLEMENTED_ERROR = "WALLET.METHOD_NOT_IMPLEMENTED_ERROR", e.WALLET__REPORT_EFFECTS_ERROR = "WALLET.REPORT_EFFECTS_ERROR", e))(ie || {});
var Pi = class extends Error {
  constructor(t, n = ie.UNKNOWN_ERROR, r2) {
    super(t), J(this, "code"), J(this, "details"), this.details = r2, this.code = n, this.message = this.formatErrorStr(n, t, r2);
  }
  formatErrorStr(t, n, r2) {
    let o = `[${this.code}] ${n}`;
    return r2 && (o += " | details: " + JSON.stringify(r2)), o;
  }
};
var re = class extends Pi {
  constructor(t = "kit unknown error", n = ie.KIT__UNKNOWN_ERROR, r2) {
    super(t, n, r2);
  }
};
var en;
en = /* @__PURE__ */ new WeakMap();
var tn;
var nn;
var rn;
var on;
var sn;
var an;
tn = /* @__PURE__ */ new WeakMap(), nn = /* @__PURE__ */ new WeakMap(), rn = /* @__PURE__ */ new WeakMap(), on = /* @__PURE__ */ new WeakMap(), sn = /* @__PURE__ */ new WeakMap(), an = /* @__PURE__ */ new WeakMap();
var sa = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
var $n;
function Yi(e) {
  var _a7, _b3, _c;
  return {
    lang: (_a7 = e == null ? void 0 : e.lang) != null ? _a7 : $n == null ? void 0 : $n.lang,
    message: e == null ? void 0 : e.message,
    abortEarly: (_b3 = e == null ? void 0 : e.abortEarly) != null ? _b3 : $n == null ? void 0 : $n.abortEarly,
    abortPipeEarly: (_c = e == null ? void 0 : e.abortPipeEarly) != null ? _c : $n == null ? void 0 : $n.abortPipeEarly
  };
}
var aa;
function ca(e) {
  return aa == null ? void 0 : aa.get(e);
}
var ua;
function la(e) {
  return ua == null ? void 0 : ua.get(e);
}
var fa;
function da(e, t) {
  var _a7;
  return (_a7 = fa == null ? void 0 : fa.get(e)) == null ? void 0 : _a7.get(t);
}
function Fi(e) {
  var _a7, _b3, _c;
  const t = typeof e;
  return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (_c = e && ((_b3 = (_a7 = Object.getPrototypeOf(e)) == null ? void 0 : _a7.constructor) == null ? void 0 : _b3.name)) != null ? _c : "null" : t;
}
function $e(e, t, n, r2, o) {
  var _a7, _b3, _c, _d, _e3, _f, _g, _h;
  const s = o && "input" in o ? o.input : n.value, l = (_b3 = (_a7 = o == null ? void 0 : o.expected) != null ? _a7 : e.expects) != null ? _b3 : null, c = (_c = o == null ? void 0 : o.received) != null ? _c : Fi(s), f = {
    kind: e.kind,
    type: e.type,
    input: s,
    expected: l,
    received: c,
    message: `Invalid ${t}: ${l ? `Expected ${l} but r` : "R"}eceived ${c}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: r2.lang,
    abortEarly: r2.abortEarly,
    abortPipeEarly: r2.abortPipeEarly
  }, h = e.kind === "schema", g = (_h = (_g = (_f = (_e3 = (_d = o == null ? void 0 : o.message) != null ? _d : (
    // @ts-expect-error
    e.message
  )) != null ? _e3 : da(e.reference, f.lang)) != null ? _f : h ? la(f.lang) : null) != null ? _g : r2.message) != null ? _h : ca(f.lang);
  g && (f.message = typeof g == "function" ? g(f) : g), h && (n.typed = false), n.issues ? n.issues.push(f) : n.issues = [f];
}
function Zi(e) {
  return {
    kind: "validation",
    type: "uuid",
    reference: Zi,
    async: false,
    expects: null,
    requirement: sa,
    message: e,
    _run(t, n) {
      return t.typed && !this.requirement.test(t.value) && $e(this, "UUID", t, n), t;
    }
  };
}
function ga(e, t, n) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, n)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function Gi(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: Gi,
    expects: "Array",
    async: false,
    item: e,
    message: t,
    _run(n, r2) {
      var _a7;
      const o = n.value;
      if (Array.isArray(o)) {
        n.typed = true, n.value = [];
        for (let s = 0; s < o.length; s++) {
          const l = o[s], c = this.item._run({ typed: false, value: l }, r2);
          if (c.issues) {
            const f = {
              type: "array",
              origin: "value",
              input: o,
              key: s,
              value: l
            };
            for (const h of c.issues)
              h.path ? h.path.unshift(f) : h.path = [f], (_a7 = n.issues) == null ? void 0 : _a7.push(h);
            if (n.issues || (n.issues = c.issues), r2.abortEarly) {
              n.typed = false;
              break;
            }
          }
          c.typed || (n.typed = false), n.value.push(c.value);
        }
      } else
        $e(this, "type", n, r2);
      return n;
    }
  };
}
function Fe(e, t) {
  return {
    kind: "schema",
    type: "literal",
    reference: Fe,
    expects: Fi(e),
    async: false,
    literal: e,
    message: t,
    _run(n, r2) {
      return n.value === this.literal ? n.typed = true : $e(this, "type", n, r2), n;
    }
  };
}
function ur(e) {
  return {
    kind: "schema",
    type: "number",
    reference: ur,
    expects: "number",
    async: false,
    message: e,
    _run(t, n) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = true : $e(this, "type", t, n), t;
    }
  };
}
function ze(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: ze,
    expects: "Object",
    async: false,
    entries: e,
    message: t,
    _run(n, r2) {
      var _a7;
      const o = n.value;
      if (o && typeof o == "object") {
        n.typed = true, n.value = {};
        for (const s in this.entries) {
          const l = o[s], c = this.entries[s]._run(
            { typed: false, value: l },
            r2
          );
          if (c.issues) {
            const f = {
              type: "object",
              origin: "value",
              input: o,
              key: s,
              value: l
            };
            for (const h of c.issues)
              h.path ? h.path.unshift(f) : h.path = [f], (_a7 = n.issues) == null ? void 0 : _a7.push(h);
            if (n.issues || (n.issues = c.issues), r2.abortEarly) {
              n.typed = false;
              break;
            }
          }
          c.typed || (n.typed = false), (c.value !== void 0 || s in o) && (n.value[s] = c.value);
        }
      } else
        $e(this, "type", n, r2);
      return n;
    }
  };
}
function Vi(e, ...t) {
  const n = {
    kind: "schema",
    type: "optional",
    reference: Vi,
    expects: `${e.expects} | undefined`,
    async: false,
    wrapped: e,
    _run(r2, o) {
      return r2.value === void 0 && ("default" in this && (r2.value = ga(
        this,
        r2,
        o
      )), r2.value === void 0) ? (r2.typed = true, r2) : this.wrapped._run(r2, o);
    }
  };
  return 0 in t && (n.default = t[0]), n;
}
function de(e) {
  return {
    kind: "schema",
    type: "string",
    reference: de,
    expects: "string",
    async: false,
    message: e,
    _run(t, n) {
      return typeof t.value == "string" ? t.typed = true : $e(this, "type", t, n), t;
    }
  };
}
function qi(e, t, n = /* @__PURE__ */ new Set()) {
  for (const r2 of t)
    r2.type === "variant" ? qi(e, r2.options, n) : n.add(r2.entries[e].expects);
  return n;
}
function kr(e, t, n) {
  let r2;
  return {
    kind: "schema",
    type: "variant",
    reference: kr,
    expects: "Object",
    async: false,
    key: e,
    options: t,
    message: n,
    _run(o, s) {
      const l = o.value;
      if (l && typeof l == "object") {
        const c = l[this.key];
        if (this.key in l) {
          let f;
          for (const h of this.options)
            if (h.type === "variant" || !h.entries[this.key]._run(
              { typed: false, value: c },
              s
            ).issues) {
              const g = h._run(
                { typed: false, value: l },
                s
              );
              if (!g.issues)
                return g;
              (!f || !f.typed && g.typed) && (f = g);
            }
          if (f)
            return f;
        }
        r2 || (r2 = [...qi(this.key, this.options)].join(" | ") || "never"), $e(this, "type", o, s, {
          input: c,
          expected: r2,
          path: [
            {
              type: "object",
              origin: "value",
              input: l,
              key: this.key,
              value: c
            }
          ]
        });
      } else
        $e(this, "type", o, s);
      return o;
    }
  };
}
function Ma(...e) {
  return __spreadProps(__spreadValues({}, e[0]), {
    pipe: e,
    _run(t, n) {
      for (let r2 = 0; r2 < e.length; r2++) {
        if (t.issues && (e[r2].kind === "schema" || e[r2].kind === "transformation")) {
          t.typed = false;
          break;
        }
        (!t.issues || !n.abortEarly && !n.abortPipeEarly) && (t = e[r2]._run(t, n));
      }
      return t;
    }
  });
}
function pa(e, t, n) {
  const r2 = e._run(
    { typed: false, value: t },
    Yi(n)
  );
  return {
    typed: r2.typed,
    success: !r2.issues,
    output: r2.value,
    issues: r2.issues
  };
}
new TextEncoder();
var lr = new TextDecoder();
var Xi = class extends Error {
  constructor(t, n) {
    var _a7;
    super(t, n), J(this, "code", "ERR_JOSE_GENERIC"), this.name = this.constructor.name, (_a7 = Error.captureStackTrace) == null ? void 0 : _a7.call(Error, this, this.constructor);
  }
};
J(Xi, "code", "ERR_JOSE_GENERIC");
var Xe = class extends Xi {
  constructor() {
    super(...arguments), J(this, "code", "ERR_JWT_INVALID");
  }
};
J(Xe, "code", "ERR_JWT_INVALID");
var wa = ze({
  address: de(),
  publicKey: de()
});
var ba = ze({
  exp: ur(),
  // Expiration Time
  iat: ur(),
  // Issued At
  iss: de(),
  // Issuer
  aud: de(),
  // Audience (the dapp origin)
  payload: ze({
    accounts: Gi(wa)
  })
});
var Ea = kr("type", [
  ze({
    type: Fe("connect"),
    session: de("`session` is required")
  }),
  ze({
    type: Fe("sign-transaction"),
    bytes: de(),
    signature: de()
  }),
  ze({
    type: Fe("sign-and-execute-transaction"),
    bytes: de(),
    signature: de(),
    digest: de(),
    effects: de()
  }),
  ze({
    type: Fe("sign-personal-message"),
    bytes: de(),
    signature: de()
  })
]);
var ja = kr("type", [
  ze({
    type: Fe("reject"),
    reason: Vi(de("`reason` must be a string"))
  }),
  ze({
    type: Fe("resolve"),
    data: Ea
  })
]);
var Ta = ze({
  id: Ma(de(), Zi()),
  source: Fe("web-wallet-channel"),
  payload: ja,
  version: Fe("1")
});
function Ca() {
  let e, t;
  return {
    promise: new Promise((n, r2) => {
      e = n, t = r2;
    }),
    resolve: e,
    reject: t
  };
}
function La() {
  return {
    version: "1",
    originUrl: window.location.href,
    userAgent: navigator.userAgent,
    screenResolution: `${window.screen.width}x${window.screen.height}`,
    language: navigator.language,
    platform: navigator.platform,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    timestamp: Date.now()
  };
}
var _i = (e) => {
  throw TypeError(e);
};
var Pr = (e, t, n) => t.has(e) || _i("Cannot " + n);
var ne = (e, t, n) => (Pr(e, t, "read from private field"), n ? n.call(e) : t.get(e));
var pe = (e, t, n) => t.has(e) ? _i("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n);
var be = (e, t, n, r2) => (Pr(e, t, "write to private field"), t.set(e, n), n);
var er = (e, t, n) => (Pr(e, t, "access private method"), n);
var rt;
var fr;
var Lt;
var St;
var cn;
var un;
var ln2;
var fn;
var dn;
var hn;
var Dt;
var gn;
var Tn;
var Ot;
var yn;
var Sa = class {
  constructor({
    appName: t,
    hostOrigin: n,
    hostPathname: r2 = "dapp-request",
    extraRequestOptions: o
  }) {
    pe(this, Ot), pe(this, rt), pe(this, fr, "1"), pe(this, Lt), pe(this, St), pe(this, cn), pe(this, un), pe(this, ln2), pe(this, fn), pe(this, dn), pe(this, hn), pe(this, Dt, null), pe(this, gn, false), pe(this, Tn, (h) => {
      if (h.origin !== ne(this, St))
        return;
      const { success: g, output: M2 } = pa(Ta, h.data);
      !g || M2.id !== ne(this, Lt) || (er(this, Ot, yn).call(this), M2.payload.type === "reject" ? ne(this, hn).call(this, new Error("User rejected the request")) : M2.payload.type === "resolve" && ne(this, dn).call(this, M2.payload.data));
    });
    const s = window.open("about:blank", "_blank");
    if (!s)
      throw new Error("Failed to open new window");
    be(this, Lt, crypto.randomUUID()), be(this, rt, s), be(this, St, n), be(this, cn, r2), be(this, un, t);
    const { promise: l, resolve: c, reject: f } = Ca();
    be(this, fn, l), be(this, dn, c), be(this, hn, f), be(this, ln2, o), be(this, Dt, setInterval(() => {
      try {
        ne(this, rt).closed && (er(this, Ot, yn).call(this), f(new Error("User closed the wallet window")));
      } catch (e) {
      }
    }, 1e3));
  }
  send(_a7) {
    var _b3 = _a7, {
      type: t
    } = _b3, n = __objRest(_b3, [
      "type"
    ]);
    if (ne(this, rt).closed)
      throw new Error("User closed the wallet window");
    if (ne(this, gn))
      throw new Error("send() can only be called once");
    be(this, gn, true), window.addEventListener("message", ne(this, Tn));
    const r2 = {
      version: ne(this, fr),
      requestId: ne(this, Lt),
      appUrl: window.location.href.split("#")[0],
      appName: ne(this, un),
      payload: __spreadValues({
        type: t
      }, n),
      metadata: La(),
      extraRequestOptions: ne(this, ln2)
    }, o = encodeURIComponent(btoa(JSON.stringify(r2)));
    return ne(this, rt).location.assign(`${ne(this, St)}/${ne(this, cn)}#${o}`), ne(this, fn);
  }
  close() {
    er(this, Ot, yn).call(this), ne(this, rt).close();
  }
};
rt = /* @__PURE__ */ new WeakMap();
fr = /* @__PURE__ */ new WeakMap();
Lt = /* @__PURE__ */ new WeakMap();
St = /* @__PURE__ */ new WeakMap();
cn = /* @__PURE__ */ new WeakMap();
un = /* @__PURE__ */ new WeakMap();
ln2 = /* @__PURE__ */ new WeakMap();
fn = /* @__PURE__ */ new WeakMap();
dn = /* @__PURE__ */ new WeakMap();
hn = /* @__PURE__ */ new WeakMap();
Dt = /* @__PURE__ */ new WeakMap();
gn = /* @__PURE__ */ new WeakMap();
Tn = /* @__PURE__ */ new WeakMap();
Ot = /* @__PURE__ */ new WeakSet();
yn = function() {
  ne(this, Dt) && (clearInterval(ne(this, Dt)), be(this, Dt, null)), window.removeEventListener("message", ne(this, Tn));
};
var Hi = (e) => {
  throw TypeError(e);
};
var Qr = (e, t, n) => t.has(e) || Hi("Cannot " + n);
var le = (e, t, n) => (Qr(e, t, "read from private field"), n ? n.call(e) : t.get(e));
var _e = (e, t, n, r2) => (Qr(e, t, "write to private field"), t.set(e, n), n);
var Mn;
var wt;
var Rt;
var Cn;
var pn;
var vn;
var Ln;
var dr;
var hr;
var gr;
var yr;
var Mr;
var Pe;
var Nn;
var pr;
var vr;
var At;
Mn = /* @__PURE__ */ new WeakMap();
wt = /* @__PURE__ */ new WeakMap();
Rt = /* @__PURE__ */ new WeakMap();
Cn = /* @__PURE__ */ new WeakMap();
pn = /* @__PURE__ */ new WeakMap();
vn = /* @__PURE__ */ new WeakMap();
Ln = /* @__PURE__ */ new WeakMap();
dr = /* @__PURE__ */ new WeakMap();
hr = /* @__PURE__ */ new WeakMap();
gr = /* @__PURE__ */ new WeakMap();
yr = /* @__PURE__ */ new WeakMap();
Mr = /* @__PURE__ */ new WeakMap();
Pe = /* @__PURE__ */ new WeakSet();
Nn = function(e) {
  _e(this, Rt, e), le(this, wt).emit("change", { accounts: this.accounts });
};
pr = /* @__PURE__ */ new WeakMap();
vr = /* @__PURE__ */ new WeakMap();
At = function() {
  return new Sa({
    appName: le(this, Ln),
    hostOrigin: le(this, Cn)
  });
};
function ae(e) {
  return Object.freeze(e);
}
var Pa = ae({
  name: "Suiet",
  label: "Suiet Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iMTYiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3KSIvPjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfMTcwOF8yODI5NykiIGZpbGw9IiNmZmYiPjxwYXRoIGQ9Ik0yMi44IDIwYy0xLjQgMC0yLjctMS40LTMuMy0yLjMtLjcuOS0yIDIuMy0zLjQgMi4zcy0yLjctMS40LTMuNC0yLjNjLS42LjktMS45IDIuMy0zLjMgMi4zLS4zIDAtLjUtLjItLjUtLjVzLjItLjUuNS0uNWMxLjEgMCAyLjYtMS45IDIuOS0yLjVsLjUtLjJjLjIgMCAuMyAwIC40LjIuNC42IDEuOCAyLjUgMi45IDIuNSAxLjEgMCAyLjUtMS45IDIuOS0yLjVsLjQtLjJjLjIgMCAuNCAwIC41LjIuNC42IDEuOCAyLjUgMi45IDIuNS4yIDAgLjUuMi41LjVzLS4yLjUtLjUuNXoiLz48cGF0aCBkPSJNMjIuOCAyMy4zYy0xLjQgMC0yLjctMS4zLTMuMy0yLjMtLjcgMS0yIDIuMy0zLjQgMi4zUzEzLjQgMjIgMTIuNyAyMWMtLjYgMS0xLjkgMi4zLTMuMyAyLjMtLjMgMC0uNS0uMy0uNS0uNSAwLS4zLjItLjYuNS0uNiAxLjEgMCAyLjYtMS44IDIuOS0yLjRsLjUtLjIuNC4yYy40LjYgMS44IDIuNCAyLjkgMi40IDEuMSAwIDIuNS0xLjggMi45LTIuNGwuNC0uMi41LjJjLjQuNiAxLjggMi40IDIuOSAyLjQuMiAwIC41LjMuNS42IDAgLjItLjIuNS0uNS41ek05LjggMTYuN2MtLjMgMC0uNS0uMi0uNS0uNEw5LjEgMTVjMC0zLjkgMy4yLTcgNy03IDMuOSAwIDcgMy4xIDcgN2wtLjEgMS4yYzAgLjMtLjMuNS0uNi41LS40LS4xLS41LS4zLS40LS43di0xYzAtMy4zLTIuNi02LTUuOS02LTMuMiAwLTUuOSAyLjctNS45IDZsLjEgMWMuMS40LS4xLjctLjQuN2gtLjF6Ii8+PC9nPjxkZWZzPjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF8xNzA4XzI4Mjk3IiB4PSI0LjkiIHk9IjYiIHdpZHRoPSIyMi40MzciIGhlaWdodD0iMjMuMzE5IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVDb2xvck1hdHJpeCBpbj0iU291cmNlQWxwaGEiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+PGZlT2Zmc2V0IGR5PSIyIi8+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYSIgb3BlcmF0b3I9Im91dCIvPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwLjE3NTY5NCAwIDAgMCAwIDAuNTc0MTQyIDAgMCAwIDAgMC45MTY2NjcgMCAwIDAgMSAwIi8+PGZlQmxlbmQgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzE3MDhfMjgyOTciLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMTcwOF8yODI5NyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3IiB5MT0iNCIgeDI9IjI4Ljg4OSIgeTI9IjMyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzNFQTJGOCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY3QzhGRiIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjwvc3ZnPg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/suiet/khpkpbbcccdmmclmpigdgddabeilkdpd"
  }
});
var Ji = ae({
  name: "Slush",
  label: "Slush Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgMjRDMCAxMC43NDUyIDEwLjc0NTIgMCAyNCAwQzM3LjI1NDggMCA0OCAxMC43NDUyIDQ4IDI0QzQ4IDM3LjI1NDggMzcuMjU0OCA0OCAyNCA0OEMxMC43NDUyIDQ4IDAgMzcuMjU0OCAwIDI0WiIgZmlsbD0iIzBDMEExRiIvPgo8cGF0aCBkPSJNMTMuMTM1OCAzMi4xMDg1QzE0LjE3MDEgMzUuOTY4MyAxOC4wMzMxIDM5LjQ2MjQgMjYuMDI1NSAzNy4zMjA4QzMzLjY1MTUgMzUuMjc3NCAzOC40MzA5IDI5LjAwNCAzNy4xOTE2IDI0LjM3ODlDMzYuNzYzNiAyMi43ODE3IDM1LjQ3NDYgMjEuNzAwNiAzMy40ODcyIDIxLjg3NjVMMTUuNzE2NSAyMy4zNTcyQzE0LjU5NzMgMjMuNDQzIDE0LjA4NDIgMjMuMjU5NiAxMy43ODgxIDIyLjU1NDNDMTMuNTAxIDIxLjg4MjMgMTMuNjY0NiAyMS4xNjA5IDE1LjAxNjMgMjAuNDc3N0wyOC41NDAxIDEzLjUzNzRDMjkuNTc2NyAxMy4wMSAzMC4yNjcxIDEyLjc4OTMgMzAuODk4IDEzLjAxMjZDMzEuMjkzNCAxMy4xNTYzIDMxLjU1MzggMTMuNzI4NCAzMS4zMTQ3IDE0LjQzNDRMMzAuNDM3OCAxNy4wMjMyQzI5LjM2MTcgMjAuMjAwMiAzMS42NjUzIDIwLjkzODIgMzIuOTY0MSAyMC41OTAyQzM0LjkyODkgMjAuMDYzNyAzNS4zOTExIDE4LjE5MjMgMzQuNzU4MSAxNS44Mjk5QzMzLjE1MzMgOS44NDA1NCAyNi43OTkgOC45MDQxMSAyMS4wMzc4IDEwLjQ0NzhDMTUuMTc2NyAxMi4wMTgzIDEwLjA5NiAxNi43Njc2IDExLjY0NzQgMjIuNTU3M0MxMi4wMTI5IDIzLjkyMTYgMTMuMjY4NyAyNS4wMTE2IDE0LjcyMzIgMjQuOTc4NUwxNi45NDM4IDI0Ljk3MzFDMTcuNDAwNCAyNC45NjI1IDE3LjIzNiAyNSAxOC4xMTcgMjQuOTI3MUMxOC45OTggMjQuODU0MSAyMS4zNTA5IDI0LjU2NDYgMjEuMzUwOSAyNC41NjQ2TDMyLjg5NjIgMjMuMjU4TDMzLjE5MzcgMjMuMjE0OEMzMy44Njg5IDIzLjA5OTcgMzQuMzc5MiAyMy4yNzUgMzQuODEwNiAyNC4wMTgzQzM1LjQ1NjMgMjUuMTMwNCAzNC40NzEyIDI1Ljk2OTEgMzMuMjkyIDI2Ljk3MzFDMzMuMjYwNSAyNyAzMy4yMjg4IDI3LjAyNyAzMy4xOTcgMjcuMDU0MUwyMy4wNDgyIDM1LjgwMDVDMjEuMzA4NyAzNy4zMDA4IDIwLjA4NjcgMzYuNzM2NyAxOS42NTg4IDM1LjEzOTVMMTguMTQzMSAyOS40ODI5QzE3Ljc2ODcgMjguMDg1NCAxNi40MDQxIDI2Ljk4ODkgMTQuODA1NiAyNy40MTcyQzEyLjgwNzUgMjcuOTUyNiAxMi42NDU1IDMwLjI3ODQgMTMuMTM1OCAzMi4xMDg1WiIgZmlsbD0iI0ZCRkFGRiIvPgo8L3N2Zz4K",
  downloadUrl: {
    browserExtension: "https://chromewebstore.google.com/detail/slush-%E2%80%94-a-sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil"
  }
});
var Qa = ae({
  name: "Ethos Wallet",
  label: "Ethos Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiB2aWV3Qm94PSIwIDAgMTIwMCAxMjAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiBmaWxsPSIjRjRFRkZGIi8+CjxwYXRoIGQ9Ik0zNzAuMjU3IDM0My4yMTlINzI1LjE5Qzc1NC4wMTkgMzQzLjIxOSA3NzcuMzg4IDM2Ni45MzYgNzc3LjM4OCAzOTYuMTkyVjgwNy43MTlDNzc3LjM4OCA4MzYuOTc2IDc1NC4wMTggODYwLjY5MiA3MjUuMTkgODYwLjY5MkgzNzAuMjU2QzM0MS40MjggODYwLjY5MiAzMTguMDU4IDgzNi45NzYgMzE4LjA1OCA4MDcuNzE5VjM5Ni4xOTJDMzE4LjA1OCAzNjYuOTM2IDM0MS40MjggMzQzLjIxOSAzNzAuMjU3IDM0My4yMTlaIiBmaWxsPSIjRDdCOEZGIi8+CjxwYXRoIGQ9Ik0zNzcuMzc2IDM0Ny4yMjVMNjI3LjY3NCA0NjUuNDIxQzY0Mi40IDQ3Mi4zNzUgNjUxLjgxNiA0ODcuMzYyIDY1MS44MTYgNTAzLjg0NFY5MzAuMjlDNjUxLjgxNiA5NjAuOTU1IDYyMC43MTYgOTgxLjQ2OSA1OTMuMTAyIDk2OS4wMThMMzQyLjgwNCA4NTYuMTU5QzMyNy43MjEgODQ5LjM1OSAzMTggODM0LjE4MSAzMTggODE3LjQzMVYzODUuNjQ4QzMxOCAzNTQuNjYzIDM0OS42OTUgMzM0LjE1MyAzNzcuMzc2IDM0Ny4yMjVaIiBmaWxsPSIjOUE0MkZGIi8+CjxwYXRoIGQ9Ik04NTQuOTE2IDE5Nkw4NjAuMTQzIDIxMC4xMjVDODcyLjQ1NSAyNDMuNCA4OTguNjkxIDI2OS42MzUgOTMxLjk2NiAyODEuOTQ4TDk0Ni4wOTEgMjg3LjE3NUw5MzEuOTY2IDI5Mi40MDFDODk4LjY5MSAzMDQuNzE0IDg3Mi40NTUgMzMwLjk1IDg2MC4xNDMgMzY0LjIyNUw4NTQuOTE2IDM3OC4zNDlMODQ5LjY4OSAzNjQuMjI1QzgzNy4zNzYgMzMwLjk1IDgxMS4xNDEgMzA0LjcxNCA3NzcuODY2IDI5Mi40MDFMNzYzLjc0MSAyODcuMTc1TDc3Ny44NjYgMjgxLjk0OEM4MTEuMTQxIDI2OS42MzUgODM3LjM3NiAyNDMuNCA4NDkuNjg5IDIxMC4xMjVMODU0LjkxNiAxOTZaIiBmaWxsPSIjOUE0MkZGIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/ethos-sui-wallet/mcbigmjiafegjnnogedioegffbooigli"
  }
});
var Wa = ae({
  name: "Martian Sui Wallet",
  label: "Martian Sui Wallet",
  iconUrl: "https://cdn.martianwallet.xyz/assets/icon.png",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/martian-wallet-aptos-sui/efbglgofoippbgcjepnhiblaibcnclgk"
  }
});
var Ba = ae({
  name: "Surf Wallet",
  label: "Surf Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNDcwIDQwMGMtMTEgOC0yMyAxNC0zNSAxNS00NyA0LTEwNi00Mi0xNDQtNDdzLTYwIDIxLTY5IDM2Yy01IDktNiAyMi02IDMzIDAgNCAwIDkgMiAxNSAyIDExIDMwIDU1IDk0IDQ5IDY5LTYgMTA5LTQzIDE1MC05Mmw2LTYgMi0zeiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTQgMzI3YzExLTYgMjItMTEgMzMtMTEgNDIgMCA5MiA0NiAxMjUgNTMgMzQgNyA1Ni0xNSA2NC0yNyA3LTEyIDgtMjMgOC0zMWwtMS0xMmMtMi03LTIyLTUwLTc5LTUwLTYzIDAtMTAyIDMwLTE0MiA3MGwtNSA1LTMgM3oiIGZpbGw9IiM5REUyRkYiLz48cGF0aCBkPSJNMzMgMjk2djJjMCA1OCA0NyAxMDMgMTA0IDEwMyAyNCAwIDQ1LTcgNjMtMjFsMS0xIDEtMSAxLTF2LTFsMTEtMTAgNDAtMzkgMy0yIDUtNmM0MC00MCA3OS03MCAxNDEtNzAgNTggMCA3NyA0MyA4MCA1MS01LTk5LTc1LTE4MS0xNjgtMjA2bC0zLTFjLTEwLTItMzYtMTItMzYtMjdWMThzMi0xMy0xMi00Yy0zNiAyNC02NyA3Ni05NSA5MS02OSAzMC0xMjAgOTAtMTM0IDE2NmwtMiAxOXY2eiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTUgMjcxbC00MyAzNi00NCAzOGMtNiA2LTE1IDQtMTgtN3MzLTUyIDM0LTcyIDYyLTIwIDc0LTEzYzkgNyA2IDExIDQgMTNsLTcgNXoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/surf-sui-wallet/emeeapjkbcbpbpgaagfchmcgglmebnen"
  }
});
var Ya = ae({
  name: "GlassWallet",
  label: "Glass Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAADkrSURBVHgB5X0LuF5ldea79n9OasAZY+v1mak5ccaOlwrBqtWq5UTxWqeJWgWVS6JSL1VJdBy1oklwqiICwXqhgBIEK4KSE0eUqpDgpbUzjkYFbe1UTtSnzwPBTnweCcrJv9d8+/vW7dv/nxu5kNAPcv7L3vu7rbXe9a71fXv/hHthuXPZsqn7DCeOncNg0YB4IYgXMGEqHZoiAlpwfoX+AzMTp694lqjZ3nK7HQ1vB2OWB9hKjC08xPZ5V89swb2sEI7wcudzTpqaBB1Pg3Zx+jidBL0wCXRBGhm5cEEmcNbPzHoOp/+6QnK+fJvOS98k6ZPX84t0JCkBbyFqb5zbObFl/pUzsziCyxGnADy9bAHmzz+2RbsMaJYly53q5MTJrm00Zt0iWFGCLMROzk2uSQ+WI52g5dqsEBQUAvk4ad25vsZaS8rAW9I3l01e8fnNOMLKEaMAcyecNE2D5rQklKWdhTPcwikLsFi5Ck+OIVp0PoOCQug5lIVcRFwUwYUelIrkeD651AtRLD2+PR2aAe3cOLH+izM4AsphrQC85ORj28l2WZLWytTTBSqc4q8xTohwYef/uDumClIJ3xAgY4Jcw1CRV8pU6gX6yqUo0wGLIoIr5db0ZvMchmvnr79uFodpOSwVYO6Ek6dTx1Z3gF+EpsJ2BVCL7nx5RAPz/Vkw4CLg7r/uy5YrbiDuQDmAzgaVa8q53AoXQO1SmjB31ObuMbVBmbTNdE2DzRgO106uv24zDrNyWCkALznl+CF4TZqwabFaiHXrGcnSSCytwDspAJuASI9FSy3ET67LZ5kltwL3hRiWV7LruSCIuIhYLwLXkHasX9JXQRflF6me2fR3zcTHrr0Mh0k5LBRgbjpZPNHq1Jtp8knPCkCRxWfYZjj0oyJ7YnnqBopbEGYgyBG4QrZ0LrgSEUAErt+bgMXvN+F7VktnNgJpPSt9oe78cF4+rcHWFIqunXfxdetxD5d7VAF4+qSpISYvpYamuWdBJMLj4GvzTFZwrAQPqF1ARILyfYF6PYYQ/2eF4E41iDiggR/Pp1eugj0aAEaIJYXruISRWUFYlErHllzHzM67aNU9yRHuEQXoQrkW//6M9HYNR0KVeyQsvCnzyIHUqaCgx+X8/FKOWVhnSKKcIdQPJZImZIpMHooeWXTEFcRnReguaTrlbKVdBDKKMKttrpopKJ67psBHsGbiqF9dQOs2b8chLodcAfhppxzfNs361PKUQT2KQXDw2zUHCK8k6OuCByKzV5jvvm4y8SsNU83qI8L0iGQScndyWzqhGER93y8cBCHCoFGU0DEClmuoXZqgQtPQ7BywYv6Fh5YoHjIF4OnlC9qWV6e3K3kEMkcFqj7TCV7+Hj1LHoVmxOtzGFhei1KwW6MigWYFVXzyFoX9W8ZQw8ZMQlsTouCEoc94RChtwVwAIgqguB/IBbhg8q/+ZhUOUTkkCnDnk5ZPzZuHTWm8C8cnbICeb44TV1mtJl4c2itf34Vc8i5MdNawViKImje4hRbn0rfMvtXX2cFSQ26T7bgoQCGskHRyGJsRyRIpljHVbfHsZLNzmj58w1Yc5NLgIBd+yorT5k3iO2l8Uzbx6nZRyZ9JzFJf1bClJgnopAYERieRXrzGNDvLQQRRqL+mjITEy4XRFEIcqP1SGM8EAMEhWEgRuiINKtCb39IPrLDE2muox5PTpnbyxJa7XvfsM3CQy0FVgOHTXnF+S1ifRnm/7jNr9GQTo4XdmuA+XE0dcKWgynbZBF8Im5/r55MrVW5czzffXCgAK+VIpW3Z2qCcIiY2/SrEoRoC1W0Crug6pqDMRV3E63jdxhRYPMuC5GrWzb3uWatxEMtBcQGdvx/e1VyaZmpZhPJMrQr7zr7ZuYBn9DzWFqtWto0q9SsVsmfbStIFFWnUxJFC/LgYHxhJ+xZRtLYaKG1V7sD6xq19ZiOC6gJK8igmljx89RC3KGecD5kHTSIRzUxM3LXiYEQJB1wBOPl7Hgw2pNW6xbkBGXTRcRGxWq5G7ARfjZM0qyFrZPbscTt8onvK0XKVjq3CLfP/Rcm6jw2qKITqZFLpYxSMKgtg0QMR4rGsz7o66VxFZ5yLfTemKpVCxjmw80uZHQ7nlsy/cPMsDmA5oArQCT+FeJtSpQsDpI8slOiAS7glApYpD9YkEYKwccQVPKCyTPhKH0SIFkI2RDEUq0iYzPY4YavSxNAUwUmj931vhdFWKI1iaLQSUcWsvSutoB1GwlJDDqLZyXZ4QMnhAeMA2fKp2ZTeTrXRHfbZnrwjyZAaoZJJVGdLFT3yeswZl1aD+XJgVORtqy7AhEmBcijIsJEFBNHGpnQAom+uiEoAnCZaHaxctVsuAtm1pa/qs4pz0vFhTICEAqJp7AvnmsHmO18zPYUDVA6IAmTho9mU+j1lphxYvfMgDlxIkJ9qbZFUr4KnEDlmZezq5y2BTz3VolFbdbanihHy/+prBfk9NJe2lRzCPJkaMZOsTZimWDM5AoBvQ3KdtEGIm7IMtQQpUNIZsVkUrGhMu3Awb3IT/9nTF+IAFMJ+liL8QRF+jHcpGnDOdIkCcOU7ozDMHwefPhKXi8DqJdmMI0Eh3O0ol3A4VSm6H889Oeoo4IlPAD3wgaXGn9wCbJ0Fbr+twMTYtQDVROUQqFPHPc2JWUuKc4TCgcyFFSWPS+CWKNM5STXODpvhkvnr9o8T7JcCdGyfd0x8mxtepCbfRPNUoqOoqGDfFCtW/w/xlxYIVTZcp4UDpmvkAFDfX8LbbNy/mzLCohFkXXvxi6n5o+cjK0GvtNdcBf7spznu/OmtP0SC6YjUhP7A3xfu0xtnGGMkmXXkEb8TFCTaMkE7l+xPdLBfLoB3TF6aNHOR9CzLvWS1yKZbDsk/4ztscbX5PgVUJ2yK6AyfhxIykk9bSC5BtEpPdfdAZJCOomxNQVmm5SuoefFLxgo/T9ALXwJ60YlUCVM6xEAQfrHpggpQvS/jtFSF0pI4PicU5ONAzShiIRtiOnXxTh5civ0od1sB+ImvWs1dnF/3jTz5oW9ZXH/gPerjyb1zl6r1VIhczRwJGatxMFfCUHP0uqw7mTixsW92ZpGJ6vP+iJrnPQ97nKSkBM3Jr6j0yTiA7xWVbUrBLcE1pMyN9StOmtm8EQybA9J6y3sntzZr6cplcytPOB93sxDuRhk+4fQz0gysU9FoRKspNWNJ1leu4M0TPOZLUXwe22KKxtZi58yRFlX+M4SZ0QVQpJsOv/ljUvvk67n5yIf2afz8tU1oL/qgrfXXbkdgQcLS/p6CAnM1T4n7B2KoXIWtYf58LpRCeq4hhdQrJs6//jLsY9lnBeDFifRNTnwniWqBrarJpNsGiQZqsiTr553bZ98QUQ805gQ8aRKSM/aq8XH0jTr5Qh4bMTru8YH4/kEPxGDN6vy6z+P/2g1oL/4QbHuYWvdIO11pq/xE4AoFLIwjebKIqnnB6PxWwYVnT9P3vxiiPW5fSeE+u4B2crJj/AsKp6sRj1FzGM99oOTFwiKQcjlzp626DoVNC88dIM37+4WVR42LquaF5Vj426w47W4JP1/9tKeDTn99GCWCMgZ70s7DQ0RhCWSDZK78BMEoQHjjTYSkMtw9su5HWDBJdAOvnF6AfSj7pADDx7/q/NTrhZZCI92kY8SnYjTqyk35KwZEukqeD7M4ORLipBtyEGNsZp+XjLa2Gq/+F/W0wa1ejtFL/gT0hCfsdpy87TZgxx27PN4kJWhOf0PuUai+FprMhxyAc0HYV+TvFRBt+mxu/RR4ZkmTFjrNpaQVk0VzTbebeu/LXruAuce/ajqh66axsNp1qx/2BJ/VwkMuUwyquYABAwWrH419y0dyrTIpVGEagHpzSDm+aCEGHzh7/ACTwNsvXAv+4rX5fb76vkehefwT0bwoRQkPeNDIJW3nDi75YDCjnquJMF99j9od6NiCG3Vf72pd7yTK6w2sfCu2OWQ8PbmCzdiLslcKkPz+Ap6c953UtakqIQJIIsUGQLUCtNJR9/vq83RNlfskzxWnSn647wRs48VIqBmSSOP8/lnvGg/9yeLbtWu4vX1b31/bDDWnrEDznOePzs3XsxIUhYzCln4argdBV3PRKFRwTHrZ9UquYfuPhGPBciJVKFoSZDw7OcTj9iY/sHcuoJl3Rqp3oTSj8GW5WTYbVfLvOK+ZvXKV+zzdiGkRPVAzXy67uEMvxE9qUA1y/87m9dmRMsxhGsIbXjte+Dt2JOGvZd62DUWnAqxauJcOXPFxbq/59Mjl9NTkDl71RkKN2ICjv/l4Ni/uXbRQ2YaY55FCPkVNxJeJtQUiChbgfICx6K4GK7EXZY8K0LH+lrBGVVDJjS7iRd4j2SyhvSP8huLMCIibUlsdeoDIgK0vlHIe2NDCHCIZ2bB2uv6cmPz+Yx49fnxXX90Jn1hwhY3MMgdtz8faDZ8GbxivBINXvjFUCjeSIDBCsHbXfmmvGLgx16gS5dwyqMgNOOANoYLDdNbqO1dOT2EPZc8KMJh3vnaEo5FSvaUJCNk96Y4qTM8uNGJWX1AWulCmiuvMnl7j17N4SoLPg2kAq8Vpl5PgH4UmKcC40l59Ndprr7XsctFfQRi2bEsVWrTXXMk8cxX368pI8MozoMiYt40bIoGD+jP5BJY2RV/Vwi1PppiHoB3eFekvBWWwkCl/MTGBS7GHslsF2Pm405enVpeW+tgE5tm1oHRF7XSM8lpU0XCKzLWLRhNIM3xlqBoMlFkJ8CKDg63AQRxOFXqp/GUzT4L8DP3jyuxsZ/1lYOafYSsE5CpVIXv3dnjNpzIajExmUQIK0Yqmhk0wjo1A5SbUINRrsaKknu0DNUpN1WKlVhGSC5i+879NT2M3pdn9QVqtDcf1avP5I2uWXHttGJxph6CD1GMFAYoyCJ+IsbC+stq+mouRvYKZPjflxIIyb3jNeL9/2zYM338O9NyyoGcooH30Tzby/Jo/tTNXot1w5UjV9JROCVaG65zSdZrRVmrtxzmYui1YGqcCEAylVEagkdnWbrpgBth9WLhLBcjWD5qinppWbVUjMQU3X2eOgHo5ENEVCtVW6U+IpZPEPWTJL90wUtbEqglwfMxmceKLQL873u+353wgkz5rB4IwArMFWrUfHti4Poh3n7mSxylB0ynBK86oLupG0MKToAEOPKYnMQKKpAjB2j0aVrZgkxc76ErU/Zuee8uS47GL0uz6QLPaelWDFgXKEpI1NFJH8FlcXS+ddZWxC4JAqfpOLSRux2U1S7VQPfakx1Nz0oswrrRXXQ2+ZVZ0r6BPF76pilFVIxt8kclMNFDWLNqZRAw3fnrEOpqnPAMDVQLON5lXrMgg0Fkyc4Czes1Q3J2OmSyy0lNsfVRRSsYgDbZrsIsyVgH4uNd2GjMlIF3a4OinrV15MyblyXoTH7tg4NqvhN3JF2EkA27p1HBB8COGMEHB6EEPouaVp2DsuDbdCL7qM4ClCuTWcLcm6kOK+i6Opmxko4xwuCFxgpkx7uAPnpGRgBqKiTDiuGxmgqQKUBnmmeQLnd5cATNqMu2N6quRmK6qXXKB8QqQNIbhUJe/C0s0ym6zB/cYVs2HI/GXcUuqmHWWzbLExjxfwHojBtklQbkpQkbZKVbPUPP2N+3S7/Oll/UslSqfa/21Q+IAKqJZ8hNZeK2Ps92YOMGnLhlptklKQMvPqPhDdIeuWG4I8pEpuAcjfmW2NIlS5QDDsBxBJGocUL4tb7R//S948Wum0svxMlaHoYAA3hxVAygLOhGLwzlsoy6zamu9chZrCpRMZyB7Pyp/5/ADSZRIfemrk14IPHwhRsodOzBcfRb4jh0B+s2q5cYPs3Y1elPMulD9lrw7/KX/ye3HLhhpvlOCwYqVFVYVYTvB8zGbVZPmVArqOm1wY/CZtoU5GRhHNCvnTN/11qceO9K3/heJqKzWGJu8MxbNsWlxgT8dgC7U6vnRV5Oy+ConIFdIt/32SMuFl6CifHKV4tCn8loQo/P7L92F3//4ZQkBbveZJVgSq8y0J7R8fLD9qWEbYYHeEtwiRhDatfYbN3D78VEloIwEK0mi2cAkwIi5Hfme62mK8S47FbQLUCkmTMGAYLDMEy/o92tEAah7Lg9g3inm26O1mwcr55KG0naOATaXHaGVFGGqa5qtQogIIB/VsQTXYXCY3zzwAWl1brzfb6/8TPL9X4Vl9rhuv1EoNZPS4emY2UdihK1opxHGAMUoSoBxSpCRYPlKuB8AKvShSDD686TF5E26Ghr5GcxVw3yMX8Ij9xpWCsCLX700nTulF3o40tcuhx2DoBAKcEQGVwgOLk19eyXlAgjs8BhUSTgHUOtQEeI73kxj/f4tW4GrPmt1wODSZ7h1uStKeZvcW6OA9UcuZsvE9VAJ7Teux/Dj60a6RE9OxHD5qqpWiXTDfJFNi6ZQHGXcilhhmcSNBQOt2nRPvWDuLU87Ph6rFCBx4mXxajd+rgh5MfT4B2VzErtbhk6dAX+IqEVxVCgGe0Yh4Mkhjgoh+Bl78dIXER7+MIyULtnzvnPLPFkvS2VtHJrXVDoU+kU2PMBStPI+M3kDPkNqBCQA/21CgktHlaDplOC0lcWhFq1zzhOF78QkyMRZL3HFt3t8AGUqfeJKTQ2WV32JH4iaZRaeUd1s6WlrWggDLJFecFHaUaEMFFGsOG3XfobHDhbLolK0Yo0ONYBC8JMej+ZlL8S40r73vML8YQG0I6/QF3KUJOtXmFGFV4Van3rrWnDB5GmDUEd2B5dewP3+NU8+ISnBqnJllfnhkjUQNK+CQ5KGQjJMMUdoGzycLkbojszc19K4a8i3Mjz2tcdz94xdJzRVnl5HidBRVrM27wdTW+mc8L8QL8k4qskEdHFH+tsyef3ou8UsmgeneP9PT8a4wld+tkv2oNdkZCWqQ0EZzNbiGG0lUNTe7ZEwvjj8Qb1O+7dfoeFZZ4zsMspKcOoqkMrM6lDFZHWcxKTp8mBALmeUnIYigkAHc/Cd0MP3/9V9di62PlijA15eGpU8ulYViY/2ryc91wFxZpWfFmDtWQYJhFHt1gDX4GJ9oMpna9vNmcl6HvQA9At/7rpE/D7b01Uo/5DphCsUm8Gofak/lvY0QqgE5GloChRHxhW+g+naT3+M4Qf+fLwSnLLK0TFgnPUHklRjrvQuz5/MIcdUppIHgqy1AHC+lUTd2HZ+RwDmxap3lugIsZcnaty6zXphKhabApwYerwfLE3vd3ML9ImHDoqFMMT5f3kX74/z+7cX66/wRnHE/bMHTk4+OFiK8x0Slm6jo1GksLX9qg341Fhpf/bPGJ47qgTUKcHJK6EcRDpHPoXlVSmQdmg01BbNZqgv0KOqHIqyS/VI2VyUkj9pBAYLtiBdz6RbtyhZPVQOeWP50/P1Gi4xomZbmifOo/Wa1ca0K128P87vJ+EP3/HulOy5QydMO22VmVVJTsJcKCmHYRumX002AgNDhFH1JiF+EHtkjzTSgtBPkxKc9zYeRYJnYnDqKq8WMf5mIPIT4VWWl9CBAL0VQkNqR6dy1hS/4w8W5na7P8MkfJ+cIMQAdWW3busTVymHjY98AByNjyic6VOqbD9qNGsmyyzRHM2D0/r+a8b7/faSyzPpk173D5cMqhLSeIL2kdW+mS38E61GfXpvyHYlqD5JQxgil09uuv3pLTRWCZ70zIQEq4QPtblaR0qOdyGWnoVsHMscV/skLe4lcuMsIDY3R9O5ze7PoMXxAsVcQxhzrfTuDWVsfczvzxBqVi35f/meEOaWEZ2gLTj55czNO1eO9/ufSrD/zW9Zm+auYiGhNYG1c2XevRCOa4jVer2z0ApFKGIZ0rjCGQdjKJpdxt3+9Mc0PH+8EgxOeZP2WV4kCWZuKtqeyESdM3pGrIMxH6vXDY7L7cmJGf6d8Imv56IC+mgWmzhtt+chODZaK5yhiJ1C8YEMms/Q+FqzK+RE9+UvHBvvd4Jv//oaGWURfKP8YdQPuGtj33QqkV7snz63oFzG/Q2qAr8x9tW6JR6zlHIwmQiQ2SgTMdx5/ttGieHvJyQ45c2k0Yoqq0ySWb0Qa3X3IwDk3bXNVBxkdnxuq/uTwGaxD83B0CL9KgaHojTxGKwNgbF2xpMlYa0gGlMRvG54YI4Jo1zbkx6XoHEkjZ39fnvxFaE1nQiVvTseU2plWmRf246wGI6zGLjG1br7iKoQwlr2+XHZ61RJbWRzYGPrrvhZig7WjUGCpASDk98krlfG5sgu86hI54tFekI+FgxOjc7PKLu86a5Hv27xxET7bXiC25E9ZLhLTl9v6BQoa4iqW2OoPM6nLc/QrXUyPyCihfgpeWXIqpO0rVrOft6DU57//W8HHjwK/cNXJtJ02201cMdEpKACyIVQPZGUZIwqEYk5ZcAuKamzzIGmpGFzRGoSfq8fYpqGLd/JqJ6ARqaZaP7LMRisfN/IGNu//3JCuPPEs3D9oCobl9VXPulNOkB1js2JyHpyYriooaZdYCImChilrsA7ExMn5t/qZBGZDvWvzhBbLWqJbeiD/JS7Gdxm3dqV8DlZPt22zfQ2Wpl1toIAB+MAMNZHNp2gup0gfF24ER215xmx9p7d0ZsAJYvN2gcO/AbunvlH30P7mYtGxpndwXNebqg7coJI1vfPoSzLB7qFCqjJ0P2uucFxDTftYjZFdU3qN6ibMUMOiC0sRYiPBSpbSDXVP9kRLfS+9iwebGu4SCcvGy/8jX+DduN1PsLo20s7oe9CJKJr4jB34koDVYln2HtLC4sZGE+x6ZCzJcxQ/1IFRqFCNlSWt6nu4aYZ4M7RexKb556MwXTtAiUv6K2TC0cjnVFtKTOj9sIDTDUDNFOk/XUmWxkTEXyqBfMQGbQx0HANzOdDpySfzKFytrpLPMt+Dj3zqaBxfv/W5Pf/6nIhQTqSmuyRTT6CMpOllT3XYiMQS7SQU4AuzK9IkwOaVzOs6BhBbxRQHI2JnCYS/JGX3/07jCvNc08Bzb+vzY+k5jxvxL7+ryBkISGzz4w0nt0O01TyWs3CfFkbWhNbN2GzJxLU4/h7mW9NVJhQEKMmNUmLmeQ8tcqQtUqDfcgDuDllvPCHb/sL61+lpS4BH0WVVuOQw1Ckhiqz2GCtx0q1qlDVDiAolQzBQ1ZUpIwhTwMzGfBISKmf7ryDMa7MPxr0iGMqpdUMpn2EdcjptoCj+z1ISiFPwP06arbA5qWKKYmCu7KsE4Lfswpl/k0R+ohXhXyKi1StX0vYVUjOOW+ncdDfnncR6NZtLAMUDmIthWe9ocbxAGniGu2HHDiGUdp1mdeSC0BQ7NGizfhApCeq1ObS/PJWBNWPovMUzj+asItC/+E/Ocyr7dlsm1wQ1CnomXlAKmQ1XznVcH4osVunTkzslq5GhXp90J4fKO3X5MscnKCdgy8FT+AAg2z54/z+J68Bf/+HGDFzX8U39+VmoUbvZkoCFcYbQ/dVIRl94Daf6q6HFBEj8HMmP+yPKwizEEIwVEdgpKCr83eOwa6Kuk+yUTqo2SCD7JwgR3tQZMjvp7q9Wgv0E4fJI0P7yKxRfw7tepuikyFhUcE7gn6pe1I2+eynEZ1SP3cqn/Z3/wftJ2fE13C1mVJt1b2cZpSVtCjkG+yb39K5UGuvdzgBnqJ25IvhbUTIOAMOjgi9Qi+r6kYnb4iOeTLwm6PPIbDyL7fIsCXILIgLz0FJdAJmqhkhHJG4cnUJAbqEgH7ur/8zAoSEY671vlRWA5rqkbgAO6XSCAGiPPnJ6scJv/P7fO7Fok1cr4DlJ4F3m+4bnwHrkrod1kM9XWYjTuTzhGoQpGkJVzADDo6nWxhq47LmosvkaoIsl5778lsPRvMnr8Yuy7/eCv7eNzjOpy6xl60AOt0KbKqqbOoYMIIEHhc2XMXHPkN273lAzzJEjloRIDkS5yySMHDzTJXlRs7VnPu2Uei/Ywfa//4exi/vUL/CcSgW9JnHrmde8jLSlsy59tbjfxcICNWziM1/S3uR4ZjplpPAPd6j72z6pEIhv7ri2lXYPKJLAp2dlGDX1t8lhFwG3j3RUslGsZF0R3LiYMOsE6ZkcUI657MX8auJR4KviWtAjbsMRfNshVAnwLYsqve2t570KfWcunS8379iQ8r0/TzfBlERPGi9Aa8x4prsgbTi4PIpraKuZbn9CvYJYNZd422NJSpv+0VRuKvRLrEFwNovVlsp+0ssIk1K+vRl1Lz4dOyutJs3YHjdFdCgzOZUyHWQjGZZnfI5FKsko1FjgnwqhS4Re0hplZFPS5GsBcLqg8nVRFZDEP2U1lnmky0yaJ6V4v1Tl40VfrvhS2F4AUZJBKsQ1VNfsfuwuMWa9KNekGLWbC+a7xEDVU6rUgwXFYk3Om5VEt1Qw0rUtV8Gsvmyo49OS9tnEv3OY7HLkpJC7RevwDApgON0yz527o9BAnxpRQdk8JbHXn7msjzKDxMu3LZMFTkvyZyogem2DZWjRpkRaphouf7o+zXnb16mO/khye+ftnR04P/8k6QAM2b17tOKshVg0WjVaYTWGxdcDMIpCMgFY9+qZ+iNxfb+cziGoAZKnszSqcr2mrXG/tB/fDgGrzsT2A3kdz5/50VnJeL347oqCvBOUc3hI2CuV9Ty3LXuMfK+jnJ0QnQCKmCfTM4Pb+TwCFf3fX1r1DSBXE/ka+/kliX9MV/anPfWUej/ZfL7ay6AG15pTTulKdjST7UD7vUOERS1m6Isuk8DtfrCyGx/SmHjYiWhAeHFAxgss066TBIpGcq/GIDm6X+M5sQ9QH7KBrafPDchwC85dNC6Im4maB3UvML89p0y+ZqwR8P5udWzcdnQPT6R3PgAVnvXvpBDorgd1n62tT1Yn1Uz86euD53lP2TU73ePZqNTX5CjAnVBUCyl2gLF1ehxUp10uXTfNHL3j2t4mDRYWKSnx1Ah+AapwiqPhDKf2d39pIIRslYMQyo56r7UvPZM2qPw04JQe/FZ3MG/LJSZo1UIBGARmZ4DCi6BEIKPOBsxzs3eYnZCjpKeJcpRLC2SNfOdgr0ym0qWVKtUBNlTyRJwbs/tk/GcFO+funSXk5DXAY55JHjmS9xuuE6M1VI6MjKGuwXYOCvTJSPn+hNOZSVbRkOqqiSTU040SWsL5oooWDrCu+7M7pfGGq9JY6Isng7y/+wdNO5Zg1YS5A8/cT74n77LvvcgVqYjdA5VxssaSpFkpzx9QWVhkExzyV10V1FD2yfSxbPpzZQgnCzNoufDRK4qiqBp5vMiK0cXQOQAtVzSwIfy0LS+f9ofY4+lywu8+mU0WPYstIkQ8vVfI5lRBRsfqO5T4MpMzcSFFJn5GA2JosYY2K8BABpuwQxADnRDbZyS6uVZPU5YiuakV2F3pVsKHl707m4dQHUL1itovVQZajFE1v0Bqr0BHvUZjAR/xnLpu0M0b6fhMa9dn744Vde9y7VmN9B1cPckiuM2eWy2QjLhXfEneLOe29U6uPL946F/T6VLCH0yRQZf+aooXj0d9tl9s4hX2xe113Or46Xvxi0oxjThVeuWcWtQ53zJ6SIdlRZvXnEGmuN+f7fDaq++CMMbNqK/+YaDA6lUggIah76RQLOOj40cc5aFswO4R+1+ji59v12hQf5oL6indSJChXpj3plKMFoHeXMcwkykY83yZXdP+F3pEOFNp2Pw8hegvT4pwVe+Bi67gGUw5fdbOfQq/FysIzxFxh8SeoatHlXYqxI5tXCbSgWjbvi6Cyr9/e0pbl7/50S7g/yf31Yg/0ff42D2pr4hAUNCIL3bdo70L7hkeIymj1yDOswK4wr36TgA31KiJDZWrc2wa1eZP4kdA7fWtmC800LU0GQ3X899CtHyvYD+PZVui1h3X0D6lxeHOmXo7gK+ZWsAdPn1eZVcwHBz4xrcNpFFuHsxeLVJFl5kSR7xrt08NjKDnTc64flolr6UkBBgV4V/9H20H303d5AfU0amZOR/lZhZfzggMNBzWwxTJrmarI5ykXiAPAHDhrdOJOe1lZwiFG8jaRObOkJlF/obl2pVkLZY0Ctf2bj24aEPIHr9STjQhR77qPwvlzt2EHeK8ONZNDt2dDeIgFIqmXek127DZfc00NtuC0JlC5s0OAScxVgoBeO1YetQ5CJiPEcfTc1LX5mfFbi70l51MYbXZ8h3xsTM1X5CA3ntlxml3SVFjnVBgYsQAhrEYxBUgI4zfdoyMRjwlrZ1A87yJ8e2cDVcA4DqjOIu2EiaKlRuMI1t3VuoC+8Oajk6hY+/+6j8zzvWK52SdA+IvPkHhJtvBv3wZtVg98CBy7o4UEMoURBAGvPDFtHEG98O7Any16/L1l+q9IRO+QlaEXJjkydGq3smC9ZrHyt00i8BRC7n2m1nkTn11OCwndiev22Pec2/orsz2KxbcuTVwIsLqNML7ETQfT3Lxqly7RtOQvPiE3BYlm3bkjLcDP7M1eDbOz7hv1KqylzcGns+R8iZECFqnpUg/wUJ3XYH+f/YQf57Ehr9EsamjIuw/6w9uBIgyS+v2IZ5dWqkSSC2HcuBu6EE4cFEFTEoyBLYPu/sr95/Qq7amqq7v2pR1k7h7VYM6Em4cwuNDGL4B035dEef++TDV/hdeeADQdPT+R//7/+V8u5fIPzwZolpyFaNdCrZoDh9cdR8NCfvBeRfeUniKRvZ8hZG5cQV5x9UNIGZ3xVTQnnxhEdxsxBXrLV5SOhaEsGf600Y2cCbLd2nCWlwc7r82GK5uXmDefV4IyNTC4dHTzBGmspDfpPpDScRjpBCT3giBukf/+BmtBd+iLvfEIijdkaU3j9sChMr30Z7hPyPr2P+0U3FBi11RLVhqRuoqKD67+B4JCSrehQcgImCUG2/E2s0tBHl7vTlu903WQESG/xuk9M9FJMLUNZoXVfGrAMxkFGV5PKjTf8u+eMPHgK/fxAKPfoxGHzwo8Rf3YT2s1cl13Ab4q1xzbMT5L/wxN1D/j/c1D0VBPzzW2upiu+NzL8ctDAc5lKFlpXjLEEHjHgqLqg8PPqCWXtDBsakrxbQMm/uXrMCDBICtN5TMgiKgQkh8E7FhrZmW6qly//r3Y/3D5NCf7gEg0c9BsOkBPj6JqJEMps/fQPo95642+vajZ/K/wD4r5ZK0eDTw+jQXoecDVX3YRpJJHjCya+A5jbN63bCt6SPEkvlZTCS330xb3L4HalaOrf4tbckJZuKWTIlOk4yGNX7cqUE3fL60N9Cc/X7cG8qHRp0yLBbyE9IMfzYBzPhy0XvIHBQdvJmBDvkVGROZbER9pNzMr9V+h2SeYRmaok0a5ujhugE5HwORDCVLfPOvjHcHYy8mXWj2jXIVnaoEFaPRbXe0hdXFFOl//ww3NtKhwa7E34H+Tvfd2Z6/X4wOEuZOX0gqiJM6r8GyC+rfKI+RhOUQZIGBxaKlv9pRFRav3j0bM1Jd7bosaAAmKk2PwK6s0Viztpr5b+SapQhljYe8dv4t1S6h0QPzz4zkz6EAMhyBBqEqXvUQAJun1oEsi3vBj81HAfCY+AsUIk1EVFVu0cARSHnQJfpuRP+5ldbWpr/i3TCAqqSCjHpAZiKKw9A7Aryho5/E6WD/Iv/EvjHm8pnE6lSZuF0jSef+yJXrkVKzvLmJd274hGYMTiVA4X3qLiZaJ1hD1lAYcqC7fPf5z8pZwhAW9anRSHeqDqs1ZFXF7rtWOaxRmmI/+knuLcX/mGC/Pe+M0O/W6XZd+RpZrbMbMTPgQB+lchH4Z5ZGYHKLbTPQZUopv4K4sRj1hPpS3qzMY6lflIosN6dUh9IfEwl62tdjQcJ//dn92oU6H41rH3vO3OeoCvGf2j8+QoEzrb9XoRiyxrQ630X0YEzOOhIjMGqPgW/TyFbYCv35CxjyLUCjHR7uPjV/y99eT+7ld/8iC4jhLDC2EK4166Lfk48ISWBTtzFlByhJUF+e9GH0Cbr11SL/DB2mf0mBOJAoWPVmopEBSSbZ8IvpjKZQrgN589c5Xk4RGHuDmBRg26MKQReKbwsiZc6Z+e9/8ZFcVgjTwtPEcc6ZYuyEBG2KtTkw4ueJ77jqq+AL/0c7i0lQ/5fvCtlCW9iclbP0PyLrYCH0Li8BJSMWRSy6E15o3N/yClaFSyaJxF8IIFwbPAIQIkndNVGmkh0ZHN/bKO/GEKTM+zjQ4SlYvTEGp8IWdAHRQQqkE7qFGD95xhHeGmvuQrD/7EatO02vV++TC6V7eYu9NpTluSZx3WMyNskXu8+trbCq9vdKxLBvbU9iEth9yKVD0agFwb9sgo8R7S2P76xML1z8atT6ounDV40yRPbCL9nK/pPmmzwBEZ6k7KCtOIAbAQ51GXHHRied3ay/pt7kBskZOOFL57puUVH3FbMuiUpI3MbvmcgLPOS5YcLthL166fatUAdPVPj64XFW2eZ3Dh5zuYl/WGO/80gJE0hdflsSWdPRCCOWKdE4lcKapW6sf5z6d9GHEmlWxAavv0t6fUHI8fCPpByblxt95PyX326uvJEFYqhe/QU4kqMVFpjJbDwrZjlOJF9N7Lb1XyGHi5MdC3GlLEI0JX2uFdvYtJfD5FqSYArxqHVE6lKXxolOwp1HTFcsRQHZEvYQS7dz8cPP3GppWjzIBqPxUJqh3dpmfnkuHij8yPvKTrL3CpzlXqvU8QehOvnQAADMSylDdGjHZudd87mRePGO7GriRjycG2D5niFdyEAAchgaxBBjVi2ZspHsolrEwp0W0dp+a7vB7hHS4L89txzOFk/kY1KBFWMEJp/DagHU35E56siIehP04WFIdmwqXedadQg28+gOSRP/VTCB3uYB9+sWl6YI2pAFogwxvd7HbspGQUanrbNSyM8oHoVhBhZAFHNRn6fFGDs/YD3YOmgvv3oh4Ftt8qaqe6AYI+rG4Sdtio0mWExjto3QxdSJOrLqGi8gH3vhTBohkmfjH0rD1C8D6rF5veNM1joGdAHPDvv3BsX7WrsE7ubmJQ0SCjA04XRVpYQLKIarnU6UxoSsKPwjJz1M0UnDxMlaL9wbeIo63ULtduPx+rk7Aqq32TbNaTI1mwp5XRWyq7QLpbNvT7EmF6ytkK93KVoThfaN/1Iso0voLNWKZa3dnfj3y0C5An6vYQC0IiAbYDyHKR6mbJ3Y0j0aRDtVtbbKcA9qgR33NH9hnBh+V0JKGZWKfxGWXrld5X7hHxp9NuwhG1IEIU9lazoIi7Wkm7eetkTmKtqMw8hNbrGo4tyYuQqJiOmATYm5v+C3U3DbhEg1z2kFTzgWwqaqyZLXAvXbpIZUgJSLSBZhggw/3rZTFH1Uw+9EvDNCfI/8pG8KdSAksuOHA79VKRTzxqryPJrfH+NAp/qQwmJVRPYDDhs7LBaKXADxFWW7i7uRgOr3l4tyfKF/KzGJ+ZUds5h1Z7motnTCbTlwtmWsFaFb09MYMe50tuKH4iWl7fUYw46Av7ERvBlhzZE5Gu/gOHqtfLbAuzKaYKXOZawzKE5qIAleBz17YelEDZvIMxLb+2khGYM+T0l2fpN4TcEhVdIEkkR3dpi1jsbxOzF7ebfW8o1r52/bvMs9lD2iAD5pJ13rWsH806j7oFSqsFknFZ0va1yYqySjqmqbhSNhCg68E/MID/i6WAjQfe8ofcnyL/pZkuUNDIEI88CsSp0Us6jL4pn6uyCUrCvuNj5bUZxjhGFsahGbahp8gMbFN2VJdpdfOZaIIrXelscwtBACrjL+bdYtxezsmcEyO2mpeKW2hXsc6LyNa22e+LhgGhTYROp6c+W9Uiu5LINjMs3Mg5S4ZsS5L/5rdxBf4RQdVmRYAUIdromVsn6LQcyppV4ThiKHCUKEB4sR3QiAjLo+dAkkW4eoQAeYV0ptoOea8qNDlteQes2b8delL1SgK5MfuuSzantdeSoX90g6dheetmye1c5zhbq5PEJPgipGX5iA/HlG3CgC3/+Om7fdRZ42+0+VQKh8jb2Uma5muZCWuthSlSgfAdcPWl9pB11JRRdQaXwMikWgVTxvluTYm/Vhvc8X3VBgv7N2MtC2IfCi5cvaCcnv5N6OKVX1wxZ8g7ht8igqhzWDkDOte16UfHm1GXjnxe4r6X7xfDul0M7q4/MPKud8nIPtYoLCLoaY3oltRSmWd2bx+9iuW0cpyaAfD5CnToHTbjLSpx8OZ2C8zAGVb5XLq4hoOw23jpx/qZF2Iey1wiQ+5NcQTMYLEn92F76Z6vhhlYU0NQYVTF2G4I6Xl/WJNs1wZfPYL+R4JataFe9DbjJcvnR2nTzDnsnjcxb6KIPcyOZe+1e2fdgy+QQwxULZnMx0GUjb5l1LmJjWrd1jvw1sEl2HdMvuDLf9OkXc8xLsI9lnxQgd+ybF86mrqwyV6AdZjUc6ZxEUaV3NTki9QPCvAoJg2+eunyG764StJ+7DsNVb0+Qv00bB3qeMjpcNjuTJBY5DLtgweZ92flLGFvwELUQQ57ETpFmqR9bRneaX8jcAtnlmt5FrThtWsDbG9bfLwPcjXLWv3x7y7se+rgFCbuenAfUhIE0sPRZIYdhUk36LLtXoPCpAXGelbzC9r1/yNyIjnnk3rmpjuWf85fA578oMBtcMmk7gkbRyrpXiedNqOShqoIT3Is7T7RdUjD2EFyNMHilFWRw7zRQ8FIjJXWpXh+s/mAyVp24rnRk7X3W3XC3bsbYu8ndRWmfePoGpnZZ7h0FRyB+Chj1+9EfxzVvjvl0rSnV0f1Y1Ngfjojlxwny33Me5yeGWC6crA5d1dNJV99vPfLcvvtg6Us5bjQ/i8pvygD7cxW53NkD9sQPRZ6D0XE3ygq5PO5YHiXn80SWRWVfU/F5Kgo5M3nB9S/A3Sx7lQfYVaG75lbwbwymkH92zr1T8Gj6UilaQQOnzcpsZaFNQKH87R4QRbfdXn417EGjzxLm67/G7V9/hrBjh3KlsDmCLcSHRSzMFPxzIazkilc5bQRBIlBAOZM9BascgA19GEUn6hlRq4U9WMvUQlMAkqQwzpQ7WiXiNCwgnp1I4Tn2o+wXAnTlzictn/oNDDal9MSUM2lWWO+xYyBuhtTn7VZM3LwyGZdQS85PAznmkaXiW28H/v5b5UkgZElbea/X9CAZQFyPz/0oGzsRLY/8fYFns+AQHUCtXudQLJqUNPgc2N6IclH1jAHroz/PqN4N5H0O+f/sSm4ZDHkJffiGrdiPst8KkLuTlKBFsyn1eiEHshNhEGH5c9QFhMGFzRMeYrILs+dGXMj6uXZFcVOFn9fGR7LocqtUbLsfpAoevTfP+X9vYcZdB/dD3aqPCNBu+OIK0SgiRKXRG0S441lbh3cNl8y/cN9JX7/scxQwrtA31882aJek3m2VOXXtzUaiO6f8O6hbNZ9cP4QgsvD+9+ETqdMvH0XUwfEaIzc+KPbeWsCn9hqwJ1xUdbwCFuZeAlADC9/uG30KwYXvGuH9gvMXT/yTb8UhVcwk/MkDIvyuHBAF6IoqQer2LHRm8wFLEXugJwStTGC5XiZfx1rn1qmYq5t6DVxch5kxPIM4XbNRfRySP5dHZpgM14s1xoUe/UvCKtxpBPVkR/mw+mknMAc7910BrHf2e+yofMJhjwsypc+zky1Pz7/wulkcoHLAFKArWQlKMmLWMYCrwQHwhQ/41wEhR0Jn3xTF9twe9HK5ujE2BEtckNPTvsF9W7cMBgL5Q6g6Lu2RjYHqEK/ySbJTMCe6giJYWsnVTqtTnVInVDqkBiCowdgy2Q6n99fn98sBVYCuZCWYx8cltzkj37g16thh6Fo+tZoxlyuotnF/hmH8UjimOIGyFKuykmCOup+x9faMa8SzYOAsxBpV3JZdgHXfrtRkIoMrNPBsocJ38WNc3Hs1TLX20o780X5ZCJouS2tnM5OTO5ccaOGXlg9imXvq8jUN410FVjWmZdu/BpEdg6vY1q0muE+1iXjMYcOgO1iNY7dGJo06aZbwTyydJOw0JA5MnzSuJ8QcPQmBizt0q72TzHYvRR1pVGNSiKH6gQ8Sp5RzL5j3kS+vxEEqBxwBYpn8+vo1aUSr0jB+EezNhq5f5L8sJoqgAX32FZOgQI8QFh9Mxgtr5VbCpjsrSn5I3IfYc/DmnrSEhOeoeUbA/BBOhE73vJq/j70yR8LorQuk1269ZcXBFL504OAXnk5hYotN6e1UNpxMwFqOaWKxKmVf5sRJwVmtVzBViIDG2YFIBL8Z0IIp+gJZBYQgkWUrxUPpFm5yClDQhxGzg0Cw8gq9BG26U2UfYCtIVFwRINkFRarSKzKlm51sBsnff2ErDnI5JAqgZe4Pl69rwG+EkDlUKVhGTNIopBay4Dl3EXgdEKiL6CdmLCoDwg0bejJpIqjAtfZC2g6uwPMRAVtIggEN0uSGmYoPRjdCrlShfyr8cEMJLpi8z6/X7O2Gjv0th1QBupJ4wXQz4Es5Zw6hDCzcwhwsTC26xw8Io8mhMrscwN8Fb2sBjWOIth3RABSVMbwPHIP6/TPlg64LMIhrJxT5SlBAV5asJLekDr9i8sLrNuMQloPKAcaVxAs2J1kflyZ3jYk7snP53L3ta2edEbJz+juozOmycU4o3cyhYaPQa86ZyD2IhpXVccDNOT7mWY9GC1aR9v29RA1C8vUr5NzE2sH8Xz/uUAsfuAcQIJY7EzeYBJ+fgrWlxrrH5eYdisVvG0Mux/Maq5yXK1HrIuj2TQPekIPXDGTlYgIyKNeoXVbsmyPT2AimtnpbRQw85cadA6w4kImdfS33qAJo4elTT2uJVyc8WuSkS0iaQLcLS9AeSvyiiwhEMEKtfgdRgJ5guL8wYzEKI65TVFwlX48e/5DcBLyfPX6jsL85va6dvOTQW3y/HBYKoIWfkRSBeU2arIWST6OIANGiytYstVLftNPPHbg1C7pIfZVghTzaLVdkLL9I0X47EWSKZfdJqjWLcMtTwcCjZLDjBjemf4eF4LUcVgqgZe6Ek6dTx1YD4SEVPQJGmkSprNYjCw3ghMGX98J4LJyj8JweIYMWEpZQ1bXAogF/pLwt66oCSrv26rO7eScP185ff/gIXsthqQBa7nzOSVOTw2Z1muBp1p3IMcaP0UFXgvWrpVPTf0pHd6o+l0VzD/LPcxO9bFxUrn541w/9TAlTGNeu+zXmNt53/Ze34DAth7UCxLLzWScvA4bL0gQvTb1eEC0wFxVAFnj5uToXZK0k7jJiSMjCMKuETk34yLeXjTsn1bM9/ZtpwZdNrv/8ZhwB5YhRgFjmnnPSdJr95QnSj00CWVxgWuw83JPQCamx+JzDNis2oeu5Eeb7RM8SUoF4qhIkpZhN386kTxsnJn65hdYfmgTOgSpHpALEwslNDCdoMXF7fBLE4iSRY5PA798ng5EDVJatC1TK0ZXVm1sI2cBs4TybHMWNPOAtw7nB5vlXzsziCC5HvAKMK3cte9li2tkuSIqQFKKdSqNcSMVtdN8tSMNeCNJMABC2q80KeZtNf2aTUm0fDrA16c3sXFqPP9KFPa78f3JWYVNfaX2rAAAAAElFTkSuQmCC",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/glass-wallet-sui-wallet/loinekcabhlmhjjbocijdoimmejangoa"
  }
});
var Fa = ae({
  name: "Morphis Wallet",
  label: "Morphis Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iNSIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xOS45NCA3LjRsLS4wMS0uMDhWNy4zYy0uMDEtLjAyLS4wMS0uMDQtLjAzLS4wNSAwLS4wMy0uMDItLjA1LS4wMy0uMDdsLS4wMS0uMDEtLjA2LS4wNS0uMDQtLjAyLTUuMDUtMy4wNWgtLjAxbC0uMDMtLjAxLS4wNC0uMDEtLjAzLS4wMi0uMDQtLjAxaC0uMDdsLS4wNC4wMS0uMDQuMDItLjAzLjAxLS4wNC4wMWgtLjAxTDkuMjkgNy4xIDQuMiAxMC4xM2wtLjA2LjAzLS4wMS4wMi0uMDUuMDUtLjAzLjA1LS4wMS4wMS0uMDMuMDYtLjAxLjA3djYuMTJjMCAuMTYuMDcuMjkuMi4zNmw1LjA1IDMuMDVjLjA1LjA0LjEzLjA1LjIuMDUuMDggMCAuMTQtLjAxLjIxLS4wNS4xMi0uMDguMi0uMjEuMi0uMzd2LTUuMzdsNC40NiAyLjY5Yy4wNi4wMy4xMy4wNC4yLjA0LjA4IDAgLjEzLS4wMS4yMS0uMDQuMTItLjA4LjItLjIyLjItLjM3di01LjM3bDQuNDYgMi42OGMuMDYuMDMuMTMuMDUuMjEuMDUuMDYgMCAuMTItLjAyLjItLjA1LjEyLS4wOC4yLS4yMi4yLS4zN1Y3LjM4Yy0uMDYuMDUtLjA2LjAyLS4wNi4wMnptLTEwLjUgNS42NEw1LjIgMTAuNDhsNC4yNC0yLjU3IDQuMjYgMi41Ny00LjI2IDIuNTZ6TTE0LjUgMTBsLTQuMjUtMi41NyA0LjI1LTIuNTYgNC4yNSAyLjU2TDE0LjUgMTB6bS01LjQ2IDguOUw0LjggMTYuMzNWMTEuMmw0LjI0IDIuNTZ2NS4xNHptMS4yMS01LjM3bDMuODUtMi4zM3Y0LjY1bC0zLjg1LTIuMzJ6bTUuMDUtMy4wM2wzLjg1LTIuMzR2NC42NGwtMy44NS0yLjN6IiBmaWxsPSIjMDAwIi8+PC9zdmc+",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/morphis-wallet/heefohaffomkkkphnlpohglngmbcclhi"
  }
});
var Za = ae({
  name: "OneKey Wallet",
  label: "OneKey Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80NTkyMl84OCkiPgo8cGF0aCBkPSJNMTI3LjYxIDYzLjgwNDlDMTI3LjYxIDEwNy44NTMgMTA3Ljg1MyAxMjcuNjEgNjMuODA0OSAxMjcuNjFDMTkuNzU2OCAxMjcuNjEgMCAxMDcuODUzIDAgNjMuODA0OUMwIDE5Ljc1NjggMTkuNzU2OCAwIDYzLjgwNDkgMEMxMDcuODUzIDAgMTI3LjYxIDE5Ljc1NjggMTI3LjYxIDYzLjgwNDlaIiBmaWxsPSIjM0JEMjNEIi8+CjxwYXRoIGQ9Ik02OS41Njk5IDI3LjA1NTdMNTEuODE5NyAyNy4wNTU3TDQ4LjcwNTYgMzYuNDcxOUg1OC41NjQ1TDU4LjU2NDUgNTYuMzA2M0g2OS41Njk5VjI3LjA1NTdaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTg0LjA0ODYgODAuMzExMUM4NC4wNDg2IDkxLjQ5MTIgNzQuOTg1NCAxMDAuNTU0IDYzLjgwNTMgMTAwLjU1NEM1Mi42MjUzIDEwMC41NTQgNDMuNTYyMSA5MS40OTEyIDQzLjU2MjEgODAuMzExMUM0My41NjIxIDY5LjEzMTEgNTIuNjI1MyA2MC4wNjc4IDYzLjgwNTMgNjAuMDY3OEM3NC45ODU0IDYwLjA2NzggODQuMDQ4NiA2OS4xMzExIDg0LjA0ODYgODAuMzExMVpNNzQuODU4NCA4MC4zMTExQzc0Ljg1ODQgODYuNDE1NSA2OS45MDk3IDkxLjM2NDEgNjMuODA1MyA5MS4zNjQxQzU3LjcwMDggOTEuMzY0MSA1Mi43NTIyIDg2LjQxNTUgNTIuNzUyMiA4MC4zMTExQzUyLjc1MjIgNzQuMjA2NiA1Ny43MDA4IDY5LjI1OCA2My44MDUzIDY5LjI1OEM2OS45MDk3IDY5LjI1OCA3NC44NTg0IDc0LjIwNjYgNzQuODU4NCA4MC4zMTExWiIgZmlsbD0iYmxhY2siLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF80NTkyMl84OCI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/onekey/jnmbobjmhlngoefaiojfljckilhhlhcj"
  }
});
var tf = ae({
  name: "Spacecy Sui Wallet",
  label: "Spacecy Sui Wallet",
  iconUrl: "https://spacecywallet.com/favicon.ico",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/spacecy-wallet/mkchoaaiifodcflmbaphdgeidocajadp?hl=en-US"
  }
});
var Ga = ae({
  name: "Sensui Wallet",
  label: "Sensui Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAbLSURBVGje7Vh9bNVXGX7ec87vtrdfdEA/oN2AlAyIgMKq4qbrwrJlGQuJupGoi0YTXZhmKxqdLnGMRI1LXEzI3By4LLiPxJmpi8im0aESkqEMh2yEjUHH+kGBAu3uvb299/7O+/jH/ehte9t9tKsl6Zu8ucnN7z3nfc77vB/nALMyK7MyK/9Pkene8Nj8c9V9Ib8Sc3b9oLWIO/fc7u49T/4Wm/yMB3Cy7OSyRMT9KWGClpgLELMB4s4hbt1LkMjNd74tF9/vmma6nO/GwYpA8GigbLEgHLNqSVhiXUr0Fx9k3WkDUFERXRbQX2tJOM067qgFIAJe9/PFrJ2xAEzKNjhS8qfuqLlfwmaBVCcVC2csAGvCXpt3FmOch1MfK1f0zlgAlRm8acgXHAmrI53P0Wr3t7vkwowFIFgZlxDtQj3kkI8E4Qg68kXPzL2XRB/ojL7eFGrklnjEfTxmAp9wZftPu9SzXz7TmJgWB/41p+frB2pO//FI5ZmGS64TH6zp/KTCvChABSDnrMpta+ML/vF+N/11Q2+9M5fNHXBp57Xq9Le65fyHDoDX0b18qOeIAMuH/0TSwGxeE1uw672s8YeGC6tS4n6UtqYtDVuTMkYyxiRDyr8heOA7p9yeDy2JDx/q2mzJ5YZEQcEo4He+Ut19zzOgncj+hbrzm0DZa4iN1nOOo0qgCqcatYJrDfHciehbDxKvVk05gK3YagTYMsL5YQ2Euu3Ksu6W8ez/PK9vPRQPW8W84u4b5NSpggLXVV6xBYIdREf5lAK4tfIb1xvlEguipCp2Dtaxs5TtPxtjdYHqowacZwsNTIf7gCocFQGJrrKopIEvpE3i/ikFYMXfaUufPoR8sr8ice/VXZcnSxqnB79rgKW2MLjlNet0PhKOipgL8I5zIPDNJF77zJQAICiGerUBMVZxLGnclk/3LY+Vst03p+cqS95hkAU7YgbSfCdWBKqxQPVtFUFvWSUVUgUr9xGUSQN4o7JjtSHqDYERqkgFYbixNdbUNx7wiJgfClljiuhmRg1yEer2ICUfqfH9rY6860ykPPQiUOBTCby2+t38c+9KH5U2AUsV4PaWVMvx8exeru65BpQbDATI2ROAleyvg0IUexDO3Xprv/TnQD+0/7L+dSryRQUqYe3X4HH3pCLghKtGU0eII5WD0ScmpJ6RLUJUZOmT3SgbvcLwFnea/t5nc85nz0TYkBx6XkWQ06smTSGjaB6TvJD2Row/uxyu6F4L4gaR/CZZ4BbDSeyou266sODoaNvaTNorBAqBCpqJ42WTopBAoyMzSY43Dy3aO5FN2vFuAaoLzJPs6VMAAwHJAQ7xwQK3Rpa85fnbvVCqL0DqAXR+8AgA4YjkFdkhEI57+lW9KyFy24hZhYDk6QPCqu5qG2rsKJH4zkNu9hB4CLxIoGUSnVQEVMMzDsNTQpLuwETfJ114j2V2UykCQRCGAgUHyxh5pJTtubJTN3qgtWBJIIMUJ5UDEZjDxQl82kXGffp4qaZrndBuIorqFodBCAgBn26NzT822rajtqM2JeE2FSCvNBjyKcQnV4VU9hV30BNVc+aV+u7VurNV3rgfe0GEACDFIAghASBmMnikBHUMUnqfh7QW6AOBwsQWYcW5SQGYGy49YMCBfARSTm4f/c0zoD3ruc1D1jN36CxKgjyVLPls62DToTEPXhUnbwJkM0VQrCHYIZBwUgAEoobYmS+hBL76q8bEhoLzzZ3R2vnnf+LFtKvkSCICcvRtgwOhD7ePXv9o7dFFoHnIi5R7ERQrYfZPyYWGeLM+bsNTBMt/33AFhqxjxIf/ifrwYoRYFaGvD1QLo7HNXdots7w3AIzXBz6WuPz7xeu+Xt093/hwL8GVJbZNgWy7MrnkwKSnUcHSs0L9gQVRnx5iRkRCMWszxl4fitSHEHgx8PkOCoC535y8xaDvp2MrXPpnoWDl6JPP6YlXkosPTtmNrFJXbDfA80sGY5IWi9CYnOadBxTIgsh1UmZp8I4Qt6/pX9NfosY9TSBT6LxFSsrDmyB+ygAIRFM+/NLiZOJv5RoibQwyYhAiB0SyqiJQk48C4iTa18SaSnJ5RaLpL572cxATKy6fEHkjFTn/1JQ/bNVi9cUyJj9/RTKxw8MwIwYZIwhlmEIe+UHMdKvXuz4RW/D4RGuuGmzeHYrZoMZ05qiTCcn7S0dsCl7mBK0Dt/TNvcMws1GN/D0Um8hIAQQ9pE8hf/VMb7gm1vT4e1nzo7GF+4YkbAPxlBK//F3isd9M28vcEwuHllF9S0CprtDMQJTp/97YV9eDWZmVWZmVWbkU5H+A2tIeEhTccwAAAABJRU5ErkJggg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/sensui-wallet/ebaeifdbcjklcmoigppnpkcghndhpbbm"
  }
});
var Va = ae({
  name: "Nightly",
  label: "Nightly",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAxIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMSAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wLjM5MDYyNSAxMDBDMC4zOTA2MjUgNDQuNzcxNSA0NS4xNjIyIDAgMTAwLjM5MSAwQzE1NS42MTkgMCAyMDAuMzkxIDQ0Ljc3MTUgMjAwLjM5MSAxMDBDMjAwLjM5MSAxNTUuMjI4IDE1NS42MTkgMjAwIDEwMC4zOTEgMjAwQzQ1LjE2MjIgMjAwIDAuMzkwNjI1IDE1NS4yMjggMC4zOTA2MjUgMTAwWiIgZmlsbD0iIzYwNjdGOSIvPgo8cGF0aCBkPSJNMTQ2LjgzOCA0MEMxMzguMDU0IDUyLjI2MDcgMTI3LjA2MSA2MC43NjM0IDExNC4wNzIgNjYuNDQ3NEMxMDkuNTYzIDY1LjIwMjYgMTA0LjkzNiA2NC41Njg0IDEwMC4zNzkgNjQuNjE1NEM5NS44MjIzIDY0LjU2ODQgOTEuMTk1MSA2NS4yMjYxIDg2LjY4NTUgNjYuNDQ3NEM3My42OTY2IDYwLjczOTkgNjIuNzA0MiA1Mi4yODQyIDUzLjkxOTggNDBDNTEuMjY1NiA0Ni42NzA2IDQxLjA0ODMgNjkuNjg4OCA1My4zMDkxIDEwMS44NjdDNTMuMzA5MSAxMDEuODY3IDQ5LjM4NjYgMTE4LjY2MSA1Ni41OTc0IDEzMy4wODNDNTYuNTk3NCAxMzMuMDgzIDY3LjAyNiAxMjguMzYyIDc1LjMxNzMgMTM1LjAwOUM4My45ODQzIDE0Mi4wMzIgODEuMjEyOCAxNDguNzk2IDg3LjMxOTYgMTU0LjYyMUM5Mi41ODA5IDE2MCAxMDAuNDAyIDE2MCAxMDAuNDAyIDE2MEMxMDAuNDAyIDE2MCAxMDguMjI0IDE2MCAxMTMuNDg1IDE1NC42NDVDMTE5LjU5MiAxNDguODQzIDExNi44NDQgMTQyLjA3OSAxMjUuNDg4IDEzNS4wMzJDMTMzLjc1NSAxMjguMzg1IDE0NC4yMDcgMTMzLjEwNiAxNDQuMjA3IDEzMy4xMDZDMTUxLjM5NSAxMTguNjg1IDE0Ny40OTYgMTAxLjg5MSAxNDcuNDk2IDEwMS44OTFDMTU5LjcxIDY5LjY4ODggMTQ5LjUxNiA0Ni42NzA2IDE0Ni44MzggNDBaTTU5LjgzODcgOTcuNDI4MUM1My4xNjgxIDgzLjczNDYgNTEuMzM2MSA2NC45NDQyIDU1LjU0MDQgNTAuMDk5OEM2MS4xMDcxIDY0LjE5MjYgNjguNjcwMiA3MC41MTA5IDc3LjY2NjEgNzcuMTgxNEM3My44NjEgODUuMDk2OSA2Ni42OTcyIDkyLjU2NjEgNTkuODM4NyA5Ny40MjgxWk03OS4wMjg0IDEyMS41NUM3My43NjcxIDExOS4yMjUgNzIuNjYzMSAxMTQuNjQ1IDcyLjY2MzEgMTE0LjY0NUM3OS44MjcgMTEwLjEzNSA5MC4zNzMxIDExMy41ODggOTAuNzAxOSAxMjQuMjUxQzg1LjE1ODcgMTIwLjg5MyA4My4zMDMyIDEyMy40MDYgNzkuMDI4NCAxMjEuNTVaTTEwMC4zNzkgMTU5LjQxM0M5Ni42MjA5IDE1OS40MTMgOTMuNTY3NCAxNTYuNzEyIDkzLjU2NzQgMTUzLjRDOTMuNTY3NCAxNTAuMDg4IDk2LjYyMDkgMTQ3LjM4NyAxMDAuMzc5IDE0Ny4zODdDMTA0LjEzNyAxNDcuMzg3IDEwNy4xOSAxNTAuMDg4IDEwNy4xOSAxNTMuNEMxMDcuMTkgMTU2LjczNSAxMDQuMTM3IDE1OS40MTMgMTAwLjM3OSAxNTkuNDEzWk0xMjEuNzUzIDEyMS41NUMxMTcuNDc4IDEyMy40MjkgMTE1LjY0NiAxMjAuODkzIDExMC4wNzkgMTI0LjI1MUMxMTAuNDMyIDExMy41ODggMTIwLjkzMSAxMTAuMTM1IDEyOC4xMTggMTE0LjY0NUMxMjguMTE4IDExNC42MjEgMTI2Ljk5MSAxMTkuMjI1IDEyMS43NTMgMTIxLjU1Wk0xNDAuOTE5IDk3LjQyODFDMTM0LjA4NCA5Mi41NjYxIDEyNi44OTcgODUuMTIwNCAxMjMuMDY4IDc3LjE4MTRDMTMyLjA2NCA3MC41MTA5IDEzOS42NTEgNjQuMTY5MSAxNDUuMTk0IDUwLjA5OThDMTQ5LjQ0NSA2NC45NDQyIDE0Ny42MTMgODMuNzU4MSAxNDAuOTE5IDk3LjQyODFaIiBmaWxsPSIjRjdGN0Y3Ii8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en&authuser=0"
  }
});
var qa = ae({
  name: "Elli",
  label: "Elli Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAYySURBVHgBdVdLbBVlFD5nemtvuRLKGxMTaVlBUgIREzExQJCFCTG4cONC6ka3JkbjAhMxSCExutTEhXRhjIkJ0bjk0YWBghBLqZiItnFHa5Fi+m5njuf5z9xemKb33vnn/8/jO995DELlarvx9/GCsI+A9iBm64gI+eJb4g+75F7X7YYfESD/kd/KXqju8X28Lt+DvPsc7Ht6ID3Sz1/Hu2AFz7PwAy5AHpkQl6IK9DPj5SIMULvEhuq+dFUfqG2mkDUMQxsdgr3d05nKyeEy6zuox1Vmof+Ihd2jWFWYBbGWyWYWCgXaWpH2xb/LIpFFIdvO7YEczhsC1//sw7bsazWvFTL33KBl6QZZLIZHAaWfIwfXjwcaKEHR/XEQ6M0aZnSc2BzZHfEVkeiaUnTRDcFSoG5yjiQ7FAXxVf9cpVmoshDMD1RwjiPc/IPKKMUTcrUlAXFVfLFUXEXAOUEIq8+b9sDEmUvTNYuVyUFncBgsHpjlaMTDZIsbSWFMkBRLw4vwuQJaIJuM7qpBInKklseLoLrZlRcI4Sm5I0aQpCQAgsyNwCpokEKGHsQaKeNdVxyShaxMfScoJnKSm52FhZS8CjQTYtUaEuCHU/xdQ/VVMYYgm3NFD9WvXSWcmUFoAhMg37IVlnp3q/Mdo7egbXIi4AOvRJBv3Ya6J3D1whblQX7UglqYueFRfPijPnQVN5w6CasvajRg6vRZ0JCIwMYa7PrqS8DZ2Za9D955F+cPH5FTaIIZmcyzDaWs8YKEgSEDUNiMXO1/3cX1n3/6GOVnYHlHj9OwQP5NU/1n9Nnqax0bVhu7CxpqL1ZW5CyWmVQ7++cFqbL8sDZ5DzacPtXikSrv72fl3RBCtFqKET1iRH+LERnL2PjJKZY5AV5h0Z3WaGRGZ3mQ822uCVUfugJtExMt3sy9dBiWera7N+JBjlG25bc8W+ztbTkn/Fhz8YKdi1JtLEFFgDTjybMrh/kjh2mlp7tFUOeFi+zRjNV5NtaoK0I1FOIl1YeGWs4ts6yZY0dJUbbeApYlQFmUWzTrZBPkjTpOnfiAWbylBU72hNrHx2DNpUsqTHjV+OFHaB8fh46REVytXGT8y7Ko0YmWvI64hi7n3hQQat55HxActm6GqTMftxjRefUato+NSYjQCk1BtX8mGOZ7sPbb71qUq4xtm8nJZyFztEVfBgaLxpNSW+UYMSHZCLp/4v0mYj1x+zdYYeP+e/01kP1Cpodv9UkqslGTaZ8S9uxJlrEJTDGVmaCVq1DSZ6BCck1F9DLnfVz7/MqOZ+j+h+81Cc7mZixzytChkLZq6NTZj2hly0Z0eUo4DPK64Ywgy7n9c+FnMEYC7wEUJVdu60O/QMFeLu/YDt4zSe5FXDY3p04VTzY4RDc0lAvPP5dmhmjlROXYoAqsEnrXSp0KvblEWTUBoqxj5A6s/eZ7/X749hs4e+xl48WV69D12RewtHsXLOzfB0vd291rnyl9HmrqWNbhIKMUm2iveYLVRijjSLFtE80deZHr/04yMt6wEYz3iFFyLfbuhPn9z2Lx1KaScFp0CDEqIJg88pRHHB0sjP0Bi0MkJ4oYSqOhkeZKfegmN6hZXHhhnz7pYGMEoUX2vjqqgaMXk4zPCpB2aN8ZveTJ6cMIGRZYOVkOGclMrE4/WFIlzXvNUxakx9A0nxDWvAaENPRRyMOC6Vh6R0jjNUFpp53T9ayZvH4GnYHBA+/9PA+QppPPdz5++bwGPhb5+EKYFDq4BNXpmVxZxUdI051HEZWYptz08ExID3hxPWJsp8QDCrih+oJRplGMmNrZ4hsTmyucl3xnNhc5YjmX2hDGCNxCKCtgsDd1LmU6KIOp8gJCXsCkgprO1JRSqy2rrDjF+zKtFvHSIpkwyEvFgAmjNCR4u9RqF0okHVOltLZNmIUSa2JWHd1I0laNqcpa58QmRykfsCS789Nl/jqYalCFro/6hmZ8yysmR2parQ7YZQyJhmnX0b02CS4uv8qah6P4UBqZCkchOqZOQIQxB/ge6/E60vHPeCdMBQ6j/RJGXygGqXP5UKsjv5/v4/mFX5fggLP1Eflcca3ZeV/zVMFgs/cYhGkWyU7CAOx85Vyc+x+o7DqjAADBkAAAAABJRU5ErkJggg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/elli-sui-wallet/ocjdpmoallmgmjbbogfiiaofphbjgchh?utm_source=wallet-kit"
  }
});
var Xa = ae({
  name: "TokenPocket Wallet",
  label: "TokenPocket Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzQwOF8yMjUpIj4KPHBhdGggZD0iTTEwNDEuNTIgMEgtMjdWMTAyNEgxMDQxLjUyVjBaIiBmaWxsPSIjMjk4MEZFIi8+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80MDhfMjI1KSI+CjxwYXRoIGQ9Ik00MDYuNzk2IDQzOC42NDNINDA2LjkyN0M0MDYuNzk2IDQzNy44NTcgNDA2Ljc5NiA0MzYuOTQgNDA2Ljc5NiA0MzYuMTU0VjQzOC42NDNaIiBmaWxsPSIjMjlBRUZGIi8+CjxwYXRoIGQ9Ik02NjcuNjAyIDQ2My41MzNINTIzLjI0OVY3MjQuMDc2QzUyMy4yNDkgNzM2LjM4OSA1MzMuMjA0IDc0Ni4zNDUgNTQ1LjUxNyA3NDYuMzQ1SDY0NS4zMzNDNjU3LjY0NyA3NDYuMzQ1IDY2Ny42MDIgNzM2LjM4OSA2NjcuNjAyIDcyNC4wNzZWNDYzLjUzM1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik00NTMuNTYzIDI3N0g0NDguNzE2SDE5MC4yNjlDMTc3Ljk1NSAyNzcgMTY4IDI4Ni45NTUgMTY4IDI5OS4yNjlWMzg5LjY1M0MxNjggNDAxLjk2NyAxNzcuOTU1IDQxMS45MjIgMTkwLjI2OSA0MTEuOTIySDI1MC45MThIMjc1LjAyMVY0MzguNjQ0VjcyNC43MzFDMjc1LjAyMSA3MzcuMDQ1IDI4NC45NzYgNzQ3IDI5Ny4yODkgNzQ3SDM5Mi4xMjhDNDA0LjQ0MSA3NDcgNDE0LjM5NiA3MzcuMDQ1IDQxNC4zOTYgNzI0LjczMVY0MzguNjQ0VjQzNi4xNTZWNDExLjkyMkg0MzguNDk5SDQ0OC4zMjNINDUzLjE3QzQ5MC4zNzIgNDExLjkyMiA1MjAuNjMxIDM4MS42NjMgNTIwLjYzMSAzNDQuNDYxQzUyMS4wMjQgMzA3LjI1OSA0OTAuNzY1IDI3NyA0NTMuNTYzIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik02NjcuNzM1IDQ2My41MzNWNjQ1LjM1QzY3Mi43MTMgNjQ2LjUyOSA2NzcuODIxIDY0Ny40NDYgNjgzLjA2MSA2NDguMjMyQzY5MC4zOTcgNjQ5LjI4IDY5Ny45OTQgNjQ5LjkzNSA3MDUuNTkyIDY1MC4wNjZDNzA1Ljk4NSA2NTAuMDY2IDcwNi4zNzggNjUwLjA2NiA3MDYuOTAyIDY1MC4wNjZWNTA1LjQ1QzY4NS4wMjYgNTA0LjAwOSA2NjcuNzM1IDQ4NS44MDEgNjY3LjczNSA0NjMuNTMzWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzQwOF8yMjUpIi8+CjxwYXRoIGQ9Ik03MDkuNzgxIDI3N0M2MDYuODIyIDI3NyA1MjMuMjQ5IDM2MC41NzMgNTIzLjI0OSA0NjMuNTMzQzUyMy4yNDkgNTUyLjA4NCA1ODQuOTQ2IDYyNi4yMjUgNjY3LjczMyA2NDUuMzVWNDYzLjUzM0M2NjcuNzMzIDQ0MC4zNDcgNjg2LjU5NiA0MjEuNDg0IDcwOS43ODEgNDIxLjQ4NEM3MzIuOTY3IDQyMS40ODQgNzUxLjgzIDQ0MC4zNDcgNzUxLjgzIDQ2My41MzNDNzUxLjgzIDQ4My4wNTEgNzM4LjYgNDk5LjQyNSA3MjAuNTIzIDUwNC4xNEM3MTcuMTE3IDUwNS4wNTcgNzEzLjQ0OSA1MDUuNTgxIDcwOS43ODEgNTA1LjU4MVY2NTAuMDY2QzcxMy40NDkgNjUwLjA2NiA3MTYuOTg2IDY0OS45MzUgNzIwLjUyMyA2NDkuODA0QzgxOC41MDUgNjQ0LjE3MSA4OTYuMzE0IDU2Mi45NTYgODk2LjMxNCA0NjMuNTMzQzg5Ni40NDUgMzYwLjU3MyA4MTIuODcyIDI3NyA3MDkuNzgxIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik03MDkuNzggNjUwLjA2NlY1MDUuNTgxQzcwOC43MzMgNTA1LjU4MSA3MDcuODE2IDUwNS41ODEgNzA2Ljc2OCA1MDUuNDVWNjUwLjA2NkM3MDcuODE2IDY1MC4wNjYgNzA4Ljg2NCA2NTAuMDY2IDcwOS43OCA2NTAuMDY2WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNDA4XzIyNSIgeDE9IjcwOS44NDQiIHkxPSI1NTYuODI3IiB4Mj0iNjY3Ljc1MyIgeTI9IjU1Ni44MjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0id2hpdGUiLz4KPHN0b3Agb2Zmc2V0PSIwLjk2NjciIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMzIzMyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzQwOF8yMjUiPgo8cmVjdCB3aWR0aD0iNzI4LjQ0OCIgaGVpZ2h0PSI0NzAiIGZpbGw9IndoaXRlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjggMjc3KSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://tokenpocket.pro/"
  }
});
var _a4 = ae({
  name: "Frontier Wallet",
  label: "Frontier Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC45OTkwMjMiIHk9IjAuMTIxMDk0IiB3aWR0aD0iMzAuOTUyNCIgaGVpZ2h0PSIzMC45NTI0IiBmaWxsPSIjQ0M3MDNDIi8+CjxwYXRoIGQ9Ik0yMyA4TDIyLjkxNDQgOC4yMzQ2TDIyLjYzMjYgOC45ODUxOUwyMi40NDU1IDkuNDY5MTlDMjEuMDI1IDEzLjA5NjkgMTkuOTE5OCAxNC44MTg2IDE4Ljc0NTIgMTQuODE4NkMxOC4wNjgzIDE0LjgxODYgMTcuNjY3NyAxNC42MTcyIDE3LjE0OSAxNC4xNDQ1TDE2Ljk5OTIgMTQuMDA0MUMxNi42MjYgMTMuNjQ4OCAxNi40Njg5IDEzLjU2MTQgMTYuMTA5OSAxMy41NjE0QzE1LjkyMjggMTMuNTYxNCAxNS41ODggMTMuODA4OCAxNS4xNjQzIDE0LjM4NkMxNC43MjUgMTQuOTg0NiAxNC4yNDMyIDE1Ljg2ODggMTMuNzI1NCAxNy4wMzM2TDEzLjY3NzIgMTcuMTQyNkwxOC43MTY3IDE3LjE0MjlMMTguMDg5MiAxOC40ODU3SDEzLjM4MzNWMjRIMTJWOEgyM1pNMjEuMDM5MSA5LjM0MzMyTDEzLjM4MzIgOS4zNDI4NlYxNC42NzUyQzE0LjMwMDUgMTMuMDM0IDE1LjE3MjEgMTIuMjEgMTYuMTA5OSAxMi4yMUMxNi44MzkgMTIuMjEgMTcuMjY4NiAxMi40MjE4IDE3LjgxMDYgMTIuOTE0NkwxNy45NjUyIDEzLjA1OTRDMTguMzEzNiAxMy4zOTExIDE4LjQ0NzkgMTMuNDY3MiAxOC43NDUyIDEzLjQ2NzJDMTkuMDc0IDEzLjQ2NzIgMTkuOTQ0NyAxMi4wNDE4IDIxLjAzOTEgOS4zNDMzMloiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/frontier-wallet/kppfdiipphfccemcignhifpjkapfbihd"
  }
});
var Ha = ae({
  name: "OKX Wallet",
  label: "OKX Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=",
  downloadUrl: {
    browserExtension: "https://chromewebstore.google.com/detail/%E6%AC%A7%E6%98%93-web3-%E9%92%B1%E5%8C%85/mcohilncbfahbmgdjkbpemcciiolgcge"
  }
});
var Ka = ae({
  name: "Bitget Wallet",
  label: "Bitget Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAMAAAAKE/YAAAAC8VBMVEUAAACS3/uZ5/rF4v7h/f9K6Pdi0vtTyvqnt/5T1PlH9fakpf/p//88/fXs//5G8vXy//5F8/Zj1vqvuv514PrI7v2J3/o6/PTE7/1A9fbU+/3Y+/1R0vo7/fXh//7G5/3l//6jov6k8fuxs/6ppP6/1f5O6Pfv//7n//+bsv4AAADy//7r//7l//45//RE/vTg//1I/vVB/vRL+vXb//09//RM/vXV/v19/vhQ/vXw+/5z/fc++vVh+feC/fii/fpf9PdQ1Pmxr/6y/vuM/fm8/vun/frB/vyt/vpq9vi3/vtZ9fdRyvq1s/5N4Ph4/vfj9v6tqv7e+f1q/PbK//xS3fhS6fdl+/bX2f6c/fmS/flw6fng7/7f4/66uP5O2fmB8Pla5/jQ//2H/fjT1P6X/fl47vlV/vXLy/5p7fhc+fbHx/5v7/hL5vdR5fhT+fbP0P6T7/p15Pp09PhB9fWL7fp6+vhn8/di8PdG8Pbb3f7F/vyppf586Ppu/feK8/rX+v1W2PlN8vbW7/1Vzvrb8/6D6fpE+vXO+/zj6P5x+PjV9v1Qz/rn8/7m7v7Y4v5X7vfCwv+lo/7R6f3I/Py/vf9H9fbq+P7Q4f5Z0/qt9/ub8PuC9vlU4fiT9/rs/P5t4frQ2v4KGBje6f5+3/pI6/bCxv569Plj4/nY6P7B1P67wP7K5/2gtP2/+vzJ4P7P8v1c7vi2+PzL7/1b3/nJ0/5P7vdm3Ppj6fnEzf7Q9/2zuP6k9vtM7Peb9/qJ3fpf1vq5xv6TyfyO5fpd2/lZ/faG1vrC3P6rs/6k8PuU1fvJ2f6+y/6Xvvyl6Pu2vf633P205vxqeX5Cf32lxv2i2fyW3vuorP6hq/6+5P2wyf2u7fys3/zD6/2gvf2puv0dHiC40P2w1f2n0PyN0PuvwP667f2d0fybx/yi4ftYe3xPn5oufHvW7+5U7uZwm5oQLy3R3N5G29eEnp53zco5WF0qMC+dzM2MzcwsLzAtbGshLA3xAAAAKnRSTlMAIf47Wjuk17BXvH1536di36KDXdSkaIV1cd+/6c/v5s/Pvd/f0+PKk9+fkOCeAAAZMUlEQVR42szVvarqQBSGYS2iJHAQbUTIaXdpceo06cPuYruvIKnSpFQCaayFFCm9BbuAl3a+NWtmPojljj/vGqwfFkudTdo8DDeLdRTHcSqd43i5XCw2YRDMPrJwt/76Rj+2VNlalmXLxeaj5HN4i0LEVKORGkEefoR8tf66FtrYrerUsQmfvbVddDVZc2HJqk7xqBY24eF89p6CqK6VjKFa8ux0xGbv2Hewvdboatkm7hrDCxmreSevWTeXXEFMNRLyw67pJhvR/bp1r6IK1RXN7j6IBjtXM9VvZK/+VNaskY3ozsHWyHa9lE0y1byPK81ctardbb+FHUQkc9mebfPsPM8h98smvDk3WdbIWPbz/nLmUZIkVeLYY/Og7BKjZrJzzz5jGkFLmX4K/Vm/JLsKZKIfVj2I2ubMUEuy7KNlN7JtQdOdYeLNbPqCv4lk0CRfatswAD0UQ3HAFGVZfpdAO7NeyTHFOHfz0HLyZW8dmepLdbkY9CCjaoGbSqTL1o6C/jHmTp7UjdnTLntu16zkxJEVfbJwax6wa1WD3ZOtt30E24BBxqTPW/au2icJnoe3To2gxqNa4Hoiyu773CVoyV5J1ym689PEq6nWvN3v985c6aDWmq16GG7OfDgcQLb1YMuy/Zlg1H3EtiWoUSMPbSY6DTXjeXfbVq1ZNE/kdEODo+NEvLrslU042Z2Dd74pTiSoQJbx5ARisFtnPl3qExI2yCIHGpW+XnJiGdaNunf33//T7MyayQZZxphbr1Y21EjoBk24+UYqm3S6IfdifNzvvzxsPWdH/qfqSsxKtmrthufgh4Forptmkh37LmP7T2odu6YVRXEcJ0OyZWiQdO/YoSERBaGDu7uL01ssOkSQBrI4xMGsb+oWeIQMrsKjvlFo/pwOJdC933PPvfc8S4hX8zvn7h9+nLz4rsP+gNmrW4y4fc/e3WRomglxYjYmXrZns6XKfTYsZgns96oxawL6yszfIYtZFrapresIt659UDN3ZWA/s5vN3SZmvTk5/LNhPRN/0jHN+6aEsutkXlCTN9wUjpXcMQQ268jsunGoOUZqlqav6DlGwZ7c5Glyz+7L1tj9h7q6fCgpu6RuuDGwRUwOVEdzS4uGTO6Z0PMP557zME/mFsiv1y1uR9aVUHMZyevnNWSeqg++Z/3iyT0r+cKKdlUrG+nLn8c38xc15MyNk4dE9VrGsvddf7SeIX+5avmeL0Cz2rS6Vf3y+PnNYCbX2XXmyaCj25N5IcW6KIqTvc2mjrdxISO5vES9lSRzxogad5aVGVqre/nM1MmiPtvr/6CJGaJmF4rGHLUTZj5JMgc3ZNioiReX61LRSwYz43Kebj6u9UwwG5qaKfpSvObeac6dOO/D5IWUzDKDvHT5XzwtptPj5I/dqRVtZn8Z96iJiRPMv3NJn8lYczszD7WcB5GuixDM06ejw8yADe3Jiu6oO8X8E7FLxtazxGwpIFvNksY+f4Rm9mo7DSsadWrPBDZkHmNkpm5mt9Vn+/4RuhiZqLnd9uZOp5NstqZXwVyJm2QBzRiYPE2fZucJx/HVzAFtaiWDFna705nsNvfy3rxXZ68kwBHzmKpassuqkBm4mYbMZrOEsz599Z6NTMSMuA06wdxDLWPmHLJnV2r2U4zUPB0oGDLmRSPxoFuvoaMYbpNJMhN1s4AtFQM5BHEwDzCzkCWLxeJsx3HEg3bk7YOOZlVPks2531Uvp+Y6O2ZQVaPRCK+QGcjBTI72PQ4j180k2UyUzHTVe6vm6B6xA8w+8TYwSxppXzszR7I8I+9nzru9XlfN3VtlS6qKlYpDzSNtejgd1sg3i5vzlC+HS71myO0t9Lfd5vF4HNBdIXeFLF7EIag9mfVVDweQTY355tfRzt/QLUMrmYEM18hJZtTjgCarrkSsuFnIoxhqDuShkQUt+bTjd1JL0du3gTmKnfofZ3YP2lQUhnE8fg0WURz8RgcHcRQVWgmxgrUaHRwiSOsSlCpKQEJoKoiNk0hmp6Zk7ebg5BDcHDp3dHdQUREFcfL/vu+5901yYu6NzznnJoPDz4dzr/HcfGaiXruYWVaah0wz12p3akY2c/VZ9UVVa6bo5fqOjLtwuGeCeFKziYM8IpvYi67VHtaImoPaatbU6/V/VL0viGMzPbsZ8YMHX7/nMZf0cqlELjmbGdwrJJjpmXG/ZmTM1aoVbWhycEzRTo57NnJOMwHLErIMy4qNJwwhMxBbEIeYGHAgk872kUUrOTKL2sk5zaU4Tge+wkStcTLDyPfZz2S5mpo79U7n4KiiI7MX7eQLE5tdzHVFhplTctnMjUYjrVmbdjNosn1k0SaOzRP3fLt0m8lFpgWsLcyeMgnkGmQzB7WR3UzVcdFoxz82aDmX+TZRMrGvTF18L5dLKZiotwx5uOjWckvJbt7cjB4gu+OWHX0BM+jc5jjYWWUmbKanDZmoeYNUA7q6LG43g94cflZP9ZvxMoe3M3n//j/N5i0p0821djmA2RyNjY37G1VDt1rVFqnXmfWEHFW9LXh9a7i5r+ac5gqzwuTCNyOzTOvsdrvdaDdCMHvRgOlZyd1O512n00MdVb3/7Nn4h2j/wzlfz1sYoyi+XAFf4VpmBHGZ0Q5iM1P0OmlpMBMzK3lt8/DgbegtR0+N/D1/Vh9rZNCqebVcUa8XDdmyvl6tJuZuq1tnYH63Kere5trah239z7uoZcj/ZSar/zQbeVU6TqNoE2NOySbuYiY9yZqkf39MGVrFkTmQs82rq5XVJBUmST+5shiQ2ywnY24yEIckPSPGLEX3pObNtQ9rayfdvM2OjywDZMT5zZlpsxBXEnKz2WywRKxmJ4dYzV70mzfb+ndHAAdyVHNOc3G1WAxrlJlhNRdlNlFjpmXcqfkeZBlha3R6plYy6MO+O0wc7YyJzMXRaetfoCjL/oiRCUWHgHVyay6p2YtGLGji+yOYnWyHGupFnMdczBfAem2m4g3MzfWLjHsM0ETJ8d5A7ftjt6HdDFkyqfkmgysfOkanKcOjZDUreW5urmtNYyZ95JCdAb1fxedkndOe5Yzu8YPHmEles2GHUmSmfvmq5ptOvti8SIRMMLfmTOxm0K5+/fpA8i8L5nMyEjNBnJhLmWZo2WkyBsEzDMBSs4jVvNjtMpfemXm215vvJ4P+aOZd6RsUTkKlY5LW/Oj9o0xz6pqxi82ZmWE1PevAPTOjYswSyLClZsQEtPfsZsjENvU+E4cDZxWzgjhHzwEK818RsS0r2MQh66lYyKoGvPBudhbxvBVtZIs99Kb6Xp+EUDNkTelPlnkAe1HXuGjBM2hZ1jKZs1twcdFqBi3m+V4wX1a0sQ/Yljaxk98/puJALv3IMA+Kocjgc4wf6hCZKBnx0hLiBcyz1Owb+rqJX716elTRVrKbHz1OyWQrp1mpcVztf4jpYsiaxbnF7uIi5CXIbI7eLGRVa82Yg/qVbOpdSmYmZLSJmd/uX8aZf5lkOFtj8zkVO7mLGLJExAQz5GuYL1/2niU7QR9Sq5NvGFjIgs5o2sVGkXnv5/gzs617LmbSMgMyaMi2NdgckK8Z+fqVK1cwX70q5pdyJ06l4htiTtBEzJWvGXs65fYln9r3BUlqRp3UDPka5MvXQav5qZpfyp14PCVzJAvZxGYu88M96+nh3EnUaGMzYjdDxgz5zaD5pdyJwWtmI9tZUNnS/pWh9s3pyVSnZhdDJr6dzWx7g63xFDRmwn0oaGI1c4ycklfM3M5U442TpXaxmyGnPbvZezb03W2FXTc8lywlEwcyydohSWsTqcFavOXYHNBX3Xx3enpnYZ+LA3mFBLKgG2QrS83OjJJH7befk4mSid+DtqHJtKCPDHQsR8eEoiE3ZGg2stQKmFSN2MxxzYa2nq+a+ZbUfHea7CnsV3KiHjgcVHOzIf9VzqNWg37KWMqhVnFE9prNrPcgaDOT04X9/l4BrQVwuZEknKJkqZdGJUvtYt8Zkth8y83n9xam4PpLEEkNMoev/WTQ+dULE6jHkUebn0+fP1aYMq6TV2rEWyZCzlZ/40fDQpQM9SfIlpTsNQczaMxe9PmjhVOJ+Im8s3loZCbu+3jt8JXjqtZ6K1MNe2J1AHvNI8237pJgPnO08NbM6eu8/hcgcmBMkhO2TLV1thA+mIwcahc7uc98i7xMzeREIZBFXTNzeMkEuRoiR9z51D20HqNnqQfIXjNmEvVM02cK2rHX7OaY3G3V83Q9bxfP7ww15OgGFLMXPWAG/TbdGbyeZrg5qJfl7QfH8jLqWeqf88PJo453BmTvWYt2M+i/zdxfaJVlHMDxczwRi8WIypCELCr64wZdCIGXhRRBMKULoSkRXgjdWNBNKQhjkgyTWqHUxTKH4PxLsgvbxZiC1rSp4dTN6dp06oKQiP7d9f39fs/z/s7x0b3vdFbf5zlnXX749Zyje9+3TPymiDUFr6sma+++j5grxjnqr//CmXb9+Ry1ilMy5nTOoAM5iFmIWes22K1pzIEcb5z+nKN+1bNPWBF1aoacnmdDN5VcDPi9+EjLWxsswI5WcxH1F7Jry1PDTcaM2NBOVnNT6Su08XmndWxtwzoVZ2ZNxQXV/Pt+9eWZqWvJZGQ3k5kfKz38ZnioDPJ7Rnaz7MNOjnf08tTy2yivqgqo8Ro5NVOVuekB0ORP76k5dBgxZllz3p3z5ZxALqDGbKu6PHVCTs2Gfrz0MNgoxtwFWcEbDhNmEZOKBzEXU38jv4++zHoNLa9C6kCexgyZ5pfu5WFUM3chxtzF6gtowmxznjOI+vtBxOe/P38+R/0naDarujx1Qk7nTI0NoKUuIVuIMYfmxCAPDmJmCTpfvYReW4J0Jmonuxmym7WG0oNmZpFOua/v8Ia+YGYZWZaqB8+LuZB675KkHPWPJnZyaqb7S49ARhxC3NV3OJDPAM7MGmTQVES9d+8SNvSZqJ2MWbvR3Nh4T+k+qBlZlgYc85kzZ4KZbeZMfeX8lXy19QotWcKL9Uq+GnJynN0MulIq15jNywLMnsOamjM1NTU4FQZNgUx56lf2sjR+xPLOdUJ2tJIFXcrImENn+hCTqCGTmU8Nnh89f0rWqSuw89UfutX7Lec/LwlkSsiYiWt5D3d1Hek6coRXlZmtTZ0BbJMeZaFGDBkxFVDfrBz1z3DNrOpAdvPjoO/FDLnvyJE+WQO2jBzVNDqKehQwoT5VUP1Z6MPPPmQXU/+i4lD1mA3dAPoRnbIk7r4gNvXQ1JCJp1SsZidfuHLhwoUCau8NW29Mr76uZrabg1q7H/R9R7wBWZqoh84MDQl7CDXVqIevDAf19R+n6/pHGbi636f9BjFvejasSoky8uVq8tAAYsJsZEcPnxoeBg04dCBrP32rfVQbFw/5ndrEuZN2cWKmsqAfDmLWZdQx1EyaRlnRfJKFGjJmtohZkXwAMuiMfQP9bfYbrJwz/WtqbozmhY0PlKR7VSwNXB5gS1chx6L55OhJFVtGNrVPWcxx1MLmvcos8Z737ZGQlR3VDYp+BDLbCuaBqzR0NZgnRicmMDNmOnXS1budDDqwvaC3y8oBnWv+45f0ZDi5ceE9ii5DDeBDA2zxBvMl1oSaJzA7WdG7h3df2E0HdpuZFN2Ou729HS5v6+lFCbaVa4acjNnNCyslLUMfGjjEjupLVzGbuoo9LIv2DWNmHVB1x4GO/a1CRpu1Xl7f6voIue58M9hkzk5eyJHW7oV7+ZB1VVZUaxOXAEOeOGkdPTl8dPiomDXIHR1x0q2trcJ29fqqIM/EXDNlZzcE9COihR3d165dvSZktqNRB/NRaXjfvn3D+wK7g1o7Wgl2e6ura8nFzYjT08wijrSFNHTt0DXCfFrItaMeh9wN+SSDPoo4kAHTfsxk5ra2NkcvC+pFi9YvKmRG7FVN2SpHdF2N2Tp9+tLpKvP4BObx7jhp1IR76+4O2NmoqQ0zW1rftgxzRi5irhU3OTmM+hm4fj5+YEFmq5hRq3rk0sjIxAhmFuzu7m4zG5lhb8Vr6GBuYxPw9mWYswqZU3Ekk58ODTDrGkvJbA31CGpBW92oa9hbSdk7O3buVDM7qJfJRhvpueZqcC05PR1U9wOpmi3koBayND5i5nEhC/pYNXkrZMygqcXECvYKml3tOZgaSl5FyNq1ixcvIg5mtobZ1biPHT12bN+xfVsjGzLmnTtbBC2rWd3NMzKnU/aj0einw4OrXfwBNBkaMhuyq9WMmhBbHA2rZTtg24iblzXzxntxc/S6mOVk/ZPFq3e1mtljp09Pwrb6R8b7x8ePj3cfVzZkVW8z9ebNQt7Obtneqmp1I4Ysu/l6AbPP2Mm8LD8dXrlKbOrTqCcnJ0cmzQwZNGSpR9XbyMhRTS2h5pZmduzH6c1/Y47c9GBkbv8Y+kdxD+rIHrs4NjY2ORnZoPv7jx8fPw77IOieHlOTqimgmbWrC5sbbyo2the+pL2KoPewzcwCDVvV/dJ4/3E6ePBg98EeKYwatZpRuxkyrzswkzmd7R9Drw4waroIXMyZun+SSRNqYZOYeyCLejloCbGqrU0tzZs2NW+audnmm/3w/GPoPaTgoBaxqiP7hJpVbWYyNOblQb3C1BtNjZlXYbOT2Wk26KTnXD3GZtQk5hOTJzBrhs7YqzBvWx7MK9S8kVF/bEGm4mafrX/PJYNORu19NzbGFnOvqGHv6u/fJaPekaHXbFsFehvoDzZ/gFnavpFAs/EWNgM0p67ig/ZRQ9aXsHvZmGXUsIHv2LHD0KtRg16FGTVoIa9YsVHYH4eKmF3sXFfnDFpHfe7cHhZiWcS8e+mEtIvEfNzYq3vWrFmzigS9GTVoEnNLVOeaf/qlk1zs8IKDpjrEdPbcnrOqpt7vxlQd2TskMa9eDbpHZi2TphXKxkxBnWv+tVM0vCXggoOmCmKd9VmGHYLss47qd95RtI06U2tmtnLNgEW6OAesVaIyHbWGWgpqcxv6k4jWUUc0KdrVxcyLhcsb4NwaSreq/JyizzJqzFGt2ahhfyJoRu1qRZOSQUvFzExad36d5dItq4dMYdLsl1hx1CtXKvoTR5OjUUtK3ljMrLtQ95em6YlgDmzp9d5edu/KlTrqz3NGDZqKno2UXfxT6JXPnfuUBdhi0uZGTaBRY3Z1NdrV+WYjF6xcmrb6T0HrsZaWLpUD8tLrr+usCbSrk1HPxKyTLibncOT0xKfa2rVrMaN+iURtaMygUaejdnURM2j2nR0Or4z4HOssatiobda0UhI1+aiDWsiCLng2bNGdfXP4AametagpUdd+Fn3SVGzO8XTc+eFwNWZamqgx0y1GzawLmouK6VlTFT3WpGZXZ8eabnaqi5r9TOf2QNH/Yd5Tho5qR7s6QZu6oNkmPYtmqkCWMKN29i1PNRn698JzLsiulApXH9HCdjSlXyA+6qJm71bsxrj5EN6WGjSZmQSdqo2db95SDWbdDGxeNxev7gZ1NmlXJ+hc8xbM7KpqsLZ80v7FUVzt6PSz6Gg/IL//NG1/Z+ZOH7WxjVmLp4bSjHvC1QVONSV/Q/XfFWmLJlafNvyFnUHsk46/nnMR7PbUjna1oikZNTlaq0FvWqxsyJ0WZDY8FbO1+A/PlEu3pwbtakenp9rQqdrMgb1pi8y4083yhje5HCY9jvm2qnN0jbr2b3vT/AoDmjKzBV3Njfam4KSG0m1X72rMS6cdNTnaLoGwHY3axJhRq3gx5oWzZnb12vRrr3bUhvZR20WyeOHG0GHWMcxBzb5ZfD/fmdrRPmlydDLqzYaOlyNbIPuslcwW8c3J8lzmHVZ5CrWjXV2LJrmy5+rtoIXdImwRN7OzSbOaOpswp+KmxyqlO678lKLXJucjHbWiN4NWNWy/xq7s5i0sRQNm+72hqtuefG3MRvXT/AGzA7Wjw5VfbSdk0kmjxqyBbrJpZ0wyvuxnMc+a+uZf1Y6mbYZebmZSNGy7bWRqG7Y6t7g29pgf51k4Io5WtV8DQQ26Z/WaHg61thV1YNfeows16drCWxJHYzard7Wjd4EmLkfCXiN3YfSGBvcVIRu6FbWa2R5ezMZ+gc2SHz7mWRt2Ldqv7NlF1J4eY9tNOj8gLa3b2/TOc5vdwQ2r+YWmZTDBsq3HK6XZr77qfPRGdbzK7ve7YKM2tA1bxHqTHy3bQrmMlcVpviuV6yKai2SKRm1oZ2NWdYeiW3e2arBrH6fAG+BWQ7l0t6o86eiqWwOZ2W+Yo8ZMasYb1J6RFy1iL5pfKd3NHoKdol3NswmgpQ6KaDJzxl4ki+Tt0XtKdznYoCneOurnjlc1Okxan7eBHc2o21k8gwVZXia++2RnO9pv43ZjpvjADWrY/hRZfFQPd0jI8+862dl1UQ16h6kdjVrNZOb9bkZdFWf536xc9+SNo+bpFTWjpvCYIfE0p6x2czv7sfv/RbKPG7Tf5+8WtLCzxwxhA0ettbOtMORy6T+p/FBdLVrMR33SvPTh2aiWp5O/lebP+2/EPu+nFd1t+ROdiDEfYEU1aHp07j3l0n9fBbijpYim6ifCAc/7P4BdPm/u06DNjDqSQWsL5s77X0w4rVJ5aN7cuU8/vWABo+Y59gULFsyfi3aWuf8ADHnSl6eWnZwAAAAASUVORK5CYII=",
  downloadUrl: {
    browserExtension: "https://chromewebstore.google.com/detail/bitget-wallet-formerly-bi/jiidiaalihmmhddjgbnbgdfflelocpak"
  }
});
var Ja = ae({
  name: "Gate Wallet",
  label: "Gate Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAAP1BMVEUAAAAX5aIjVOYjVeYjVOYjU+UjVOYgUN8jVeYkVOcgWOcoWOcjVOYjVeYjVOcjVOYkVOYjU+YY5KIjVOYX5aFnl2IZAAAAE3RSTlMAn+/fn5CAEGBAICDPr3C/v1Bg8gPz/wAAAYNJREFUWMOtl9lywzAIRYkQ2mzZSen/f2uX6UzGt7IJVc87R4sRYDpjKdJXVqU/UYX1B/KTU9Ank+F+wRZUJwRtV8S7/JRAVKcEUecEq84Jos4Jks4JNp0TtDApYB0R7pLKDXkbxJdRdK+ZPnlHboMDDDYgX9GvCkQRrkQXAvMGYyaPoCiQiFwCxvXJJ6h4/uwURBAs5BQwHsApaLgBr+CBG3AK8B1Xt6AfXwA5BVjJ7l4BfgTxCyCLZwXlvwV29cEjuOs3XqK3ATJ8xp1Mjg18xUTKZHGsX53ESGWjfCS81O7soQ9qapzBfP0MDcG1AR50herZQDSKKpJ5tFpA6+tTCI9ni2RkMT6dPGptA3JUICwnYuVlkEGsiBA9twBEUGTRi2U2HRDrM7r2oL8p+MKQsEsqJckedATDiOAlLDDmedmwzjhJRpJZRGPYtliNRLeIRqpbiPHLYxDg/mFmNbkvdEVh7/JIk3ARnjLZtMLucKRGVoClkov2SH391vDapZze3Ac97ZDnSKHPHwAAAABJRU5ErkJggg==",
  downloadUrl: {
    browserExtension: "https://chromewebstore.google.com/detail/gate-wallet/cpmkedoipcpimgecpmgpldfpohjplkpp"
  }
});
var $a = ae({
  name: "Phantom",
  label: "Phantom",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chromewebstore.google.com/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
  }
});
var ec = [
  // presets.SuiWallet,
  Ji,
  Ha,
  Ka,
  Ja,
  Pa,
  Ba,
  Va,
  ...[
    Qa,
    Wa,
    Fa,
    Ya,
    Za,
    // presets.SpacecyWallet,
    Ga,
    qa,
    Xa,
    _a4,
    $a
  ].sort((e, t) => e.name < t.name ? -1 : 1)
];
var bt = {
  id: "unknown:unknown",
  name: "Unknown Network",
  rpcUrl: ""
};
function we(e) {
  return `Failed to call ${e}, missing context provider to run within`;
}
var uc = {
  configuredWallets: [],
  detectedWallets: [],
  allAvailableWallets: [],
  chains: [],
  chain: void 0,
  name: void 0,
  adapter: void 0,
  connecting: false,
  connected: false,
  account: void 0,
  accounts: void 0,
  status: Oe.DISCONNECTED,
  address: void 0,
  async select() {
    throw new re(we("select"));
  },
  on() {
    throw new re(we("on"));
  },
  async disconnect() {
    throw new re(we("disconnect"));
  },
  getAccounts() {
    throw new re(we("getAccounts"));
  },
  async signTransaction() {
    throw new re(we("signTransaction"));
  },
  async signAndExecuteTransaction() {
    throw new re(we("signAndExecuteTransaction"));
  },
  async signPersonalMessage() {
    throw new re(we("signPersonalMessage"));
  },
  async reportTransactionEffects() {
    throw new re(we("reportTransactionEffects"));
  },
  verifySignedMessage() {
    throw new re(we("verifySignedMessage"));
  },
  async signMessage() {
    throw new re(we("signMessage"));
  },
  async signTransactionBlock() {
    throw new re(we("signTransactionBlock"));
  },
  async signAndExecuteTransactionBlock() {
    throw new re(we("signAndExecuteTransactionBlock"));
  }
};
var $i = (0, import_react2.createContext)(uc);
function Ft() {
  return (0, import_react2.useContext)($i);
}
function Nr(e, t) {
  return Nr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r2) {
    return n.__proto__ = r2, n;
  }, Nr(e, t);
}
function Zt(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Nr(e, t);
}
var Gt = /* @__PURE__ */ function() {
  function e() {
    this.listeners = [];
  }
  var t = e.prototype;
  return t.subscribe = function(r2) {
    var o = this, s = r2 || function() {
    };
    return this.listeners.push(s), this.onSubscribe(), function() {
      o.listeners = o.listeners.filter(function(l) {
        return l !== s;
      }), o.onUnsubscribe();
    };
  }, t.hasListeners = function() {
    return this.listeners.length > 0;
  }, t.onSubscribe = function() {
  }, t.onUnsubscribe = function() {
  }, e;
}();
function C() {
  return C = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r2 in n)
        ({}).hasOwnProperty.call(n, r2) && (e[r2] = n[r2]);
    }
    return e;
  }, C.apply(null, arguments);
}
var Sn = typeof window > "u";
function ii(e) {
  Promise.resolve().then(e).catch(function(t) {
    return setTimeout(function() {
      throw t;
    });
  });
}
var yc = /* @__PURE__ */ function(e) {
  Zt(t, e);
  function t() {
    var r2;
    return r2 = e.call(this) || this, r2.setup = function(o) {
      var s;
      if (!Sn && ((s = window) != null && s.addEventListener)) {
        var l = function() {
          return o();
        };
        return window.addEventListener("visibilitychange", l, false), window.addEventListener("focus", l, false), function() {
          window.removeEventListener("visibilitychange", l), window.removeEventListener("focus", l);
        };
      }
    }, r2;
  }
  var n = t.prototype;
  return n.onSubscribe = function() {
    this.cleanup || this.setEventListener(this.setup);
  }, n.onUnsubscribe = function() {
    if (!this.hasListeners()) {
      var o;
      (o = this.cleanup) == null || o.call(this), this.cleanup = void 0;
    }
  }, n.setEventListener = function(o) {
    var s, l = this;
    this.setup = o, (s = this.cleanup) == null || s.call(this), this.cleanup = o(function(c) {
      typeof c == "boolean" ? l.setFocused(c) : l.onFocus();
    });
  }, n.setFocused = function(o) {
    this.focused = o, o && this.onFocus();
  }, n.onFocus = function() {
    this.listeners.forEach(function(o) {
      o();
    });
  }, n.isFocused = function() {
    return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? true : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }, t;
}(Gt);
var Ut = new yc();
var Mc = /* @__PURE__ */ function(e) {
  Zt(t, e);
  function t() {
    var r2;
    return r2 = e.call(this) || this, r2.setup = function(o) {
      var s;
      if (!Sn && ((s = window) != null && s.addEventListener)) {
        var l = function() {
          return o();
        };
        return window.addEventListener("online", l, false), window.addEventListener("offline", l, false), function() {
          window.removeEventListener("online", l), window.removeEventListener("offline", l);
        };
      }
    }, r2;
  }
  var n = t.prototype;
  return n.onSubscribe = function() {
    this.cleanup || this.setEventListener(this.setup);
  }, n.onUnsubscribe = function() {
    if (!this.hasListeners()) {
      var o;
      (o = this.cleanup) == null || o.call(this), this.cleanup = void 0;
    }
  }, n.setEventListener = function(o) {
    var s, l = this;
    this.setup = o, (s = this.cleanup) == null || s.call(this), this.cleanup = o(function(c) {
      typeof c == "boolean" ? l.setOnline(c) : l.onOnline();
    });
  }, n.setOnline = function(o) {
    this.online = o, o && this.onOnline();
  }, n.onOnline = function() {
    this.listeners.forEach(function(o) {
      o();
    });
  }, n.isOnline = function() {
    return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? true : navigator.onLine;
  }, t;
}(Gt);
var mn = new Mc();
var vc = /* @__PURE__ */ function() {
  function e() {
    this.queue = [], this.transactions = 0, this.notifyFn = function(n) {
      n();
    }, this.batchNotifyFn = function(n) {
      n();
    };
  }
  var t = e.prototype;
  return t.batch = function(r2) {
    var o;
    this.transactions++;
    try {
      o = r2();
    } finally {
      this.transactions--, this.transactions || this.flush();
    }
    return o;
  }, t.schedule = function(r2) {
    var o = this;
    this.transactions ? this.queue.push(r2) : ii(function() {
      o.notifyFn(r2);
    });
  }, t.batchCalls = function(r2) {
    var o = this;
    return function() {
      for (var s = arguments.length, l = new Array(s), c = 0; c < s; c++)
        l[c] = arguments[c];
      o.schedule(function() {
        r2.apply(void 0, l);
      });
    };
  }, t.flush = function() {
    var r2 = this, o = this.queue;
    this.queue = [], o.length && ii(function() {
      r2.batchNotifyFn(function() {
        o.forEach(function(s) {
          r2.notifyFn(s);
        });
      });
    });
  }, t.setNotifyFunction = function(r2) {
    this.notifyFn = r2;
  }, t.setBatchNotifyFunction = function(r2) {
    this.batchNotifyFn = r2;
  }, e;
}();
var q = new vc();
var oo = console;
function Nc(e) {
  oo = e;
}
var Sc = import_react_dom.default.unstable_batchedUpdates;
q.setBatchNotifyFunction(Sc);
var Oc = console;
Nc(Oc);
function Rc() {
  var e = false;
  return {
    clearReset: function() {
      e = false;
    },
    reset: function() {
      e = true;
    },
    isReset: function() {
      return e;
    }
  };
}
var Uc = /* @__PURE__ */ import_react2.default.createContext(Rc());
var uo = (0, import_react2.createContext)(
  new SuiClient({
    url: bt.rpcUrl
  })
);
var rf = () => (0, import_react2.useContext)(uo);
var lo = { exports: {} };
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var r2 = [], o = 0; o < arguments.length; o++) {
        var s = arguments[o];
        if (s) {
          var l = typeof s;
          if (l === "string" || l === "number")
            r2.push(s);
          else if (Array.isArray(s)) {
            if (s.length) {
              var c = n.apply(null, s);
              c && r2.push(c);
            }
          } else if (l === "object") {
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
              r2.push(s.toString());
              continue;
            }
            for (var f in s)
              t.call(s, f) && s[f] && r2.push(f);
          }
        }
      }
      return r2.join(" ");
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(lo);
var Kc = lo.exports;
function Jc(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function fo(...e) {
  return (t) => e.forEach(
    (n) => Jc(n, t)
  );
}
function jt(...e) {
  return (0, import_react2.useCallback)(fo(...e), e);
}
function $c(e, t = []) {
  let n = [];
  function r2(s, l) {
    const c = /* @__PURE__ */ (0, import_react2.createContext)(l), f = n.length;
    n = [
      ...n,
      l
    ];
    function h(M2) {
      const _a7 = M2, { scope: A, children: N } = _a7, I2 = __objRest(_a7, ["scope", "children"]), v = (A == null ? void 0 : A[e][f]) || c, b2 = (0, import_react2.useMemo)(
        () => I2,
        Object.values(I2)
      );
      return /* @__PURE__ */ (0, import_react2.createElement)(v.Provider, {
        value: b2
      }, N);
    }
    function g(M2, A) {
      const N = (A == null ? void 0 : A[e][f]) || c, I2 = (0, import_react2.useContext)(N);
      if (I2)
        return I2;
      if (l !== void 0)
        return l;
      throw new Error(`\`${M2}\` must be used within \`${s}\``);
    }
    return h.displayName = s + "Provider", [
      h,
      g
    ];
  }
  const o = () => {
    const s = n.map((l) => /* @__PURE__ */ (0, import_react2.createContext)(l));
    return function(c) {
      const f = (c == null ? void 0 : c[e]) || s;
      return (0, import_react2.useMemo)(
        () => ({
          [`__scope${e}`]: __spreadProps(__spreadValues({}, c), {
            [e]: f
          })
        }),
        [
          c,
          f
        ]
      );
    };
  };
  return o.scopeName = e, [
    r2,
    eu(o, ...t)
  ];
}
function eu(...e) {
  const t = e[0];
  if (e.length === 1)
    return t;
  const n = () => {
    const r2 = e.map(
      (o) => ({
        useScope: o(),
        scopeName: o.scopeName
      })
    );
    return function(s) {
      const l = r2.reduce((c, { useScope: f, scopeName: h }) => {
        const M2 = f(s)[`__scope${h}`];
        return __spreadValues(__spreadValues({}, c), M2);
      }, {});
      return (0, import_react2.useMemo)(
        () => ({
          [`__scope${t.scopeName}`]: l
        }),
        [
          l
        ]
      );
    };
  };
  return n.scopeName = t.scopeName, n;
}
var br = (globalThis == null ? void 0 : globalThis.document) ? import_react2.useLayoutEffect : () => {
};
var Fr = /* @__PURE__ */ (0, import_react2.forwardRef)((e, t) => {
  const _a7 = e, { children: n } = _a7, r2 = __objRest(_a7, ["children"]), o = import_react2.Children.toArray(n), s = o.find(su);
  if (s) {
    const l = s.props.children, c = o.map((f) => f === s ? import_react2.Children.count(l) > 1 ? import_react2.Children.only(null) : /* @__PURE__ */ (0, import_react2.isValidElement)(l) ? l.props.children : null : f);
    return /* @__PURE__ */ (0, import_react2.createElement)(Dr, C({}, r2, {
      ref: t
    }), /* @__PURE__ */ (0, import_react2.isValidElement)(l) ? /* @__PURE__ */ (0, import_react2.cloneElement)(l, void 0, c) : null);
  }
  return /* @__PURE__ */ (0, import_react2.createElement)(Dr, C({}, r2, {
    ref: t
  }), n);
});
Fr.displayName = "Slot";
var Dr = /* @__PURE__ */ (0, import_react2.forwardRef)((e, t) => {
  const _a7 = e, { children: n } = _a7, r2 = __objRest(_a7, ["children"]);
  return /* @__PURE__ */ (0, import_react2.isValidElement)(n) ? /* @__PURE__ */ (0, import_react2.cloneElement)(n, __spreadProps(__spreadValues({}, au(r2, n.props)), {
    ref: fo(t, n.ref)
  })) : import_react2.Children.count(n) > 1 ? import_react2.Children.only(null) : null;
});
Dr.displayName = "SlotClone";
var ou = ({ children: e }) => /* @__PURE__ */ (0, import_react2.createElement)(import_react2.Fragment, null, e);
function su(e) {
  return /* @__PURE__ */ (0, import_react2.isValidElement)(e) && e.type === ou;
}
function au(e, t) {
  const n = __spreadValues({}, t);
  for (const r2 in t) {
    const o = e[r2], s = t[r2];
    /^on[A-Z]/.test(r2) ? o && s ? n[r2] = (...c) => {
      s(...c), o(...c);
    } : o && (n[r2] = o) : r2 === "style" ? n[r2] = __spreadValues(__spreadValues({}, o), s) : r2 === "className" && (n[r2] = [
      o,
      s
    ].filter(Boolean).join(" "));
  }
  return __spreadValues(__spreadValues({}, e), n);
}
var cu = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var ut = cu.reduce((e, t) => {
  const n = /* @__PURE__ */ (0, import_react2.forwardRef)((r2, o) => {
    const _a7 = r2, { asChild: s } = _a7, l = __objRest(_a7, ["asChild"]), c = s ? Fr : t;
    return (0, import_react2.useEffect)(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []), /* @__PURE__ */ (0, import_react2.createElement)(c, C({}, l, {
      ref: o
    }));
  });
  return n.displayName = `Primitive.${t}`, __spreadProps(__spreadValues({}, e), {
    [t]: n
  });
}, {});
var hi = Iu();
function Iu() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null ? void 0 : n.pause()), e = gi(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = gi(e, t), (n = e[0]) === null || n === void 0 || n.resume();
    }
  };
}
function gi(e, t) {
  const n = [
    ...e
  ], r2 = n.indexOf(t);
  return r2 !== -1 && n.splice(r2, 1), n;
}
function Du(e, t) {
  return (0, import_react2.useReducer)((n, r2) => {
    const o = t[n][r2];
    return o != null ? o : n;
  }, e);
}
var Fn = (e) => {
  const { present: t, children: n } = e, r2 = Eu(t), o = typeof n == "function" ? n({
    present: r2.isPresent
  }) : import_react2.Children.only(n), s = jt(r2.ref, o.ref);
  return typeof n == "function" || r2.isPresent ? /* @__PURE__ */ (0, import_react2.cloneElement)(o, {
    ref: s
  }) : null;
};
Fn.displayName = "Presence";
function Eu(e) {
  const [t, n] = (0, import_react2.useState)(), r2 = (0, import_react2.useRef)({}), o = (0, import_react2.useRef)(e), s = (0, import_react2.useRef)("none"), l = e ? "mounted" : "unmounted", [c, f] = Du(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return (0, import_react2.useEffect)(() => {
    const h = Xt(r2.current);
    s.current = c === "mounted" ? h : "none";
  }, [
    c
  ]), br(() => {
    const h = r2.current, g = o.current;
    if (g !== e) {
      const A = s.current, N = Xt(h);
      e ? f("MOUNT") : N === "none" || (h == null ? void 0 : h.display) === "none" ? f("UNMOUNT") : f(g && A !== N ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
    }
  }, [
    e,
    f
  ]), br(() => {
    if (t) {
      const h = (M2) => {
        const N = Xt(r2.current).includes(M2.animationName);
        M2.target === t && N && (0, import_react_dom.flushSync)(
          () => f("ANIMATION_END")
        );
      }, g = (M2) => {
        M2.target === t && (s.current = Xt(r2.current));
      };
      return t.addEventListener("animationstart", g), t.addEventListener("animationcancel", h), t.addEventListener("animationend", h), () => {
        t.removeEventListener("animationstart", g), t.removeEventListener("animationcancel", h), t.removeEventListener("animationend", h);
      };
    } else
      f("ANIMATION_END");
  }, [
    t,
    f
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(c),
    ref: (0, import_react2.useCallback)((h) => {
      h && (r2.current = getComputedStyle(h)), n(h);
    }, [])
  };
}
function Xt(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
var We = function() {
  return We = Object.assign || function(t) {
    for (var n, r2 = 1, o = arguments.length; r2 < o; r2++) {
      n = arguments[r2];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, We.apply(this, arguments);
};
function yo(e, t) {
  var n = {};
  for (var r2 in e)
    Object.prototype.hasOwnProperty.call(e, r2) && t.indexOf(r2) < 0 && (n[r2] = e[r2]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r2 = Object.getOwnPropertySymbols(e); o < r2.length; o++)
      t.indexOf(r2[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r2[o]) && (n[r2[o]] = e[r2[o]]);
  return n;
}
function Tu(e, t, n) {
  if (n || arguments.length === 2)
    for (var r2 = 0, o = t.length, s; r2 < o; r2++)
      (s || !(r2 in t)) && (s || (s = Array.prototype.slice.call(t, 0, r2)), s[r2] = t[r2]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var wn = "right-scroll-bar-position";
var bn = "width-before-scroll-bar";
var Cu = "with-scroll-bars-hidden";
var Lu = "--removed-body-scroll-bar-size";
function or(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Su(e, t) {
  var n = (0, import_react2.useState)(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r2) {
          var o = n.value;
          o !== r2 && (n.value = r2, n.callback(r2, o));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var Ou = typeof window < "u" ? W.useLayoutEffect : W.useEffect;
var Mi = /* @__PURE__ */ new WeakMap();
function xu(e, t) {
  var n = Su(null, function(r2) {
    return e.forEach(function(o) {
      return or(o, r2);
    });
  });
  return Ou(function() {
    var r2 = Mi.get(n);
    if (r2) {
      var o = new Set(r2), s = new Set(e), l = n.current;
      o.forEach(function(c) {
        s.has(c) || or(c, null);
      }), s.forEach(function(c) {
        o.has(c) || or(c, l);
      });
    }
    Mi.set(n, e);
  }, [e]), n;
}
function zu(e) {
  return e;
}
function Ru(e, t) {
  t === void 0 && (t = zu);
  var n = [], r2 = false, o = {
    read: function() {
      if (r2)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(s) {
      var l = t(s, r2);
      return n.push(l), function() {
        n = n.filter(function(c) {
          return c !== l;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r2 = true; n.length; ) {
        var l = n;
        n = [], l.forEach(s);
      }
      n = {
        push: function(c) {
          return s(c);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r2 = true;
      var l = [];
      if (n.length) {
        var c = n;
        n = [], c.forEach(s), l = n;
      }
      var f = function() {
        var g = l;
        l = [], g.forEach(s);
      }, h = function() {
        return Promise.resolve().then(f);
      };
      h(), n = {
        push: function(g) {
          l.push(g), h();
        },
        filter: function(g) {
          return l = l.filter(g), n;
        }
      };
    }
  };
  return o;
}
function Uu(e) {
  e === void 0 && (e = {});
  var t = Ru(null);
  return t.options = We({ async: true, ssr: false }, e), t;
}
var Mo = function(e) {
  var t = e.sideCar, n = yo(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r2 = t.read();
  if (!r2)
    throw new Error("Sidecar medium not found");
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(r2, __spreadValues({}, We({}, n)));
};
Mo.isSideCarExport = true;
function ku(e, t) {
  return e.useMedium(t), Mo;
}
var po = Uu();
var sr = function() {
};
var Zn = W.forwardRef(function(e, t) {
  var n = W.useRef(null), r2 = W.useState({
    onScrollCapture: sr,
    onWheelCapture: sr,
    onTouchMoveCapture: sr
  }), o = r2[0], s = r2[1], l = e.forwardProps, c = e.children, f = e.className, h = e.removeScrollBar, g = e.enabled, M2 = e.shards, A = e.sideCar, N = e.noIsolation, I2 = e.inert, v = e.allowPinchZoom, b2 = e.as, D = b2 === void 0 ? "div" : b2, x2 = yo(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), E2 = A, L = xu([n, t]), z = We(We({}, x2), o);
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, {
    children: [g && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(E2, {
      sideCar: po,
      removeScrollBar: h,
      shards: M2,
      noIsolation: N,
      inert: I2,
      setCallbacks: s,
      allowPinchZoom: !!v,
      lockRef: n
    }), l ? W.cloneElement(W.Children.only(c), We(We({}, z), {
      ref: L
    })) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(D, __spreadProps(__spreadValues({}, We({}, z, {
      className: f,
      ref: L
    })), {
      children: c
    }))]
  });
});
Zn.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
Zn.classNames = {
  fullWidth: bn,
  zeroRight: wn
};
var Pu = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Qu() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Pu();
  return t && e.setAttribute("nonce", t), e;
}
function Wu(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function Bu(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Yu = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Qu()) && (Wu(t, n), Bu(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
};
var Fu = function() {
  var e = Yu();
  return function(t, n) {
    W.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
};
var vo = function() {
  var e = Fu(), t = function(n) {
    var r2 = n.styles, o = n.dynamic;
    return e(r2, o), null;
  };
  return t;
};
var Zu = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var ar = function(e) {
  return parseInt(e || "", 10) || 0;
};
var Gu = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r2 = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [ar(n), ar(r2), ar(o)];
};
var Vu = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return Zu;
  var t = Gu(e), n = document.documentElement.clientWidth, r2 = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r2 - n + t[2] - t[0])
  };
};
var qu = vo();
var Et = "data-scroll-locked";
var Xu = function(e, t, n, r2) {
  var o = e.left, s = e.top, l = e.right, c = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Cu, ` {
   overflow: hidden `).concat(r2, `;
   padding-right: `).concat(c, "px ").concat(r2, `;
  }
  body[`).concat(Et, `] {
    overflow: hidden `).concat(r2, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(r2, ";"), n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(c, "px ").concat(r2, `;
    `), n === "padding" && "padding-right: ".concat(c, "px ").concat(r2, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(wn, ` {
    right: `).concat(c, "px ").concat(r2, `;
  }
  
  .`).concat(bn, ` {
    margin-right: `).concat(c, "px ").concat(r2, `;
  }
  
  .`).concat(wn, " .").concat(wn, ` {
    right: 0 `).concat(r2, `;
  }
  
  .`).concat(bn, " .").concat(bn, ` {
    margin-right: 0 `).concat(r2, `;
  }
  
  body[`).concat(Et, `] {
    `).concat(Lu, ": ").concat(c, `px;
  }
`);
};
var pi = function() {
  var e = parseInt(document.body.getAttribute(Et) || "0", 10);
  return isFinite(e) ? e : 0;
};
var _u = function() {
  W.useEffect(function() {
    return document.body.setAttribute(Et, (pi() + 1).toString()), function() {
      var e = pi() - 1;
      e <= 0 ? document.body.removeAttribute(Et) : document.body.setAttribute(Et, e.toString());
    };
  }, []);
};
var Hu = function(e) {
  var t = e.noRelative, n = e.noImportant, r2 = e.gapMode, o = r2 === void 0 ? "margin" : r2;
  _u();
  var s = W.useMemo(function() {
    return Vu(o);
  }, [o]);
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(qu, {
    styles: Xu(s, !t, o, n ? "" : "!important")
  });
};
var jr = false;
if (typeof window < "u")
  try {
    _t = Object.defineProperty({}, "passive", {
      get: function() {
        return jr = true, true;
      }
    });
    window.addEventListener("test", _t, _t), window.removeEventListener("test", _t, _t);
  } catch (e) {
    jr = false;
  }
var _t;
var pt = jr ? { passive: false } : false;
var Ku = function(e) {
  return e.tagName === "TEXTAREA";
};
var No = function(e, t) {
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Ku(e) && n[t] === "visible")
  );
};
var Ju = function(e) {
  return No(e, "overflowY");
};
var $u = function(e) {
  return No(e, "overflowX");
};
var vi = function(e, t) {
  var n = t;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var r2 = Ao(e, n);
    if (r2) {
      var o = mo(e, n), s = o[1], l = o[2];
      if (s > l)
        return true;
    }
    n = n.parentNode;
  } while (n && n !== document.body);
  return false;
};
var el = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r2 = e.clientHeight;
  return [
    t,
    n,
    r2
  ];
};
var tl = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r2 = e.clientWidth;
  return [
    t,
    n,
    r2
  ];
};
var Ao = function(e, t) {
  return e === "v" ? Ju(t) : $u(t);
};
var mo = function(e, t) {
  return e === "v" ? el(t) : tl(t);
};
var nl = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
};
var rl = function(e, t, n, r2, o) {
  var s = nl(e, window.getComputedStyle(t).direction), l = s * r2, c = n.target, f = t.contains(c), h = false, g = l > 0, M2 = 0, A = 0;
  do {
    var N = mo(e, c), I2 = N[0], v = N[1], b2 = N[2], D = v - b2 - s * I2;
    (I2 || D) && Ao(e, c) && (M2 += D, A += I2), c = c.parentNode;
  } while (
    // portaled content
    !f && c !== document.body || // self content
    f && (t.contains(c) || t === c)
  );
  return (g && (M2 === 0 || !o) || !g && (A === 0 || !o)) && (h = true), h;
};
var Ht = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
};
var Ni = function(e) {
  return [e.deltaX, e.deltaY];
};
var Ai = function(e) {
  return e && "current" in e ? e.current : e;
};
var il = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
};
var ol = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
};
var sl = 0;
var vt = [];
function al(e) {
  var t = W.useRef([]), n = W.useRef([0, 0]), r2 = W.useRef(), o = W.useState(sl++)[0], s = W.useState(function() {
    return vo();
  })[0], l = W.useRef(e);
  W.useEffect(function() {
    l.current = e;
  }, [e]), W.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var v = Tu([e.lockRef.current], (e.shards || []).map(Ai), true).filter(Boolean);
      return v.forEach(function(b2) {
        return b2.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), v.forEach(function(b2) {
          return b2.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var c = W.useCallback(function(v, b2) {
    if ("touches" in v && v.touches.length === 2)
      return !l.current.allowPinchZoom;
    var D = Ht(v), x2 = n.current, E2 = "deltaX" in v ? v.deltaX : x2[0] - D[0], L = "deltaY" in v ? v.deltaY : x2[1] - D[1], z, k2 = v.target, ee2 = Math.abs(E2) > Math.abs(L) ? "h" : "v";
    if ("touches" in v && ee2 === "h" && k2.type === "range")
      return false;
    var P4 = vi(ee2, k2);
    if (!P4)
      return true;
    if (P4 ? z = ee2 : (z = ee2 === "v" ? "h" : "v", P4 = vi(ee2, k2)), !P4)
      return false;
    if (!r2.current && "changedTouches" in v && (E2 || L) && (r2.current = z), !z)
      return true;
    var ue2 = r2.current || z;
    return rl(ue2, b2, v, ue2 === "h" ? E2 : L, true);
  }, []), f = W.useCallback(function(v) {
    var b2 = v;
    if (!(!vt.length || vt[vt.length - 1] !== s)) {
      var D = "deltaY" in b2 ? Ni(b2) : Ht(b2), x2 = t.current.filter(function(z) {
        return z.name === b2.type && z.target === b2.target && il(z.delta, D);
      })[0];
      if (x2 && x2.should) {
        b2.cancelable && b2.preventDefault();
        return;
      }
      if (!x2) {
        var E2 = (l.current.shards || []).map(Ai).filter(Boolean).filter(function(z) {
          return z.contains(b2.target);
        }), L = E2.length > 0 ? c(b2, E2[0]) : !l.current.noIsolation;
        L && b2.cancelable && b2.preventDefault();
      }
    }
  }, []), h = W.useCallback(function(v, b2, D, x2) {
    var E2 = {
      name: v,
      delta: b2,
      target: D,
      should: x2
    };
    t.current.push(E2), setTimeout(function() {
      t.current = t.current.filter(function(L) {
        return L !== E2;
      });
    }, 1);
  }, []), g = W.useCallback(function(v) {
    n.current = Ht(v), r2.current = void 0;
  }, []), M2 = W.useCallback(function(v) {
    h(v.type, Ni(v), v.target, c(v, e.lockRef.current));
  }, []), A = W.useCallback(function(v) {
    h(v.type, Ht(v), v.target, c(v, e.lockRef.current));
  }, []);
  W.useEffect(function() {
    return vt.push(s), e.setCallbacks({
      onScrollCapture: M2,
      onWheelCapture: M2,
      onTouchMoveCapture: A
    }), document.addEventListener("wheel", f, pt), document.addEventListener("touchmove", f, pt), document.addEventListener("touchstart", g, pt), function() {
      vt = vt.filter(function(v) {
        return v !== s;
      }), document.removeEventListener("wheel", f, pt), document.removeEventListener("touchmove", f, pt), document.removeEventListener("touchstart", g, pt);
    };
  }, []);
  var N = e.removeScrollBar, I2 = e.inert;
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, {
    children: [I2 ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(s, {
      styles: ol(o)
    }) : null, N ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Hu, {
      gapMode: "margin"
    }) : null]
  });
}
var cl = ku(po, al);
var Io = W.forwardRef(function(e, t) {
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Zn, __spreadValues({}, We({}, e, {
    ref: t,
    sideCar: cl
  })));
});
Io.classNames = Zn.classNames;
var bo = "Dialog";
var [Do, sf] = $c(bo);
var [hl, Ye] = Do(bo);
var Eo = "DialogPortal";
var [pl, jo] = Do(Eo, {
  forceMount: void 0
});

// src/lib/txHelper/pt.ts
var getPtOutForExactSyIn = ({
  tx,
  coinConfig,
  syAmount,
  minPtAmount,
  priceVoucher,
  returnDebugInfo
}) => {
  const moveCallInfo = {
    target: `${coinConfig.nemoContractId}::router::get_pt_out_for_exact_sy_in_with_price_voucher`,
    arguments: [
      { name: "net_sy_in", value: syAmount },
      { name: "min_pt_out", value: minPtAmount },
      { name: "price_voucher", value: "priceVoucher" },
      { name: "py_state_id", value: coinConfig.pyStateId },
      {
        name: "market_factory_config_id",
        value: coinConfig.marketFactoryConfigId
      },
      { name: "market_state_id", value: coinConfig.marketStateId },
      { name: "clock", value: "0x6" }
    ],
    typeArguments: [coinConfig.syCoinType]
  };
  const txMoveCall = {
    target: moveCallInfo.target,
    arguments: [
      tx.pure.u64(syAmount),
      tx.pure.u64(minPtAmount),
      priceVoucher,
      tx.object(coinConfig.pyStateId),
      tx.object(coinConfig.marketFactoryConfigId),
      tx.object(coinConfig.marketStateId),
      tx.object("0x6")
    ],
    typeArguments: moveCallInfo.typeArguments
  };
  const result = tx.moveCall(txMoveCall);
  return returnDebugInfo ? [result, moveCallInfo] : result;
};

// src/hooks/dryRun/pt/useQueryPtOutBySyIn.ts
function useQueryPtOutBySyIn({ outerCoinConfig, debug } = {
  debug: false
}) {
  const client = rf();
  const address = DEFAULT_Address;
  return useMutation({
    mutationFn: async ({
      syAmount,
      innerCoinConfig,
      minPtAmount = "0"
    }) => {
      var _a7, _b3, _c;
      const coinConfig = outerCoinConfig || innerCoinConfig;
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const tx = new Transaction();
      tx.setSender(address);
      const [priceVoucher, priceVoucherInfo] = getPriceVoucher(tx, coinConfig);
      const [, getPtOutForExactSyInMoveCallInfo] = getPtOutForExactSyIn({
        tx,
        coinConfig,
        syAmount,
        minPtAmount,
        priceVoucher,
        returnDebugInfo: true
      });
      const result = await client.devInspectTransactionBlock({
        sender: address,
        transactionBlock: await tx.build({
          client,
          onlyTransactionKind: true
        })
      });
      const debugInfo = {
        moveCall: [priceVoucherInfo, getPtOutForExactSyInMoveCallInfo],
        rawResult: result
      };
      if (result == null ? void 0 : result.error) {
        throw new ContractError(result.error, debugInfo);
      }
      if (!((_c = (_b3 = (_a7 = result == null ? void 0 : result.results) == null ? void 0 : _a7[1]) == null ? void 0 : _b3.returnValues) == null ? void 0 : _c[0])) {
        const message = "Failed to get PT amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      const ptAmount = suiBcs.U64.parse(
        new Uint8Array(result.results[1].returnValues[0][0])
      );
      const ptValue = new decimal_default(ptAmount.toString()).div(10 ** Number(coinConfig.decimal)).toFixed();
      const parsedSyAmount = suiBcs.U64.parse(
        new Uint8Array(result.results[1].returnValues[1][0])
      );
      const syValue = new decimal_default(parsedSyAmount.toString()).div(10 ** Number(coinConfig.decimal)).toFixed();
      const fee = suiBcs.U128.parse(
        new Uint8Array(result.results[1].returnValues[2][0])
      );
      const tradeFee = new decimal_default(fee).div(2 ** 64).div(10 ** Number(coinConfig.decimal)).toString();
      debugInfo.parsedOutput = `${ptValue} ${syValue} ${tradeFee}`;
      return debug ? [{ ptValue, ptAmount, syValue, syAmount, tradeFee }, debugInfo] : { ptValue, ptAmount, syValue, syAmount, tradeFee };
    }
  });
}

// src/hooks/useQuerySyOutFromPtInWithVoucher.ts
function useQuerySyOutFromPtInWithVoucher(coinConfig, debug = false) {
  const client = rf();
  const { address } = Ft();
  return useMutation({
    mutationFn: async (ptAmount) => {
      var _a7, _b3, _c;
      if (!address) {
        throw new Error("Please connect wallet first");
      }
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const tx = new Transaction();
      tx.setSender(address);
      const [priceVoucher] = getPriceVoucher(tx, coinConfig);
      const moveCall = {
        target: `${coinConfig.nemoContractId}::router::get_sy_amount_out_for_exact_pt_in_with_price_voucher`,
        arguments: [
          { name: "exact_pt_in", value: ptAmount },
          { name: "price_voucher", value: "priceVoucher" },
          { name: "py_state", value: coinConfig.pyStateId },
          {
            name: "market_factory_config",
            value: coinConfig.marketFactoryConfigId
          },
          { name: "market", value: coinConfig.marketStateId },
          { name: "clock", value: "0x6" }
        ],
        typeArguments: [coinConfig.syCoinType]
      };
      tx.moveCall({
        target: moveCall.target,
        arguments: [
          tx.pure.u64(ptAmount),
          priceVoucher,
          tx.object(coinConfig.pyStateId),
          tx.object(coinConfig.marketFactoryConfigId),
          tx.object(coinConfig.marketStateId),
          tx.object("0x6")
        ],
        typeArguments: moveCall.typeArguments
      });
      const result = await client.devInspectTransactionBlock({
        sender: address,
        transactionBlock: await tx.build({
          client,
          onlyTransactionKind: true
        })
      });
      const debugInfo = {
        moveCall: [moveCall],
        rawResult: result
      };
      debugInfo.rawResult = {
        error: result == null ? void 0 : result.error,
        results: result == null ? void 0 : result.results
      };
      if (result == null ? void 0 : result.error) {
        throw new ContractError(result.error, debugInfo);
      }
      if (!((_c = (_b3 = (_a7 = result == null ? void 0 : result.results) == null ? void 0 : _a7[1]) == null ? void 0 : _b3.returnValues) == null ? void 0 : _c[0])) {
        const message = "Failed to get SY amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      const outputAmount = suiBcs.U64.parse(
        new Uint8Array(result.results[1].returnValues[0][0])
      );
      const formattedAmount = new decimal_default(outputAmount.toString()).div(10 ** Number(coinConfig.decimal)).toFixed();
      debugInfo.parsedOutput = formattedAmount;
      return debug ? [formattedAmount, debugInfo] : formattedAmount;
    }
  });
}

// src/lib/utils.ts
var import_dayjs = __toESM(require_dayjs_min());

// ../../node_modules/.pnpm/tailwind-merge@2.6.0/node_modules/tailwind-merge/dist/bundle-mjs.mjs
var CLASS_PART_SEPARATOR = "-";
var createClassGroupUtils = (config3) => {
  const classMap = createClassMap(config3);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config3;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, classPartObject) => {
  var _a7;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a7 = classPartObject.validators.find(({
    validator
  }) => validator(classRest))) == null ? void 0 : _a7.classGroupId;
};
var arbitraryPropertyRegex = /^\[(.+)\]$/;
var getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
var createClassMap = (config3) => {
  const {
    theme,
    prefix
  } = config3;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config3.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
var getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
var isThemeGetter = (func) => func.isThemeGetter;
var getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var createParseClassName = (config3) => {
  const {
    separator,
    experimentalParseClassName
  } = config3;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index = 0; index < className.length; index++) {
      let currentCharacter = className[index];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index));
          modifierStart = index + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className) => experimentalParseClassName({
      className,
      parseClassName
    });
  }
  return parseClassName;
};
var sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
var createConfigUtils = (config3) => __spreadValues({
  cache: createLruCache(config3.cacheSize),
  parseClassName: createParseClassName(config3)
}, createClassGroupUtils(config3));
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1; index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0; i < conflictGroups.length; ++i) {
      const group = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index = 0;
  let argument;
  let resolvedValue;
  let string2 = "";
  while (index < arguments.length) {
    if (argument = arguments[index++]) {
      if (resolvedValue = toValue(argument)) {
        string2 && (string2 += " ");
        string2 += resolvedValue;
      }
    }
  }
  return string2;
}
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string2 = "";
  for (let k2 = 0; k2 < mix.length; k2++) {
    if (mix[k2]) {
      if (resolvedValue = toValue(mix[k2])) {
        string2 && (string2 += " ");
        string2 += resolvedValue;
      }
    }
  }
  return string2;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config3 = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config3);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var fractionRegex = /^\d+\/\d+$/;
var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
var isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
var isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
var isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
var isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
var imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
var isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
var isAny = () => true;
var getIsArbitraryValue = (value, label, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);

// ../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// src/lib/utils.ts
function cn2(...inputs) {
  return twMerge(clsx(inputs));
}
var truncateStr = (str, charsPerSide = 4) => {
  if (str.length < charsPerSide * 4) {
    return str;
  }
  return `${str.slice(0, charsPerSide)}...${str.slice(-charsPerSide)}`;
};
var debounce = (func, delay) => {
  let timeout = null;
  const debounced = (...args) => {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      func(...args);
    }, delay);
  };
  debounced.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  return debounced;
};
var formatDecimalValue = (_value, decimal = 0) => {
  try {
    const value = _value instanceof decimal_default ? _value : new decimal_default(_value || 0);
    return value.decimalPlaces() > decimal ? value.toFixed(Number(decimal)) : value.toFixed(value.decimalPlaces());
  } catch (error) {
    return "0";
  }
};
var splitSyAmount = (syAmount, lpSupply, totalSy, totalPt, exchangeRate, pyIndexStored) => {
  const result = getMintLpParameter(
    syAmount,
    lpSupply,
    totalSy,
    totalPt,
    exchangeRate,
    pyIndexStored
  );
  const syForPtValue = (result == null ? void 0 : result.syForPt.toFixed(0)) || "1";
  const syValue = (result == null ? void 0 : result.syDesired.toFixed(0)) || "1";
  const ptValue = (result == null ? void 0 : result.pt.toFixed(0)) || "1";
  return { syForPtValue, syValue, ptValue };
};
function getMintLpParameter(syAmount, lpSupply, totalSy, totalPt, exchangeRate, pyIndexStored) {
  const total_sy = Number(syAmount);
  const lp_supply = Number(lpSupply);
  const total_sy_reserve = Number(totalSy);
  const total_pt_reserve = Number(totalPt);
  const exchange_rate_num = Number(exchangeRate);
  const py_index_stored_num = Number(pyIndexStored);
  if (lpSupply == "0") {
    const syIn = new decimal_default(syAmount).div(2).toString();
    const max_rate = get_max_rate(exchange_rate_num, py_index_stored_num);
    const ptIn = new decimal_default(syAmount).div(2).mul(max_rate).toString();
    const syInNumber = Number(syIn);
    const ptInNumber = Number(ptIn);
    return {
      syForPt: ptInNumber,
      syDesired: syInNumber,
      pt: get_pt_out(ptInNumber, exchange_rate_num, py_index_stored_num)
    };
  }
  let left = 0;
  let right = total_sy;
  let sy_for_pt = -1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    const net_lp_by_pt = get_pt_out(mid, exchange_rate_num, py_index_stored_num) * lp_supply / total_pt_reserve;
    const sy_desired = (total_sy_reserve * net_lp_by_pt + (lp_supply - 1)) / lp_supply;
    if (total_sy >= mid + sy_desired && total_sy <= mid + sy_desired + 100) {
      sy_for_pt = mid;
      return {
        syForPt: sy_for_pt,
        syDesired: sy_desired,
        pt: get_pt_out(sy_for_pt, exchange_rate_num, py_index_stored_num)
      };
    } else if (mid + sy_desired < total_sy) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return null;
}
function get_max_rate(exchange_rate, py_index_stored) {
  return Math.max(exchange_rate / 2 ** 64, py_index_stored / 2 ** 64);
}
function get_pt_out(syAmount, exchange_rate, py_index_stored) {
  const max_rate = Math.max(exchange_rate / 2 ** 64, py_index_stored / 2 ** 64);
  return syAmount * max_rate;
}
function handleInfinityValues(data) {
  if (typeof data !== "object" || data === null) return data;
  const result = Array.isArray(data) ? [...data] : __spreadValues({}, data);
  Object.entries(result).forEach(([key, value]) => {
    if (typeof value === "string" && (value === "+Inf" || value === "-Inf")) {
      const typedResult = result;
      typedResult[key] = "";
    } else if (typeof value === "object" && value !== null) {
      const typedResult = result;
      typedResult[key] = handleInfinityValues(value);
    }
  });
  return result;
}
var isValidAmount = (amount) => {
  if (!amount || amount === 0 || amount === "" || amount === "0" || amount === "NaN" || new decimal_default(amount).isZero())
    return false;
  const num = Number(amount);
  return !isNaN(num) && num > 0;
};
var formatTimeDiff = (timestamp) => {
  const maturityTime = (0, import_dayjs.default)(timestamp);
  const now = (0, import_dayjs.default)();
  const diffSeconds = maturityTime.diff(now, "second");
  if (diffSeconds <= 0) {
    return "Pool Expired";
  }
  const diffDays = maturityTime.diff(now, "day");
  if (diffDays > 0) {
    return `${diffDays} DAYS`;
  }
  const diffHours = maturityTime.diff(now, "hour");
  if (diffHours > 0) {
    return `${diffHours} HOURS`;
  }
  const diffMinutes = maturityTime.diff(now, "minute");
  if (diffMinutes > 0) {
    return `${diffMinutes} MINS`;
  }
  return `${diffSeconds} SECS`;
};
var safeDivide = (numerator, denominator, returnType = "string") => {
  try {
    const num = new decimal_default(numerator || 0);
    const den = new decimal_default(denominator || 0);
    if (!isValidAmount(denominator)) {
      return returnType === "string" ? "0" : returnType === "number" ? 0 : new decimal_default(0);
    }
    const result = num.div(den);
    return returnType === "number" ? result.toNumber() : returnType === "decimal" ? result : result.toString();
  } catch (e) {
    return returnType === "string" ? "0" : returnType === "number" ? 0 : new decimal_default(0);
  }
};
var formatLargeNumber = (value, decimals = 2) => {
  try {
    if (!value) return "0";
    const num = new decimal_default(value);
    const abs3 = num.abs();
    if (abs3.greaterThanOrEqualTo(new decimal_default("1e15"))) {
      return "\u221E";
    }
    if (abs3.lessThan(1e6)) {
      return formatDecimalValue(num, decimals);
    }
    const suffixes = ["", "M", "B", "T"];
    const magnitude = Math.min(Math.floor(abs3.log(1e6).toNumber()), 3);
    return formatDecimalValue(
      num.div(new decimal_default(1e6).pow(magnitude)),
      decimals
    ).concat(suffixes[magnitude]);
  } catch (e) {
    return "0";
  }
};
var formatTVL = (tvlStr) => {
  const num = parseFloat(tvlStr.replace(/,/g, ""));
  if (isNaN(num)) return tvlStr;
  if (num < 1e3) {
    return `$${num.toFixed(2)}`;
  }
  if (num < 1e6) {
    return `$${num.toLocaleString("en-US", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    })}`;
  }
  if (num < 1e9) {
    return `$${(num / 1e6).toFixed(2)}M`;
  }
  return `$${(num / 1e9).toFixed(2)}B`;
};
function formatPortfolioNumber(input) {
  let val;
  if (typeof input === "string") {
    val = new decimal_default(input.replace(/,/g, ""));
  } else if (typeof input === "number") {
    val = new decimal_default(input);
  } else {
    val = input;
  }
  if (!val.isFinite()) {
    return input.toString();
  }
  if (val.lt(0.01)) {
    return "0.01";
  }
  if (val.lt(1e3)) {
    return `${val.toFixed(2)}`;
  }
  if (val.lt(1e6)) {
    return `${val.toNumber().toLocaleString("en-US", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    })}`;
  }
  if (val.lt(1e9)) {
    return `${val.div(1e6).toFixed(2)}M`;
  }
  return `${val.div(1e9).toFixed(2)}B`;
}

// src/hooks/useQueryYtOutBySyInWithVoucher.ts
function useQueryYtOutBySyInWithVoucher(coinConfig, debug = false) {
  const client = rf();
  const { address } = Ft();
  return useMutation({
    mutationFn: async (syAmount) => {
      var _a7, _b3, _c;
      if (!address) {
        throw new Error("Please connect wallet first");
      }
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const tx = new Transaction();
      const [priceVoucher, priceVoucherInfo] = getPriceVoucher(tx, coinConfig);
      tx.setSender(address);
      const moveCallInfo = {
        target: `${coinConfig.nemoContractId}::router::get_yt_out_for_exact_sy_in_with_price_voucher`,
        arguments: [
          { name: "net_sy_in", value: syAmount },
          { name: "min_yt_out", value: "0" },
          { name: "price_voucher", value: "priceVoucher" },
          { name: "py_state_id", value: coinConfig.pyStateId },
          { name: "market_state_id", value: coinConfig.marketStateId },
          { name: "clock", value: "0x6" }
        ],
        typeArguments: [coinConfig.syCoinType]
      };
      tx.moveCall({
        target: moveCallInfo.target,
        arguments: [
          tx.pure.u64(syAmount),
          tx.pure.u64("0"),
          priceVoucher,
          tx.object(coinConfig.pyStateId),
          tx.object(coinConfig.marketFactoryConfigId),
          tx.object(coinConfig.marketStateId),
          tx.object("0x6")
        ],
        typeArguments: moveCallInfo.typeArguments
      });
      const result = await client.devInspectTransactionBlock({
        sender: address,
        transactionBlock: await tx.build({
          client,
          onlyTransactionKind: true
        })
      });
      const debugInfo = {
        moveCall: [priceVoucherInfo, moveCallInfo],
        rawResult: result
      };
      if (result == null ? void 0 : result.error) {
        throw new ContractError(result.error, debugInfo);
      }
      if (!((_c = (_b3 = (_a7 = result == null ? void 0 : result.results) == null ? void 0 : _a7[1]) == null ? void 0 : _b3.returnValues) == null ? void 0 : _c[0])) {
        const message = "Failed to get YT amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      const decimal = Number(coinConfig.decimal);
      const ytAmount = suiBcs.U64.parse(
        new Uint8Array(result.results[1].returnValues[0][0])
      );
      const ytValue = formatDecimalValue(
        new decimal_default(ytAmount).div(10 ** decimal),
        decimal
      );
      const feeAmount = suiBcs.U128.parse(
        new Uint8Array(result.results[1].returnValues[1][0])
      );
      const feeValue = formatDecimalValue(
        new decimal_default(feeAmount).div(2 ** 64).div(10 ** decimal),
        decimal
      );
      const resultObj = { ytValue, feeValue, ytAmount };
      debugInfo.parsedOutput = `${ytValue},${feeValue}`;
      return debug ? [resultObj, debugInfo] : resultObj;
    }
  });
}

// src/hooks/useQueryPriceVoucher.ts
function useQueryPriceVoucher(coinConfig, debug = false) {
  const client = rf();
  const address = DEFAULT_Address;
  return useMutation({
    mutationFn: async () => {
      var _a7, _b3, _c;
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const tx = new Transaction();
      tx.setSender(address);
      const debugInfo = {
        moveCall: [],
        rawResult: {}
      };
      try {
        const [, priceVoucherMoveCallInfo] = getPriceVoucher(tx, coinConfig);
        debugInfo.moveCall = [priceVoucherMoveCallInfo];
        const result = await client.devInspectTransactionBlock({
          sender: address,
          transactionBlock: await tx.build({
            client,
            onlyTransactionKind: true
          })
        });
        debugInfo.rawResult = result;
        if (result == null ? void 0 : result.error) {
          throw new ContractError(
            "useQueryPriceVoucher error: " + result.error,
            debugInfo
          );
        }
        if (!((_c = (_b3 = (_a7 = result == null ? void 0 : result.results) == null ? void 0 : _a7[0]) == null ? void 0 : _b3.returnValues) == null ? void 0 : _c[0])) {
          const message = "Failed to get price voucher";
          debugInfo.rawResult.error = message;
          throw new ContractError(message, debugInfo);
        }
        const outputVoucher = suiBcs.U128.parse(
          new Uint8Array(result.results[0].returnValues[0][0])
        ).toString();
        debugInfo.parsedOutput = outputVoucher;
        return debug ? [outputVoucher, debugInfo] : outputVoucher;
      } catch (error) {
        throw new Error("Failed to get price voucher");
      }
    }
  });
}

// src/hooks/dryRun/sy/useQuerySyOutByYtIn.ts
function useQuerySyOutByYtInDryRun({ outerCoinConfig, debug } = {
  debug: false
}) {
  const client = rf();
  const address = DEFAULT_Address;
  return useMutation({
    mutationFn: async ({
      ytAmount,
      innerCoinConfig
    }) => {
      var _a7, _b3, _c, _d, _e3, _f, _g, _h;
      const coinConfig = outerCoinConfig || innerCoinConfig;
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const tx = new Transaction();
      tx.setSender(address);
      const [priceVoucher] = getPriceVoucher(tx, coinConfig);
      const moveCallInfo = {
        target: `${coinConfig.nemoContractId}::router::get_sy_amount_out_for_exact_yt_in_with_price_voucher`,
        arguments: [
          { name: "exact_yt_in", value: ytAmount },
          { name: "price_voucher", value: "priceVoucher" },
          { name: "py_state", value: coinConfig.pyStateId },
          {
            name: "market_factory_config",
            value: coinConfig.marketFactoryConfigId
          },
          { name: "market", value: coinConfig.marketStateId },
          { name: "clock", value: "0x6" }
        ],
        typeArguments: [coinConfig.syCoinType]
      };
      tx.moveCall({
        target: moveCallInfo.target,
        arguments: [
          tx.pure.u64(ytAmount),
          priceVoucher,
          tx.object(coinConfig.pyStateId),
          tx.object(coinConfig.marketFactoryConfigId),
          tx.object(coinConfig.marketStateId),
          tx.object("0x6")
        ],
        typeArguments: moveCallInfo.typeArguments
      });
      const result = await client.devInspectTransactionBlock({
        sender: address,
        transactionBlock: await tx.build({
          client,
          onlyTransactionKind: true
        })
      });
      const debugInfo = {
        moveCall: [moveCallInfo],
        rawResult: result
      };
      if (result == null ? void 0 : result.error) {
        throw new ContractError(result.error, debugInfo);
      }
      if (((_d = (_c = (_b3 = (_a7 = result == null ? void 0 : result.results) == null ? void 0 : _a7[result.results.length - 1]) == null ? void 0 : _b3.returnValues) == null ? void 0 : _c[0]) == null ? void 0 : _d[1]) !== "u64") {
        const message = "Failed to get sy amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      const returnValue = (_h = (_g = (_f = (_e3 = result == null ? void 0 : result.results) == null ? void 0 : _e3[result.results.length - 1]) == null ? void 0 : _f.returnValues) == null ? void 0 : _g[0]) == null ? void 0 : _h[0];
      if (!returnValue) {
        const message = "Failed to get sy amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      const syAmount = suiBcs.U64.parse(
        new Uint8Array(returnValue)
      );
      const syValue = new decimal_default(syAmount.toString()).div(10 ** Number(coinConfig.decimal)).toFixed();
      debugInfo.parsedOutput = syAmount;
      const resultObj = { syValue, syAmount };
      return debug ? [resultObj, debugInfo] : resultObj;
    }
  });
}

// ../../node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@18.3.21_react@19.1.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React7 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React7.useCallback(composeRefs(...refs), refs);
}

// ../../node_modules/.pnpm/@radix-ui+react-slot@1.2.2_@types+react@18.3.21_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.mjs
var React8 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = React8.forwardRef((props, forwardedRef) => {
    const _a7 = props, { children } = _a7, slotProps = __objRest(_a7, ["children"]);
    const childrenArray = React8.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React8.Children.count(newElement) > 1) return React8.Children.only(null);
          return React8.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(SlotClone, __spreadProps(__spreadValues({}, slotProps), { ref: forwardedRef, children: React8.isValidElement(newElement) ? React8.cloneElement(newElement, void 0, newChildren) : null }));
    }
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(SlotClone, __spreadProps(__spreadValues({}, slotProps), { ref: forwardedRef, children }));
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
  const SlotClone = React8.forwardRef((props, forwardedRef) => {
    const _a7 = props, { children } = _a7, slotProps = __objRest(_a7, ["children"]);
    const childrenRef = React8.isValidElement(children) ? getElementRef(children) : void 0;
    const ref = useComposedRefs(childrenRef, forwardedRef);
    if (React8.isValidElement(children)) {
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React8.Fragment) {
        props2.ref = ref;
      }
      return React8.cloneElement(children, props2);
    }
    return React8.Children.count(children) > 1 ? React8.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable(child) {
  return React8.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = __spreadValues({}, childProps);
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = __spreadValues(__spreadValues({}, slotPropValue), childPropValue);
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return __spreadValues(__spreadValues({}, slotProps), overrideProps);
}
function getElementRef(element) {
  var _a7, _b3;
  let getter = (_a7 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a7.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b3 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b3.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/.pnpm/@mysten+dapp-kit@0.14.44_@tanstack+react-query@5.76.0_react@19.1.0__@types+react-dom@18.3.7_@_ckag77vru7hslt4afqvecufmau/node_modules/@mysten/dapp-kit/dist/esm/index.js
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@vanilla-extract+recipes@0.5.5_@vanilla-extract+css@1.17.2/node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js
function toPrimitive(t, r2) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
function mapValues(input, fn3) {
  var result = {};
  for (var _key in input) {
    result[_key] = fn3(input[_key], _key);
  }
  return result;
}
var shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {
  for (var key of Object.keys(compoundCheck)) {
    var _selections$key;
    if (compoundCheck[key] !== ((_selections$key = selections[key]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key])) {
      return false;
    }
  }
  return true;
};
var createRuntimeFn = (config3) => {
  var runtimeFn = (options) => {
    var className = config3.defaultClassName;
    var selections = _objectSpread2(_objectSpread2({}, config3.defaultVariants), options);
    for (var variantName in selections) {
      var _selections$variantNa;
      var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config3.defaultVariants[variantName];
      if (variantSelection != null) {
        var selection = variantSelection;
        if (typeof selection === "boolean") {
          selection = selection === true ? "true" : "false";
        }
        var selectionClassName = (
          // @ts-expect-error
          config3.variantClassNames[variantName][selection]
        );
        if (selectionClassName) {
          className += " " + selectionClassName;
        }
      }
    }
    for (var [compoundCheck, compoundClassName] of config3.compoundVariants) {
      if (shouldApplyCompound(compoundCheck, selections, config3.defaultVariants)) {
        className += " " + compoundClassName;
      }
    }
    return className;
  };
  runtimeFn.variants = () => Object.keys(config3.variantClassNames);
  runtimeFn.classNames = {
    get base() {
      return config3.defaultClassName.split(" ")[0];
    },
    get variants() {
      return mapValues(config3.variantClassNames, (classNames) => mapValues(classNames, (className) => className.split(" ")[0]));
    }
  };
  return runtimeFn;
};

// ../../node_modules/.pnpm/@mysten+dapp-kit@0.14.44_@tanstack+react-query@5.76.0_react@19.1.0__@types+react-dom@18.3.7_@_ckag77vru7hslt4afqvecufmau/node_modules/@mysten/dapp-kit/dist/esm/index.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var import_react15 = __toESM(require_react(), 1);
var import_react16 = __toESM(require_react(), 1);
var import_react17 = __toESM(require_react(), 1);
var import_react18 = __toESM(require_react(), 1);
var import_react19 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@vanilla-extract+private@1.0.7/node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js
function getVarName(variable) {
  var matches = variable.match(/^var\((.*)\)$/);
  if (matches) {
    return matches[1];
  }
  return variable;
}
function walkObject(obj, fn3) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var clone3 = {};
  for (var key in obj) {
    var _value = obj[key];
    var currentPath = [...path, key];
    if (typeof _value === "string" || typeof _value === "number" || _value == null) {
      clone3[key] = fn3(_value, currentPath);
    } else if (typeof _value === "object" && !Array.isArray(_value)) {
      clone3[key] = walkObject(_value, fn3, currentPath);
    } else {
      console.warn('Skipping invalid key "'.concat(currentPath.join("."), '". Should be a string, number, null or object. Received: "').concat(Array.isArray(_value) ? "Array" : typeof _value, '"'));
    }
  }
  return clone3;
}

// ../../node_modules/.pnpm/@vanilla-extract+css@1.17.2/node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.esm.js
var stylesheets = {};
var injectStyles = (_ref) => {
  var {
    fileScope,
    css
  } = _ref;
  var fileScopeId = fileScope.packageName ? [fileScope.packageName, fileScope.filePath].join("/") : fileScope.filePath;
  var stylesheet = stylesheets[fileScopeId];
  if (!stylesheet) {
    var styleEl = document.createElement("style");
    if (fileScope.packageName) {
      styleEl.setAttribute("data-package", fileScope.packageName);
    }
    styleEl.setAttribute("data-file", fileScope.filePath);
    styleEl.setAttribute("type", "text/css");
    stylesheet = stylesheets[fileScopeId] = styleEl;
    document.head.appendChild(styleEl);
  }
  stylesheet.innerHTML = css;
};

// ../../node_modules/.pnpm/@vanilla-extract+css@1.17.2/node_modules/@vanilla-extract/css/dist/transformCss-0dba36bf.esm.js
var import_cssesc = __toESM(require_cssesc());

// ../../node_modules/.pnpm/modern-ahocorasick@1.1.0/node_modules/modern-ahocorasick/dist/index.js
var AhoCorasick = class {
  constructor(keywords) {
    const { failure, gotoFn, output } = this._buildTables(keywords);
    this.gotoFn = gotoFn;
    this.output = output;
    this.failure = failure;
  }
  _buildTables(keywords) {
    const gotoFn = {
      0: {}
    };
    const output = {};
    let state = 0;
    for (const word of keywords) {
      let curr = 0;
      for (const l of word) {
        if (gotoFn[curr] && l in gotoFn[curr]) {
          curr = gotoFn[curr][l];
        } else {
          state++;
          gotoFn[curr][l] = state;
          gotoFn[state] = {};
          curr = state;
          output[state] = [];
        }
      }
      output[curr].push(word);
    }
    const failure = {};
    const xs = [];
    for (const l in gotoFn[0]) {
      const state2 = gotoFn[0][l];
      failure[state2] = 0;
      xs.push(state2);
    }
    while (xs.length > 0) {
      const r2 = xs.shift();
      if (r2 !== void 0) {
        for (const l in gotoFn[r2]) {
          const s = gotoFn[r2][l];
          xs.push(s);
          let state2 = failure[r2];
          while (state2 > 0 && !(l in gotoFn[state2])) {
            state2 = failure[state2];
          }
          if (l in gotoFn[state2]) {
            const fs2 = gotoFn[state2][l];
            failure[s] = fs2;
            output[s] = [...output[s], ...output[fs2]];
          } else {
            failure[s] = 0;
          }
        }
      }
    }
    return {
      gotoFn,
      output,
      failure
    };
  }
  search(str) {
    let state = 0;
    const results = [];
    for (let i = 0; i < str.length; i++) {
      const l = str[i];
      while (state > 0 && !(l in this.gotoFn[state])) {
        state = this.failure[state];
      }
      if (!(l in this.gotoFn[state])) {
        continue;
      }
      state = this.gotoFn[state][l];
      if (this.output[state].length > 0) {
        const foundStrs = this.output[state];
        results.push([i, foundStrs]);
      }
    }
    return results;
  }
  match(str) {
    let state = 0;
    for (let i = 0; i < str.length; i++) {
      const l = str[i];
      while (state > 0 && !(l in this.gotoFn[state])) {
        state = this.failure[state];
      }
      if (!(l in this.gotoFn[state])) {
        continue;
      }
      state = this.gotoFn[state][l];
      if (this.output[state].length > 0) {
        return true;
      }
    }
    return false;
  }
};

// ../../node_modules/.pnpm/@vanilla-extract+css@1.17.2/node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.esm.js
var mockAdapter = {
  appendCss: () => {
  },
  registerClassName: () => {
  },
  onEndFileScope: () => {
  },
  registerComposition: () => {
  },
  markCompositionUsed: () => {
  },
  getIdentOption: () => process.env.NODE_ENV === "production" ? "short" : "debug"
};
var adapterStack = [mockAdapter];
var currentAdapter = () => {
  if (adapterStack.length < 1) {
    throw new Error("No adapter configured");
  }
  return adapterStack[adapterStack.length - 1];
};
var hasConfiguredAdapter = false;
var setAdapterIfNotSet = (newAdapter) => {
  if (!hasConfiguredAdapter) {
    setAdapter(newAdapter);
  }
};
var setAdapter = (newAdapter) => {
  if (!newAdapter) {
    throw new Error('No adapter provided when calling "setAdapter"');
  }
  hasConfiguredAdapter = true;
  adapterStack.push(newAdapter);
};
var markCompositionUsed = function markCompositionUsed2() {
  return currentAdapter().markCompositionUsed(...arguments);
};

// ../../node_modules/.pnpm/@vanilla-extract+css@1.17.2/node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-10998315.esm.js
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

// ../../node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/es/types.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

// ../../node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/es/parse.js
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
var unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse2(selector) {
  const subselects = [];
  const endIndex = parseSelector(subselects, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
  let tokens = [];
  function getName(offset) {
    const match = selector.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match;
    selectorIndex += offset + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop: while (selectorIndex < selector.length) {
    const firstChar = selector.charCodeAt(selectorIndex);
    switch (firstChar) {
      // Whitespace
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
          ensureNotTraversal();
          tokens.push({ type: SelectorType.Descendant });
        }
        stripWhitespace(1);
        break;
      }
      // Traversals
      case 62: {
        addTraversal(SelectorType.Child);
        stripWhitespace(1);
        break;
      }
      case 60: {
        addTraversal(SelectorType.Parent);
        stripWhitespace(1);
        break;
      }
      case 126: {
        addTraversal(SelectorType.Sibling);
        stripWhitespace(1);
        break;
      }
      case 43: {
        addTraversal(SelectorType.Adjacent);
        stripWhitespace(1);
        break;
      }
      // Special attribute selectors: .class, #id
      case 46: {
        addSpecialAttribute("class", AttributeAction.Element);
        break;
      }
      case 35: {
        addSpecialAttribute("id", AttributeAction.Equals);
        break;
      }
      case 91: {
        stripWhitespace(1);
        let name;
        let namespace = null;
        if (selector.charCodeAt(selectorIndex) === 124) {
          name = getName(1);
        } else if (selector.startsWith("*|", selectorIndex)) {
          namespace = "*";
          name = getName(2);
        } else {
          name = getName(0);
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
            namespace = name;
            name = getName(1);
          }
        }
        stripWhitespace(0);
        let action = AttributeAction.Exists;
        const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
        if (possibleAction) {
          action = possibleAction;
          if (selector.charCodeAt(selectorIndex + 1) !== 61) {
            throw new Error("Expected `=`");
          }
          stripWhitespace(2);
        } else if (selector.charCodeAt(selectorIndex) === 61) {
          action = AttributeAction.Equals;
          stripWhitespace(1);
        }
        let value = "";
        let ignoreCase = null;
        if (action !== "exists") {
          if (isQuote(selector.charCodeAt(selectorIndex))) {
            const quote = selector.charCodeAt(selectorIndex);
            let sectionEnd = selectorIndex + 1;
            while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
              sectionEnd += 1;
            }
            if (selector.charCodeAt(sectionEnd) !== quote) {
              throw new Error("Attribute value didn't end");
            }
            value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
            selectorIndex = sectionEnd + 1;
          } else {
            const valueStart = selectorIndex;
            while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
              selectorIndex += 1;
            }
            value = unescapeCSS(selector.slice(valueStart, selectorIndex));
          }
          stripWhitespace(0);
          const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
          if (forceIgnore === 115) {
            ignoreCase = false;
            stripWhitespace(1);
          } else if (forceIgnore === 105) {
            ignoreCase = true;
            stripWhitespace(1);
          }
        }
        if (selector.charCodeAt(selectorIndex) !== 93) {
          throw new Error("Attribute selector didn't terminate");
        }
        selectorIndex += 1;
        const attributeSelector = {
          type: SelectorType.Attribute,
          name,
          action,
          value,
          namespace,
          ignoreCase
        };
        tokens.push(attributeSelector);
        break;
      }
      case 58: {
        if (selector.charCodeAt(selectorIndex + 1) === 58) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name: getName(2).toLowerCase(),
            data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
          });
          continue;
        }
        const name = getName(1).toLowerCase();
        let data = null;
        if (selector.charCodeAt(selectorIndex) === 40) {
          if (unpackPseudos.has(name)) {
            if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
              throw new Error(`Pseudo-selector ${name} cannot be quoted`);
            }
            data = [];
            selectorIndex = parseSelector(data, selector, selectorIndex + 1);
            if (selector.charCodeAt(selectorIndex) !== 41) {
              throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
            }
            selectorIndex += 1;
          } else {
            data = readValueWithParenthesis();
            if (stripQuotesFromPseudos.has(name)) {
              const quot = data.charCodeAt(0);
              if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                data = data.slice(1, -1);
              }
            }
            data = unescapeCSS(data);
          }
        }
        tokens.push({ type: SelectorType.Pseudo, name, data });
        break;
      }
      case 44: {
        finalizeSubselector();
        tokens = [];
        stripWhitespace(1);
        break;
      }
      default: {
        if (selector.startsWith("/*", selectorIndex)) {
          const endIndex = selector.indexOf("*/", selectorIndex + 2);
          if (endIndex < 0) {
            throw new Error("Comment was not terminated");
          }
          selectorIndex = endIndex + 2;
          if (tokens.length === 0) {
            stripWhitespace(0);
          }
          break;
        }
        let namespace = null;
        let name;
        if (firstChar === 42) {
          selectorIndex += 1;
          name = "*";
        } else if (firstChar === 124) {
          name = "";
          if (selector.charCodeAt(selectorIndex + 1) === 124) {
            addTraversal(SelectorType.ColumnCombinator);
            stripWhitespace(2);
            break;
          }
        } else if (reName.test(selector.slice(selectorIndex))) {
          name = getName(0);
        } else {
          break loop;
        }
        if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
          namespace = name;
          if (selector.charCodeAt(selectorIndex + 1) === 42) {
            name = "*";
            selectorIndex += 2;
          } else {
            name = getName(1);
          }
        }
        tokens.push(name === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name, namespace });
      }
    }
  }
  finalizeSubselector();
  return selectorIndex;
}

// ../../node_modules/.pnpm/dedent@1.6.0/node_modules/dedent/dist/dedent.mjs
function ownKeys2(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var dedent = createDedent({});
var dedent_default = dedent;
function createDedent(options) {
  dedent2.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent2;
  function dedent2(strings, ...values) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const {
      escapeSpecialCharacters = Array.isArray(strings),
      trimWhitespace = true
    } = options;
    let result = "";
    for (let i = 0; i < raw.length; i++) {
      let next = raw[i];
      if (escapeSpecialCharacters) {
        next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
      }
      result += next;
      if (i < values.length) {
        result += values[i];
      }
    }
    const lines = result.split("\n");
    let mindent = null;
    for (const l of lines) {
      const m = l.match(/^(\s+)\S+/);
      if (m) {
        const indent = m[1].length;
        if (!mindent) {
          mindent = indent;
        } else {
          mindent = Math.min(mindent, indent);
        }
      }
    }
    if (mindent !== null) {
      const m = mindent;
      result = lines.map((l) => l[0] === " " || l[0] === "	" ? l.slice(m) : l).join("\n");
    }
    if (trimWhitespace) {
      result = result.trim();
    }
    if (escapeSpecialCharacters) {
      result = result.replace(/\\n/g, "\n");
    }
    return result;
  }
}

// ../../node_modules/.pnpm/media-query-parser@2.0.2/node_modules/media-query-parser/dist/media-query-parser.esm.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r2, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar2.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
}
var weirdNewlines = /(\u000D|\u000C|\u000D\u000A)/g;
var nullOrSurrogates = /[\u0000\uD800-\uDFFF]/g;
var commentRegex = /(\/\*)[\s\S]*?(\*\/)/g;
var lexicalAnalysis = function lexicalAnalysis2(str, index) {
  if (index === void 0) {
    index = 0;
  }
  str = str.replace(weirdNewlines, "\n").replace(nullOrSurrogates, "\uFFFD");
  str = str.replace(commentRegex, "");
  var tokens = [];
  for (; index < str.length; index += 1) {
    var code = str.charCodeAt(index);
    if (code === 9 || code === 32 || code === 10) {
      var code_1 = str.charCodeAt(++index);
      while (code_1 === 9 || code_1 === 32 || code_1 === 10) {
        code_1 = str.charCodeAt(++index);
      }
      index -= 1;
      tokens.push({
        type: "<whitespace-token>"
      });
    } else if (code === 34) {
      var result = consumeString(str, index);
      if (result === null) {
        return null;
      }
      var _a7 = __read(result, 2), lastIndex = _a7[0], value = _a7[1];
      tokens.push({
        type: "<string-token>",
        value
      });
      index = lastIndex;
    } else if (code === 35) {
      if (index + 1 < str.length) {
        var nextCode = str.charCodeAt(index + 1);
        if (nextCode === 95 || nextCode >= 65 && nextCode <= 90 || nextCode >= 97 && nextCode <= 122 || nextCode >= 128 || nextCode >= 48 && nextCode <= 57 || nextCode === 92 && index + 2 < str.length && str.charCodeAt(index + 2) !== 10) {
          var flag = wouldStartIdentifier(str, index + 1) ? "id" : "unrestricted";
          var result = consumeIdentUnsafe(str, index + 1);
          if (result !== null) {
            var _b3 = __read(result, 2), lastIndex = _b3[0], value = _b3[1];
            tokens.push({
              type: "<hash-token>",
              value: value.toLowerCase(),
              flag
            });
            index = lastIndex;
            continue;
          }
        }
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 39) {
      var result = consumeString(str, index);
      if (result === null) {
        return null;
      }
      var _c = __read(result, 2), lastIndex = _c[0], value = _c[1];
      tokens.push({
        type: "<string-token>",
        value
      });
      index = lastIndex;
    } else if (code === 40) {
      tokens.push({
        type: "<(-token>"
      });
    } else if (code === 41) {
      tokens.push({
        type: "<)-token>"
      });
    } else if (code === 43) {
      var plusNumeric = consumeNumeric(str, index);
      if (plusNumeric === null) {
        tokens.push({
          type: "<delim-token>",
          value: code
        });
      } else {
        var _d = __read(plusNumeric, 2), lastIndex = _d[0], tokenTuple = _d[1];
        if (tokenTuple[0] === "<dimension-token>") {
          tokens.push({
            type: "<dimension-token>",
            value: tokenTuple[1],
            unit: tokenTuple[2].toLowerCase(),
            flag: "number"
          });
        } else if (tokenTuple[0] === "<number-token>") {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: tokenTuple[2]
          });
        } else {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: "number"
          });
        }
        index = lastIndex;
      }
    } else if (code === 44) {
      tokens.push({
        type: "<comma-token>"
      });
    } else if (code === 45) {
      var minusNumeric = consumeNumeric(str, index);
      if (minusNumeric !== null) {
        var _e3 = __read(minusNumeric, 2), lastIndex = _e3[0], tokenTuple = _e3[1];
        if (tokenTuple[0] === "<dimension-token>") {
          tokens.push({
            type: "<dimension-token>",
            value: tokenTuple[1],
            unit: tokenTuple[2].toLowerCase(),
            flag: "number"
          });
        } else if (tokenTuple[0] === "<number-token>") {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: tokenTuple[2]
          });
        } else {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: "number"
          });
        }
        index = lastIndex;
        continue;
      }
      if (index + 2 < str.length) {
        var nextCode = str.charCodeAt(index + 1);
        var nextNextCode = str.charCodeAt(index + 2);
        if (nextCode === 45 && nextNextCode === 62) {
          tokens.push({
            type: "<CDC-token>"
          });
          index += 2;
          continue;
        }
      }
      var result = consumeIdentLike(str, index);
      if (result !== null) {
        var _f = __read(result, 3), lastIndex = _f[0], value = _f[1], type = _f[2];
        tokens.push({
          type,
          value
        });
        index = lastIndex;
        continue;
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 46) {
      var minusNumeric = consumeNumeric(str, index);
      if (minusNumeric === null) {
        tokens.push({
          type: "<delim-token>",
          value: code
        });
      } else {
        var _g = __read(minusNumeric, 2), lastIndex = _g[0], tokenTuple = _g[1];
        if (tokenTuple[0] === "<dimension-token>") {
          tokens.push({
            type: "<dimension-token>",
            value: tokenTuple[1],
            unit: tokenTuple[2].toLowerCase(),
            flag: "number"
          });
        } else if (tokenTuple[0] === "<number-token>") {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: tokenTuple[2]
          });
        } else {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: "number"
          });
        }
        index = lastIndex;
        continue;
      }
    } else if (code === 58) {
      tokens.push({
        type: "<colon-token>"
      });
    } else if (code === 59) {
      tokens.push({
        type: "<semicolon-token>"
      });
    } else if (code === 60) {
      if (index + 3 < str.length) {
        var nextCode = str.charCodeAt(index + 1);
        var nextNextCode = str.charCodeAt(index + 2);
        var nextNextNextCode = str.charCodeAt(index + 3);
        if (nextCode === 33 && nextNextCode === 45 && nextNextNextCode === 45) {
          tokens.push({
            type: "<CDO-token>"
          });
          index += 3;
          continue;
        }
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 64) {
      var result = consumeIdent(str, index + 1);
      if (result !== null) {
        var _h = __read(result, 2), lastIndex = _h[0], value = _h[1];
        tokens.push({
          type: "<at-keyword-token>",
          value: value.toLowerCase()
        });
        index = lastIndex;
        continue;
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 91) {
      tokens.push({
        type: "<[-token>"
      });
    } else if (code === 92) {
      var result = consumeEscape(str, index);
      if (result === null) {
        return null;
      }
      var _j = __read(result, 2), lastIndex = _j[0], value = _j[1];
      str = str.slice(0, index) + value + str.slice(lastIndex + 1);
      index -= 1;
    } else if (code === 93) {
      tokens.push({
        type: "<]-token>"
      });
    } else if (code === 123) {
      tokens.push({
        type: "<{-token>"
      });
    } else if (code === 125) {
      tokens.push({
        type: "<}-token>"
      });
    } else if (code >= 48 && code <= 57) {
      var result = consumeNumeric(str, index);
      var _k = __read(result, 2), lastIndex = _k[0], tokenTuple = _k[1];
      if (tokenTuple[0] === "<dimension-token>") {
        tokens.push({
          type: "<dimension-token>",
          value: tokenTuple[1],
          unit: tokenTuple[2].toLowerCase(),
          flag: "number"
        });
      } else if (tokenTuple[0] === "<number-token>") {
        tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: tokenTuple[2]
        });
      } else {
        tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: "number"
        });
      }
      index = lastIndex;
    } else if (code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128) {
      var result = consumeIdentLike(str, index);
      if (result === null) {
        return null;
      }
      var _l = __read(result, 3), lastIndex = _l[0], value = _l[1], type = _l[2];
      tokens.push({
        type,
        value
      });
      index = lastIndex;
    } else {
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    }
  }
  tokens.push({
    type: "<EOF-token>"
  });
  return tokens;
};
var consumeString = function consumeString2(str, index) {
  if (str.length <= index + 1) return null;
  var firstCode = str.charCodeAt(index);
  var charCodes = [];
  for (var i = index + 1; i < str.length; i += 1) {
    var code = str.charCodeAt(i);
    if (code === firstCode) {
      return [i, String.fromCharCode.apply(null, charCodes)];
    } else if (code === 92) {
      var result = consumeEscape(str, i);
      if (result === null) return null;
      var _a7 = __read(result, 2), lastIndex = _a7[0], charCode = _a7[1];
      charCodes.push(charCode);
      i = lastIndex;
    } else if (code === 10) {
      return null;
    } else {
      charCodes.push(code);
    }
  }
  return null;
};
var wouldStartIdentifier = function wouldStartIdentifier2(str, index) {
  if (str.length <= index) return false;
  var code = str.charCodeAt(index);
  if (code === 45) {
    if (str.length <= index + 1) return false;
    var nextCode = str.charCodeAt(index + 1);
    if (nextCode === 45 || nextCode === 95 || nextCode >= 65 && nextCode <= 90 || nextCode >= 97 && nextCode <= 122 || nextCode >= 128) {
      return true;
    } else if (nextCode === 92) {
      if (str.length <= index + 2) return false;
      var nextNextCode = str.charCodeAt(index + 2);
      return nextNextCode !== 10;
    } else {
      return false;
    }
  } else if (code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128) {
    return true;
  } else if (code === 92) {
    if (str.length <= index + 1) return false;
    var nextCode = str.charCodeAt(index + 1);
    return nextCode !== 10;
  } else {
    return false;
  }
};
var consumeEscape = function consumeEscape2(str, index) {
  if (str.length <= index + 1) return null;
  if (str.charCodeAt(index) !== 92) return null;
  var code = str.charCodeAt(index + 1);
  if (code === 10) {
    return null;
  } else if (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102) {
    var hexCharCodes = [code];
    var min3 = Math.min(index + 7, str.length);
    var i = index + 2;
    for (; i < min3; i += 1) {
      var code_2 = str.charCodeAt(i);
      if (code_2 >= 48 && code_2 <= 57 || code_2 >= 65 && code_2 <= 70 || code_2 >= 97 && code_2 <= 102) {
        hexCharCodes.push(code_2);
      } else {
        break;
      }
    }
    if (i < str.length) {
      var code_3 = str.charCodeAt(i);
      if (code_3 === 9 || code_3 === 32 || code_3 === 10) {
        i += 1;
      }
    }
    return [i - 1, parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)];
  } else {
    return [index + 1, code];
  }
};
var consumeNumeric = function consumeNumeric2(str, index) {
  var numberResult = consumeNumber(str, index);
  if (numberResult === null) return null;
  var _a7 = __read(numberResult, 3), numberEndIndex = _a7[0], numberValue = _a7[1], numberFlag = _a7[2];
  var identResult = consumeIdent(str, numberEndIndex + 1);
  if (identResult !== null) {
    var _b3 = __read(identResult, 2), identEndIndex = _b3[0], identValue = _b3[1];
    return [identEndIndex, ["<dimension-token>", numberValue, identValue]];
  }
  if (numberEndIndex + 1 < str.length && str.charCodeAt(numberEndIndex + 1) === 37) {
    return [numberEndIndex + 1, ["<percentage-token>", numberValue]];
  }
  return [numberEndIndex, ["<number-token>", numberValue, numberFlag]];
};
var consumeNumber = function consumeNumber2(str, index) {
  if (str.length <= index) return null;
  var flag = "integer";
  var numberChars = [];
  var firstCode = str.charCodeAt(index);
  if (firstCode === 43 || firstCode === 45) {
    index += 1;
    if (firstCode === 45) numberChars.push(45);
  }
  while (index < str.length) {
    var code = str.charCodeAt(index);
    if (code >= 48 && code <= 57) {
      numberChars.push(code);
      index += 1;
    } else {
      break;
    }
  }
  if (index + 1 < str.length) {
    var nextCode = str.charCodeAt(index);
    var nextNextCode = str.charCodeAt(index + 1);
    if (nextCode === 46 && nextNextCode >= 48 && nextNextCode <= 57) {
      numberChars.push(nextCode, nextNextCode);
      flag = "number";
      index += 2;
      while (index < str.length) {
        var code = str.charCodeAt(index);
        if (code >= 48 && code <= 57) {
          numberChars.push(code);
          index += 1;
        } else {
          break;
        }
      }
    }
  }
  if (index + 1 < str.length) {
    var nextCode = str.charCodeAt(index);
    var nextNextCode = str.charCodeAt(index + 1);
    var nextNextNextCode = str.charCodeAt(index + 2);
    if (nextCode === 69 || nextCode === 101) {
      var nextNextIsDigit = nextNextCode >= 48 && nextNextCode <= 57;
      if (nextNextIsDigit || (nextNextCode === 43 || nextNextCode === 45) && nextNextNextCode >= 48 && nextNextNextCode <= 57) {
        flag = "number";
        if (nextNextIsDigit) {
          numberChars.push(69, nextNextCode);
          index += 2;
        } else if (nextNextCode === 45) {
          numberChars.push(69, 45, nextNextNextCode);
          index += 3;
        } else {
          numberChars.push(69, nextNextNextCode);
          index += 3;
        }
        while (index < str.length) {
          var code = str.charCodeAt(index);
          if (code >= 48 && code <= 57) {
            numberChars.push(code);
            index += 1;
          } else {
            break;
          }
        }
      }
    }
  }
  var numberString = String.fromCharCode.apply(null, numberChars);
  var value = flag === "number" ? parseFloat(numberString) : parseInt(numberString);
  if (value === -0) value = 0;
  return Number.isNaN(value) ? null : [index - 1, value, flag];
};
var consumeIdentUnsafe = function consumeIdentUnsafe2(str, index) {
  if (str.length <= index) {
    return null;
  }
  var identChars = [];
  for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {
    if (code === 45 || code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128 || code >= 48 && code <= 57) {
      identChars.push(code);
      continue;
    } else {
      var result = consumeEscape(str, index);
      if (result !== null) {
        var _a7 = __read(result, 2), lastIndex = _a7[0], code_4 = _a7[1];
        identChars.push(code_4);
        index = lastIndex;
        continue;
      }
    }
    break;
  }
  return index === 0 ? null : [index - 1, String.fromCharCode.apply(null, identChars)];
};
var consumeIdent = function consumeIdent2(str, index) {
  if (str.length <= index || !wouldStartIdentifier(str, index)) {
    return null;
  }
  var identChars = [];
  for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {
    if (code === 45 || code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128 || code >= 48 && code <= 57) {
      identChars.push(code);
      continue;
    } else {
      var result = consumeEscape(str, index);
      if (result !== null) {
        var _a7 = __read(result, 2), lastIndex = _a7[0], code_5 = _a7[1];
        identChars.push(code_5);
        index = lastIndex;
        continue;
      }
    }
    break;
  }
  return [index - 1, String.fromCharCode.apply(null, identChars)];
};
var consumeUrl = function consumeUrl2(str, index) {
  var code = str.charCodeAt(index);
  while (code === 9 || code === 32 || code === 10) {
    code = str.charCodeAt(++index);
  }
  var urlChars = [];
  var hasFinishedWord = false;
  while (index < str.length) {
    if (code === 41) {
      return [index, String.fromCharCode.apply(null, urlChars)];
    } else if (code === 34 || code === 39 || code === 40) {
      return null;
    } else if (code === 9 || code === 32 || code === 10) {
      if (!hasFinishedWord && urlChars.length !== 0) hasFinishedWord = true;
    } else if (code === 92) {
      var result = consumeEscape(str, index);
      if (result === null || hasFinishedWord) return null;
      var _a7 = __read(result, 2), lastIndex = _a7[0], value = _a7[1];
      urlChars.push(value);
      index = lastIndex;
    } else {
      if (hasFinishedWord) return null;
      urlChars.push(code);
    }
    code = str.charCodeAt(++index);
  }
  return null;
};
var consumeIdentLike = function consumeIdentLike2(str, index) {
  var result = consumeIdent(str, index);
  if (result === null) return null;
  var _a7 = __read(result, 2), lastIndex = _a7[0], value = _a7[1];
  if (value.toLowerCase() === "url") {
    if (str.length > lastIndex + 1) {
      var nextCode = str.charCodeAt(lastIndex + 1);
      if (nextCode === 40) {
        for (var offset = 2; lastIndex + offset < str.length; offset += 1) {
          var nextNextCode = str.charCodeAt(lastIndex + offset);
          if (nextNextCode === 34 || nextNextCode === 39) {
            return [lastIndex + 1, value.toLowerCase(), "<function-token>"];
          } else if (nextNextCode !== 9 && nextNextCode !== 32 && nextNextCode !== 10) {
            var result_1 = consumeUrl(str, lastIndex + offset);
            if (result_1 === null) return null;
            var _b3 = __read(result_1, 2), lastUrlIndex = _b3[0], value_1 = _b3[1];
            return [lastUrlIndex, value_1, "<url-token>"];
          }
        }
        return [lastIndex + 1, value.toLowerCase(), "<function-token>"];
      }
    }
  } else if (str.length > lastIndex + 1) {
    var nextCode = str.charCodeAt(lastIndex + 1);
    if (nextCode === 40) {
      return [lastIndex + 1, value.toLowerCase(), "<function-token>"];
    }
  }
  return [lastIndex, value.toLowerCase(), "<ident-token>"];
};
var simplifyAST = function simplifyAST2(ast) {
  for (var i = ast.length - 1; i >= 0; i--) {
    ast[i] = simplifyMediaQuery(ast[i]);
  }
  return ast;
};
var simplifyMediaQuery = function simplifyMediaQuery2(mediaQuery) {
  if (mediaQuery.mediaCondition === null) return mediaQuery;
  var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);
  if (mediaCondition.operator === null && mediaCondition.children.length === 1 && "children" in mediaCondition.children[0]) {
    mediaCondition = mediaCondition.children[0];
  }
  return {
    mediaPrefix: mediaQuery.mediaPrefix,
    mediaType: mediaQuery.mediaType,
    mediaCondition
  };
};
var simplifyMediaCondition = function simplifyMediaCondition2(mediaCondition) {
  for (var i = mediaCondition.children.length - 1; i >= 0; i--) {
    var unsimplifiedChild = mediaCondition.children[i];
    if (!("context" in unsimplifiedChild)) {
      var child = simplifyMediaCondition2(unsimplifiedChild);
      if (child.operator === null && child.children.length === 1) {
        mediaCondition.children[i] = child.children[0];
      } else if (child.operator === mediaCondition.operator && (child.operator === "and" || child.operator === "or")) {
        var spliceArgs = [i, 1];
        for (var i_1 = 0; i_1 < child.children.length; i_1++) {
          spliceArgs.push(child.children[i_1]);
        }
        mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);
      }
    }
  }
  return mediaCondition;
};
var createError = function createError2(message, err) {
  if (err instanceof Error) {
    return new Error("".concat(err.message.trim(), "\n").concat(message.trim()));
  } else {
    return new Error(message.trim());
  }
};
var toAST = function toAST2(str) {
  return simplifyAST(toUnflattenedAST(str));
};
var toUnflattenedAST = function toUnflattenedAST2(str) {
  var tokenList = lexicalAnalysis(str.trim());
  if (tokenList === null) {
    throw createError("Failed tokenizing");
  }
  var startIndex = 0;
  var endIndex = tokenList.length - 1;
  if (tokenList[0].type === "<at-keyword-token>" && tokenList[0].value === "media") {
    if (tokenList[1].type !== "<whitespace-token>") {
      throw createError("Expected whitespace after media");
    }
    startIndex = 2;
    for (var i = 2; i < tokenList.length - 1; i++) {
      var token = tokenList[i];
      if (token.type === "<{-token>") {
        endIndex = i;
        break;
      } else if (token.type === "<semicolon-token>") {
        throw createError("Expected '{' in media query but found ';'");
      }
    }
  }
  tokenList = tokenList.slice(startIndex, endIndex);
  return syntacticAnalysis(tokenList);
};
var removeWhitespace = function removeWhitespace2(tokenList) {
  var newTokenList = [];
  var before = false;
  for (var i = 0; i < tokenList.length; i++) {
    if (tokenList[i].type === "<whitespace-token>") {
      before = true;
      if (newTokenList.length > 0) {
        newTokenList[newTokenList.length - 1].wsAfter = true;
      }
    } else {
      newTokenList.push(__assign(__assign({}, tokenList[i]), {
        wsBefore: before,
        wsAfter: false
      }));
      before = false;
    }
  }
  return newTokenList;
};
var syntacticAnalysis = function syntacticAnalysis2(tokenList) {
  var e_1, _a7;
  var mediaQueryList = [[]];
  for (var i = 0; i < tokenList.length; i++) {
    var token = tokenList[i];
    if (token.type === "<comma-token>") {
      mediaQueryList.push([]);
    } else {
      mediaQueryList[mediaQueryList.length - 1].push(token);
    }
  }
  var mediaQueries = mediaQueryList.map(removeWhitespace);
  if (mediaQueries.length === 1 && mediaQueries[0].length === 0) {
    return [{
      mediaCondition: null,
      mediaPrefix: null,
      mediaType: "all"
    }];
  } else {
    var mediaQueryTokens = mediaQueries.map(function(mediaQueryTokens2) {
      if (mediaQueryTokens2.length === 0) {
        return null;
      } else {
        return tokenizeMediaQuery(mediaQueryTokens2);
      }
    });
    var nonNullMediaQueryTokens = [];
    try {
      for (var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()) {
        var mediaQueryToken = mediaQueryTokens_1_1.value;
        if (mediaQueryToken !== null) {
          nonNullMediaQueryTokens.push(mediaQueryToken);
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a7 = mediaQueryTokens_1["return"])) _a7.call(mediaQueryTokens_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (nonNullMediaQueryTokens.length === 0) {
      throw createError("No valid media queries");
    }
    return nonNullMediaQueryTokens;
  }
};
var tokenizeMediaQuery = function tokenizeMediaQuery2(tokens) {
  var firstToken = tokens[0];
  if (firstToken.type === "<(-token>") {
    try {
      return {
        mediaPrefix: null,
        mediaType: "all",
        mediaCondition: tokenizeMediaCondition(tokens, true)
      };
    } catch (err) {
      throw createError("Expected media condition after '('", err);
    }
  } else if (firstToken.type === "<ident-token>") {
    var mediaPrefix = null;
    var mediaType = void 0;
    var value = firstToken.value;
    if (value === "only" || value === "not") {
      mediaPrefix = value;
    }
    var firstIndex = mediaPrefix === null ? 0 : 1;
    if (tokens.length <= firstIndex) {
      throw createError("Expected extra token in media query");
    }
    var firstNonUnaryToken = tokens[firstIndex];
    if (firstNonUnaryToken.type === "<ident-token>") {
      var value_1 = firstNonUnaryToken.value;
      if (value_1 === "all") {
        mediaType = "all";
      } else if (value_1 === "print" || value_1 === "screen") {
        mediaType = value_1;
      } else if (value_1 === "tty" || value_1 === "tv" || value_1 === "projection" || value_1 === "handheld" || value_1 === "braille" || value_1 === "embossed" || value_1 === "aural" || value_1 === "speech") {
        mediaPrefix = mediaPrefix === "not" ? null : "not";
        mediaType = "all";
      } else {
        throw createError("Unknown ident '".concat(value_1, "' in media query"));
      }
    } else if (mediaPrefix === "not" && firstNonUnaryToken.type === "<(-token>") {
      var tokensWithParens = [{
        type: "<(-token>",
        wsBefore: false,
        wsAfter: false
      }];
      tokensWithParens.push.apply(tokensWithParens, tokens);
      tokensWithParens.push({
        type: "<)-token>",
        wsBefore: false,
        wsAfter: false
      });
      try {
        return {
          mediaPrefix: null,
          mediaType: "all",
          mediaCondition: tokenizeMediaCondition(tokensWithParens, true)
        };
      } catch (err) {
        throw createError("Expected media condition after '('", err);
      }
    } else {
      throw createError("Invalid media query");
    }
    if (firstIndex + 1 === tokens.length) {
      return {
        mediaPrefix,
        mediaType,
        mediaCondition: null
      };
    } else if (firstIndex + 4 < tokens.length) {
      var secondNonUnaryToken = tokens[firstIndex + 1];
      if (secondNonUnaryToken.type === "<ident-token>" && secondNonUnaryToken.value === "and") {
        try {
          return {
            mediaPrefix,
            mediaType,
            mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), false)
          };
        } catch (err) {
          throw createError("Expected media condition after 'and'", err);
        }
      } else {
        throw createError("Expected 'and' after media prefix");
      }
    } else {
      throw createError("Expected media condition after media prefix");
    }
  } else {
    throw createError("Expected media condition or media prefix");
  }
};
var tokenizeMediaCondition = function tokenizeMediaCondition2(tokens, mayContainOr, previousOperator) {
  if (previousOperator === void 0) {
    previousOperator = null;
  }
  if (tokens.length < 3 || tokens[0].type !== "<(-token>" || tokens[tokens.length - 1].type !== "<)-token>") {
    throw new Error("Invalid media condition");
  }
  var endIndexOfFirstFeature = tokens.length - 1;
  var maxDepth = 0;
  var count = 0;
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (token.type === "<(-token>") {
      count += 1;
      maxDepth = Math.max(maxDepth, count);
    } else if (token.type === "<)-token>") {
      count -= 1;
    }
    if (count === 0) {
      endIndexOfFirstFeature = i;
      break;
    }
  }
  if (count !== 0) {
    throw new Error("Mismatched parens\nInvalid media condition");
  }
  var child;
  var featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);
  if (maxDepth === 1) {
    child = tokenizeMediaFeature(featureTokens);
  } else {
    if (featureTokens[1].type === "<ident-token>" && featureTokens[1].value === "not") {
      child = tokenizeMediaCondition2(featureTokens.slice(2, -1), true, "not");
    } else {
      child = tokenizeMediaCondition2(featureTokens.slice(1, -1), true);
    }
  }
  if (endIndexOfFirstFeature === tokens.length - 1) {
    return {
      operator: previousOperator,
      children: [child]
    };
  } else {
    var nextToken = tokens[endIndexOfFirstFeature + 1];
    if (nextToken.type !== "<ident-token>") {
      throw new Error("Invalid operator\nInvalid media condition");
    } else if (previousOperator !== null && previousOperator !== nextToken.value) {
      throw new Error("'".concat(nextToken.value, "' and '").concat(previousOperator, "' must not be at same level\nInvalid media condition"));
    } else if (nextToken.value === "or" && !mayContainOr) {
      throw new Error("Cannot use 'or' at top level of a media query\nInvalid media condition");
    } else if (nextToken.value !== "and" && nextToken.value !== "or") {
      throw new Error("Invalid operator: '".concat(nextToken.value, "'\nInvalid media condition"));
    }
    var siblings = tokenizeMediaCondition2(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);
    return {
      operator: nextToken.value,
      children: [child].concat(siblings.children)
    };
  }
};
var tokenizeMediaFeature = function tokenizeMediaFeature2(rawTokens) {
  if (rawTokens.length < 3 || rawTokens[0].type !== "<(-token>" || rawTokens[rawTokens.length - 1].type !== "<)-token>") {
    throw new Error("Invalid media feature");
  }
  var tokens = [rawTokens[0]];
  for (var i = 1; i < rawTokens.length; i++) {
    if (i < rawTokens.length - 2) {
      var a = rawTokens[i];
      var b2 = rawTokens[i + 1];
      var c = rawTokens[i + 2];
      if (a.type === "<number-token>" && a.value > 0 && b2.type === "<delim-token>" && b2.value === 47 && c.type === "<number-token>" && c.value > 0) {
        tokens.push({
          type: "<ratio-token>",
          numerator: a.value,
          denominator: c.value,
          wsBefore: a.wsBefore,
          wsAfter: c.wsAfter
        });
        i += 2;
        continue;
      }
    }
    tokens.push(rawTokens[i]);
  }
  var nextToken = tokens[1];
  if (nextToken.type === "<ident-token>" && tokens.length === 3) {
    return {
      context: "boolean",
      feature: nextToken.value
    };
  } else if (tokens.length === 5 && tokens[1].type === "<ident-token>" && tokens[2].type === "<colon-token>") {
    var valueToken = tokens[3];
    if (valueToken.type === "<number-token>" || valueToken.type === "<dimension-token>" || valueToken.type === "<ratio-token>" || valueToken.type === "<ident-token>") {
      var feature = tokens[1].value;
      var prefix = null;
      var slice = feature.slice(0, 4);
      if (slice === "min-") {
        prefix = "min";
        feature = feature.slice(4);
      } else if (slice === "max-") {
        prefix = "max";
        feature = feature.slice(4);
      }
      valueToken.wsBefore;
      valueToken.wsAfter;
      var value = __rest(valueToken, ["wsBefore", "wsAfter"]);
      return {
        context: "value",
        prefix,
        feature,
        value
      };
    }
  } else if (tokens.length >= 5) {
    try {
      var range = tokenizeRange(tokens);
      return {
        context: "range",
        feature: range.featureName,
        range
      };
    } catch (err) {
      throw createError("Invalid media feature", err);
    }
  }
  throw new Error("Invalid media feature");
};
var tokenizeRange = function tokenizeRange2(tokens) {
  var _a7, _b3, _c, _d;
  if (tokens.length < 5 || tokens[0].type !== "<(-token>" || tokens[tokens.length - 1].type !== "<)-token>") {
    throw new Error("Invalid range");
  }
  var range = {
    leftToken: null,
    leftOp: null,
    featureName: "",
    rightOp: null,
    rightToken: null
  };
  var hasLeft = tokens[1].type === "<number-token>" || tokens[1].type === "<dimension-token>" || tokens[1].type === "<ratio-token>" || tokens[1].type === "<ident-token>" && tokens[1].value === "infinite";
  if (tokens[2].type === "<delim-token>") {
    if (tokens[2].value === 60) {
      if (tokens[3].type === "<delim-token>" && tokens[3].value === 61 && !tokens[3].wsBefore) {
        range[hasLeft ? "leftOp" : "rightOp"] = "<=";
      } else {
        range[hasLeft ? "leftOp" : "rightOp"] = "<";
      }
    } else if (tokens[2].value === 62) {
      if (tokens[3].type === "<delim-token>" && tokens[3].value === 61 && !tokens[3].wsBefore) {
        range[hasLeft ? "leftOp" : "rightOp"] = ">=";
      } else {
        range[hasLeft ? "leftOp" : "rightOp"] = ">";
      }
    } else if (tokens[2].value === 61) {
      range[hasLeft ? "leftOp" : "rightOp"] = "=";
    } else {
      throw new Error("Invalid range");
    }
    if (hasLeft) {
      range.leftToken = tokens[1];
    } else if (tokens[1].type === "<ident-token>") {
      range.featureName = tokens[1].value;
    } else {
      throw new Error("Invalid range");
    }
    var tokenIndexAfterFirstOp = 2 + ((_b3 = (_a7 = range[hasLeft ? "leftOp" : "rightOp"]) === null || _a7 === void 0 ? void 0 : _a7.length) !== null && _b3 !== void 0 ? _b3 : 0);
    var tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];
    if (hasLeft) {
      if (tokenAfterFirstOp.type === "<ident-token>") {
        range.featureName = tokenAfterFirstOp.value;
        if (tokens.length >= 7) {
          var secondOpToken = tokens[tokenIndexAfterFirstOp + 1];
          var followingToken = tokens[tokenIndexAfterFirstOp + 2];
          if (secondOpToken.type === "<delim-token>") {
            var charCode = secondOpToken.value;
            if (charCode === 60) {
              if (followingToken.type === "<delim-token>" && followingToken.value === 61 && !followingToken.wsBefore) {
                range.rightOp = "<=";
              } else {
                range.rightOp = "<";
              }
            } else if (charCode === 62) {
              if (followingToken.type === "<delim-token>" && followingToken.value === 61 && !followingToken.wsBefore) {
                range.rightOp = ">=";
              } else {
                range.rightOp = ">";
              }
            } else {
              throw new Error("Invalid range");
            }
            var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];
            range.rightToken = tokenAfterSecondOp;
          } else {
            throw new Error("Invalid range");
          }
        } else if (tokenIndexAfterFirstOp + 2 !== tokens.length) {
          throw new Error("Invalid range");
        }
      } else {
        throw new Error("Invalid range");
      }
    } else {
      range.rightToken = tokenAfterFirstOp;
    }
    var validRange = null;
    var lt2 = range.leftToken, leftOp = range.leftOp, featureName = range.featureName, rightOp = range.rightOp, rt3 = range.rightToken;
    var leftToken = null;
    if (lt2 !== null) {
      if (lt2.type === "<ident-token>") {
        var type = lt2.type, value = lt2.value;
        if (value === "infinite") {
          leftToken = {
            type,
            value
          };
        }
      } else if (lt2.type === "<number-token>" || lt2.type === "<dimension-token>" || lt2.type === "<ratio-token>") {
        lt2.wsBefore;
        lt2.wsAfter;
        var ltNoWS = __rest(lt2, ["wsBefore", "wsAfter"]);
        leftToken = ltNoWS;
      }
    }
    var rightToken = null;
    if (rt3 !== null) {
      if (rt3.type === "<ident-token>") {
        var type = rt3.type, value = rt3.value;
        if (value === "infinite") {
          rightToken = {
            type,
            value
          };
        }
      } else if (rt3.type === "<number-token>" || rt3.type === "<dimension-token>" || rt3.type === "<ratio-token>") {
        rt3.wsBefore;
        rt3.wsAfter;
        var rtNoWS = __rest(rt3, ["wsBefore", "wsAfter"]);
        rightToken = rtNoWS;
      }
    }
    if (leftToken !== null && rightToken !== null) {
      if ((leftOp === "<" || leftOp === "<=") && (rightOp === "<" || rightOp === "<=")) {
        validRange = {
          leftToken,
          leftOp,
          featureName,
          rightOp,
          rightToken
        };
      } else if ((leftOp === ">" || leftOp === ">=") && (rightOp === ">" || rightOp === ">=")) {
        validRange = {
          leftToken,
          leftOp,
          featureName,
          rightOp,
          rightToken
        };
      } else {
        throw new Error("Invalid range");
      }
    } else if (leftToken === null && leftOp === null && rightOp !== null && rightToken !== null) {
      validRange = {
        leftToken,
        leftOp,
        featureName,
        rightOp,
        rightToken
      };
    } else if (leftToken !== null && leftOp !== null && rightOp === null && rightToken === null) {
      validRange = {
        leftToken,
        leftOp,
        featureName,
        rightOp,
        rightToken
      };
    }
    return validRange;
  } else {
    throw new Error("Invalid range");
  }
};

// ../../node_modules/.pnpm/@vanilla-extract+css@1.17.2/node_modules/@vanilla-extract/css/dist/transformCss-0dba36bf.esm.js
function toPrimitive2(t, r2) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}
function toPropertyKey2(t) {
  var i = toPrimitive2(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperty3(obj, key, value) {
  key = toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys3(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread22(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys3(Object(t), true).forEach(function(r3) {
      _defineProperty3(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function forEach(obj, fn3) {
  for (var _key in obj) {
    fn3(obj[_key], _key);
  }
}
function omit(obj, omitKeys) {
  var result = {};
  for (var _key2 in obj) {
    if (omitKeys.indexOf(_key2) === -1) {
      result[_key2] = obj[_key2];
    }
  }
  return result;
}
function mapKeys(obj, fn3) {
  var result = {};
  for (var _key3 in obj) {
    result[fn3(obj[_key3], _key3)] = obj[_key3];
  }
  return result;
}
var _templateObject$1;
function escapeRegex(string2) {
  return string2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var validateSelector = (selector, targetClassName) => {
  var replaceTarget = () => {
    var targetRegex = new RegExp(".".concat(escapeRegex((0, import_cssesc.default)(targetClassName, {
      isIdentifier: true
    }))), "g");
    return selector.replace(targetRegex, "&");
  };
  var selectorParts;
  try {
    selectorParts = parse2(selector);
  } catch (err) {
    throw new Error("Invalid selector: ".concat(replaceTarget()));
  }
  selectorParts.forEach((tokens) => {
    try {
      for (var i = tokens.length - 1; i >= -1; i--) {
        if (!tokens[i]) {
          throw new Error();
        }
        var token = tokens[i];
        if (token.type === "child" || token.type === "parent" || token.type === "sibling" || token.type === "adjacent" || token.type === "descendant") {
          throw new Error();
        }
        if (token.type === "attribute" && token.name === "class" && token.value === targetClassName) {
          return;
        }
      }
    } catch (err) {
      throw new Error(dedent_default(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["\n        Invalid selector: ", "\n    \n        Style selectors must target the '&' character (along with any modifiers), e.g. ", " or ", ".\n        \n        This is to ensure that each style block only affects the styling of a single class.\n        \n        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of ", ") to 'parent', you should add ", " to 'child').\n        \n        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write ", ", you should instead write 'globalStyle(", ", { ... })'\n      "])), replaceTarget(), "`${parent} &`", "`${parent} &:hover`", "`& ${child}`", "`${parent} &`", "`& h1`", "`${parent} h1`"));
    }
  });
};
var ConditionalRuleset = class _ConditionalRuleset {
  /**
   * Stores information about where conditions must be in relation to other conditions
   *
   * e.g. mobile -> tablet, desktop
   */
  constructor() {
    this.ruleset = /* @__PURE__ */ new Map();
    this.precedenceLookup = /* @__PURE__ */ new Map();
  }
  findOrCreateCondition(conditionQuery) {
    var targetCondition = this.ruleset.get(conditionQuery);
    if (!targetCondition) {
      targetCondition = {
        query: conditionQuery,
        rules: [],
        children: new _ConditionalRuleset()
      };
      this.ruleset.set(conditionQuery, targetCondition);
    }
    return targetCondition;
  }
  getConditionalRulesetByPath(conditionPath) {
    var currRuleset = this;
    for (var query of conditionPath) {
      var condition = currRuleset.findOrCreateCondition(query);
      currRuleset = condition.children;
    }
    return currRuleset;
  }
  addRule(rule, conditionQuery, conditionPath) {
    var ruleset = this.getConditionalRulesetByPath(conditionPath);
    var targetCondition = ruleset.findOrCreateCondition(conditionQuery);
    if (!targetCondition) {
      throw new Error("Failed to add conditional rule");
    }
    targetCondition.rules.push(rule);
  }
  addConditionPrecedence(conditionPath, conditionOrder) {
    var ruleset = this.getConditionalRulesetByPath(conditionPath);
    for (var i = 0; i < conditionOrder.length; i++) {
      var _ruleset$precedenceLo;
      var query = conditionOrder[i];
      var conditionPrecedence = (_ruleset$precedenceLo = ruleset.precedenceLookup.get(query)) !== null && _ruleset$precedenceLo !== void 0 ? _ruleset$precedenceLo : /* @__PURE__ */ new Set();
      for (var lowerPrecedenceCondition of conditionOrder.slice(i + 1)) {
        conditionPrecedence.add(lowerPrecedenceCondition);
      }
      ruleset.precedenceLookup.set(query, conditionPrecedence);
    }
  }
  isCompatible(incomingRuleset) {
    for (var [condition, orderPrecedence] of this.precedenceLookup.entries()) {
      for (var lowerPrecedenceCondition of orderPrecedence) {
        var _incomingRuleset$prec;
        if ((_incomingRuleset$prec = incomingRuleset.precedenceLookup.get(lowerPrecedenceCondition)) !== null && _incomingRuleset$prec !== void 0 && _incomingRuleset$prec.has(condition)) {
          return false;
        }
      }
    }
    for (var {
      query,
      children
    } of incomingRuleset.ruleset.values()) {
      var matchingCondition = this.ruleset.get(query);
      if (matchingCondition && !matchingCondition.children.isCompatible(children)) {
        return false;
      }
    }
    return true;
  }
  merge(incomingRuleset) {
    for (var {
      query,
      rules,
      children
    } of incomingRuleset.ruleset.values()) {
      var matchingCondition = this.ruleset.get(query);
      if (matchingCondition) {
        matchingCondition.rules.push(...rules);
        matchingCondition.children.merge(children);
      } else {
        this.ruleset.set(query, {
          query,
          rules,
          children
        });
      }
    }
    for (var [condition, incomingOrderPrecedence] of incomingRuleset.precedenceLookup.entries()) {
      var _this$precedenceLooku;
      var orderPrecedence = (_this$precedenceLooku = this.precedenceLookup.get(condition)) !== null && _this$precedenceLooku !== void 0 ? _this$precedenceLooku : /* @__PURE__ */ new Set();
      this.precedenceLookup.set(condition, /* @__PURE__ */ new Set([...orderPrecedence, ...incomingOrderPrecedence]));
    }
  }
  /**
   * Merge another ConditionalRuleset into this one if they are compatible
   *
   * @returns true if successful, false if the ruleset is incompatible
   */
  mergeIfCompatible(incomingRuleset) {
    if (!this.isCompatible(incomingRuleset)) {
      return false;
    }
    this.merge(incomingRuleset);
    return true;
  }
  getSortedRuleset() {
    var _this = this;
    var sortedRuleset = [];
    var _loop = function _loop2(dependents2) {
      var conditionForQuery = _this.ruleset.get(query);
      if (!conditionForQuery) {
        throw new Error("Can't find condition for ".concat(query));
      }
      var firstMatchingDependent = sortedRuleset.findIndex((condition) => dependents2.has(condition.query));
      if (firstMatchingDependent > -1) {
        sortedRuleset.splice(firstMatchingDependent, 0, conditionForQuery);
      } else {
        sortedRuleset.push(conditionForQuery);
      }
    };
    for (var [query, dependents] of this.precedenceLookup.entries()) {
      _loop(dependents);
    }
    return sortedRuleset;
  }
  renderToArray() {
    var arr = [];
    for (var {
      query,
      rules,
      children
    } of this.getSortedRuleset()) {
      var selectors = {};
      for (var rule of rules) {
        selectors[rule.selector] = _objectSpread22(_objectSpread22({}, selectors[rule.selector]), rule.rule);
      }
      Object.assign(selectors, ...children.renderToArray());
      arr.push({
        [query]: selectors
      });
    }
    return arr;
  }
};
var simplePseudoMap = {
  ":-moz-any-link": true,
  ":-moz-full-screen": true,
  ":-moz-placeholder": true,
  ":-moz-read-only": true,
  ":-moz-read-write": true,
  ":-ms-fullscreen": true,
  ":-ms-input-placeholder": true,
  ":-webkit-any-link": true,
  ":-webkit-full-screen": true,
  "::-moz-color-swatch": true,
  "::-moz-list-bullet": true,
  "::-moz-list-number": true,
  "::-moz-page-sequence": true,
  "::-moz-page": true,
  "::-moz-placeholder": true,
  "::-moz-progress-bar": true,
  "::-moz-range-progress": true,
  "::-moz-range-thumb": true,
  "::-moz-range-track": true,
  "::-moz-scrolled-page-sequence": true,
  "::-moz-selection": true,
  "::-ms-backdrop": true,
  "::-ms-browse": true,
  "::-ms-check": true,
  "::-ms-clear": true,
  "::-ms-fill-lower": true,
  "::-ms-fill-upper": true,
  "::-ms-fill": true,
  "::-ms-reveal": true,
  "::-ms-thumb": true,
  "::-ms-ticks-after": true,
  "::-ms-ticks-before": true,
  "::-ms-tooltip": true,
  "::-ms-track": true,
  "::-ms-value": true,
  "::-webkit-backdrop": true,
  "::-webkit-calendar-picker-indicator": true,
  "::-webkit-inner-spin-button": true,
  "::-webkit-input-placeholder": true,
  "::-webkit-meter-bar": true,
  "::-webkit-meter-even-less-good-value": true,
  "::-webkit-meter-inner-element": true,
  "::-webkit-meter-optimum-value": true,
  "::-webkit-meter-suboptimum-value": true,
  "::-webkit-outer-spin-button": true,
  "::-webkit-progress-bar": true,
  "::-webkit-progress-inner-element": true,
  "::-webkit-progress-inner-value": true,
  "::-webkit-progress-value": true,
  "::-webkit-resizer": true,
  "::-webkit-scrollbar-button": true,
  "::-webkit-scrollbar-corner": true,
  "::-webkit-scrollbar-thumb": true,
  "::-webkit-scrollbar-track-piece": true,
  "::-webkit-scrollbar-track": true,
  "::-webkit-scrollbar": true,
  "::-webkit-search-cancel-button": true,
  "::-webkit-search-results-button": true,
  "::-webkit-slider-runnable-track": true,
  "::-webkit-slider-thumb": true,
  "::after": true,
  "::backdrop": true,
  "::before": true,
  "::cue": true,
  "::file-selector-button": true,
  "::first-letter": true,
  "::first-line": true,
  "::grammar-error": true,
  "::marker": true,
  "::placeholder": true,
  "::selection": true,
  "::spelling-error": true,
  "::target-text": true,
  "::view-transition-group": true,
  "::view-transition-image-pair": true,
  "::view-transition-new": true,
  "::view-transition-old": true,
  "::view-transition": true,
  ":active": true,
  ":after": true,
  ":any-link": true,
  ":before": true,
  ":blank": true,
  ":checked": true,
  ":default": true,
  ":defined": true,
  ":disabled": true,
  ":empty": true,
  ":enabled": true,
  ":first-child": true,
  ":first-letter": true,
  ":first-line": true,
  ":first-of-type": true,
  ":first": true,
  ":focus-visible": true,
  ":focus-within": true,
  ":focus": true,
  ":fullscreen": true,
  ":hover": true,
  ":in-range": true,
  ":indeterminate": true,
  ":invalid": true,
  ":last-child": true,
  ":last-of-type": true,
  ":left": true,
  ":link": true,
  ":only-child": true,
  ":only-of-type": true,
  ":optional": true,
  ":out-of-range": true,
  ":placeholder-shown": true,
  ":read-only": true,
  ":read-write": true,
  ":required": true,
  ":right": true,
  ":root": true,
  ":scope": true,
  ":target": true,
  ":valid": true,
  ":visited": true
};
var simplePseudos = Object.keys(simplePseudoMap);
var simplePseudoLookup = simplePseudoMap;
var _templateObject;
var createMediaQueryError = (mediaQuery, msg) => new Error(dedent_default(_templateObject || (_templateObject = _taggedTemplateLiteral(['\n    Invalid media query: "', '"\n\n    ', "\n\n    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\n  "])), mediaQuery, msg));
var validateMediaQuery = (mediaQuery) => {
  if (mediaQuery === "@media ") {
    throw createMediaQueryError(mediaQuery, "Query is empty");
  }
  try {
    toAST(mediaQuery);
  } catch (e) {
    throw createMediaQueryError(mediaQuery, e.message);
  }
};
var _excluded = ["vars"];
var _excluded2 = ["content"];
var DECLARATION = "__DECLARATION";
var UNITLESS = {
  animationIterationCount: true,
  borderImage: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexShrink: true,
  fontWeight: true,
  gridArea: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnStart: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowStart: true,
  initialLetter: true,
  lineClamp: true,
  lineHeight: true,
  maxLines: true,
  opacity: true,
  order: true,
  orphans: true,
  scale: true,
  tabSize: true,
  WebkitLineClamp: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // svg properties
  fillOpacity: true,
  floodOpacity: true,
  maskBorder: true,
  maskBorderOutset: true,
  maskBorderSlice: true,
  maskBorderWidth: true,
  shapeImageThreshold: true,
  stopOpacity: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
function dashify(str) {
  return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
}
function replaceBetweenIndexes(target, startIndex, endIndex, replacement) {
  var start = target.slice(0, startIndex);
  var end = target.slice(endIndex);
  return "".concat(start).concat(replacement).concat(end);
}
var DOUBLE_SPACE = "  ";
var specialKeys = [...simplePseudos, "@layer", "@media", "@supports", "@container", "selectors"];
var Stylesheet = class {
  constructor(localClassNames2, composedClassLists2) {
    this.rules = [];
    this.conditionalRulesets = [new ConditionalRuleset()];
    this.fontFaceRules = [];
    this.keyframesRules = [];
    this.propertyRules = [];
    this.localClassNamesMap = new Map(localClassNames2.map((localClassName) => [localClassName, localClassName]));
    this.localClassNamesSearch = new AhoCorasick(localClassNames2);
    this.layers = /* @__PURE__ */ new Map();
    this.composedClassLists = composedClassLists2.map((_ref) => {
      var {
        identifier,
        classList
      } = _ref;
      return {
        identifier,
        regex: RegExp("(".concat(classList, ")"), "g")
      };
    }).reverse();
  }
  processCssObj(root) {
    if (root.type === "fontFace") {
      this.fontFaceRules.push(root.rule);
      return;
    }
    if (root.type === "property") {
      this.propertyRules.push(root);
      return;
    }
    if (root.type === "keyframes") {
      root.rule = Object.fromEntries(Object.entries(root.rule).map((_ref2) => {
        var [keyframe, rule] = _ref2;
        return [keyframe, this.transformVars(this.transformProperties(rule))];
      }));
      this.keyframesRules.push(root);
      return;
    }
    this.currConditionalRuleset = new ConditionalRuleset();
    if (root.type === "layer") {
      var layerDefinition = "@layer ".concat(root.name);
      this.addLayer([layerDefinition]);
    } else {
      var mainRule = omit(root.rule, specialKeys);
      this.addRule({
        selector: root.selector,
        rule: mainRule
      });
      this.transformLayer(root, root.rule["@layer"]);
      this.transformMedia(root, root.rule["@media"]);
      this.transformSupports(root, root.rule["@supports"]);
      this.transformContainer(root, root.rule["@container"]);
      this.transformSimplePseudos(root, root.rule);
      this.transformSelectors(root, root.rule);
    }
    var activeConditionalRuleset = this.conditionalRulesets[this.conditionalRulesets.length - 1];
    if (!activeConditionalRuleset.mergeIfCompatible(this.currConditionalRuleset)) {
      this.conditionalRulesets.push(this.currConditionalRuleset);
    }
  }
  addConditionalRule(cssRule, conditions) {
    var rule = this.transformVars(this.transformProperties(cssRule.rule));
    var selector = this.transformSelector(cssRule.selector);
    if (!this.currConditionalRuleset) {
      throw new Error("Couldn't add conditional rule");
    }
    var conditionQuery = conditions[conditions.length - 1];
    var parentConditions = conditions.slice(0, conditions.length - 1);
    this.currConditionalRuleset.addRule({
      selector,
      rule
    }, conditionQuery, parentConditions);
  }
  addRule(cssRule) {
    var rule = this.transformVars(this.transformProperties(cssRule.rule));
    var selector = this.transformSelector(cssRule.selector);
    this.rules.push({
      selector,
      rule
    });
  }
  addLayer(layer) {
    var uniqueLayerKey = layer.join(" - ");
    this.layers.set(uniqueLayerKey, layer);
  }
  transformProperties(cssRule) {
    return this.transformContent(this.pixelifyProperties(cssRule));
  }
  pixelifyProperties(cssRule) {
    forEach(cssRule, (value, key) => {
      if (typeof value === "number" && value !== 0 && !UNITLESS[key]) {
        cssRule[key] = "".concat(value, "px");
      }
    });
    return cssRule;
  }
  transformVars(_ref3) {
    var {
      vars
    } = _ref3, rest = _objectWithoutProperties(_ref3, _excluded);
    if (!vars) {
      return rest;
    }
    return _objectSpread22(_objectSpread22({}, mapKeys(vars, (_value, key) => getVarName(key))), rest);
  }
  transformContent(_ref4) {
    var {
      content
    } = _ref4, rest = _objectWithoutProperties(_ref4, _excluded2);
    if (typeof content === "undefined") {
      return rest;
    }
    var contentArray = Array.isArray(content) ? content : [content];
    return _objectSpread22({
      content: contentArray.map((value) => (
        // This logic was adapted from Stitches :)
        value && (value.includes('"') || value.includes("'") || /^([A-Za-z\-]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\s|$)/.test(value)) ? value : '"'.concat(value, '"')
      ))
    }, rest);
  }
  transformClassname(identifier) {
    return ".".concat((0, import_cssesc.default)(identifier, {
      isIdentifier: true
    }));
  }
  transformSelector(selector) {
    var transformedSelector = selector;
    var _loop = function _loop2(identifier2) {
      transformedSelector = transformedSelector.replace(regex, () => {
        markCompositionUsed(identifier2);
        return identifier2;
      });
    };
    for (var {
      identifier,
      regex
    } of this.composedClassLists) {
      _loop(identifier);
    }
    if (this.localClassNamesMap.has(transformedSelector)) {
      return this.transformClassname(transformedSelector);
    }
    var results = this.localClassNamesSearch.search(transformedSelector);
    var lastReplaceIndex = transformedSelector.length;
    for (var i = results.length - 1; i >= 0; i--) {
      var [endIndex, [firstMatch]] = results[i];
      var startIndex = endIndex - firstMatch.length + 1;
      var skipReplacement = lastReplaceIndex <= endIndex;
      if (skipReplacement) {
        continue;
      }
      lastReplaceIndex = startIndex;
      if (transformedSelector[startIndex - 1] !== ".") {
        transformedSelector = replaceBetweenIndexes(transformedSelector, startIndex, endIndex + 1, this.transformClassname(firstMatch));
      }
    }
    return transformedSelector;
  }
  transformSelectors(root, rule, conditions) {
    forEach(rule.selectors, (selectorRule, selector) => {
      if (root.type !== "local") {
        throw new Error("Selectors are not allowed within ".concat(root.type === "global" ? '"globalStyle"' : '"selectors"'));
      }
      var transformedSelector = this.transformSelector(selector.replace(RegExp("&", "g"), root.selector));
      validateSelector(transformedSelector, root.selector);
      var rule2 = {
        selector: transformedSelector,
        rule: omit(selectorRule, specialKeys)
      };
      if (conditions) {
        this.addConditionalRule(rule2, conditions);
      } else {
        this.addRule(rule2);
      }
      var selectorRoot = {
        type: "selector",
        selector: transformedSelector,
        rule: selectorRule
      };
      this.transformLayer(selectorRoot, selectorRule["@layer"], conditions);
      this.transformSupports(selectorRoot, selectorRule["@supports"], conditions);
      this.transformMedia(selectorRoot, selectorRule["@media"], conditions);
      this.transformContainer(selectorRoot, selectorRule["@container"], conditions);
    });
  }
  transformMedia(root, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional;
      (_this$currConditional = this.currConditionalRuleset) === null || _this$currConditional === void 0 || _this$currConditional.addConditionPrecedence(parentConditions, Object.keys(rules).map((query2) => "@media ".concat(query2)));
      for (var [query, mediaRule] of Object.entries(rules)) {
        var mediaQuery = "@media ".concat(query);
        validateMediaQuery(mediaQuery);
        var conditions = [...parentConditions, mediaQuery];
        this.addConditionalRule({
          selector: root.selector,
          rule: omit(mediaRule, specialKeys)
        }, conditions);
        if (root.type === "local") {
          this.transformSimplePseudos(root, mediaRule, conditions);
          this.transformSelectors(root, mediaRule, conditions);
        }
        this.transformLayer(root, mediaRule["@layer"], conditions);
        this.transformSupports(root, mediaRule["@supports"], conditions);
        this.transformContainer(root, mediaRule["@container"], conditions);
      }
    }
  }
  transformContainer(root, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional2;
      (_this$currConditional2 = this.currConditionalRuleset) === null || _this$currConditional2 === void 0 || _this$currConditional2.addConditionPrecedence(parentConditions, Object.keys(rules).map((query) => "@container ".concat(query)));
      forEach(rules, (containerRule, query) => {
        var containerQuery = "@container ".concat(query);
        var conditions = [...parentConditions, containerQuery];
        this.addConditionalRule({
          selector: root.selector,
          rule: omit(containerRule, specialKeys)
        }, conditions);
        if (root.type === "local") {
          this.transformSimplePseudos(root, containerRule, conditions);
          this.transformSelectors(root, containerRule, conditions);
        }
        this.transformLayer(root, containerRule["@layer"], conditions);
        this.transformSupports(root, containerRule["@supports"], conditions);
        this.transformMedia(root, containerRule["@media"], conditions);
      });
    }
  }
  transformLayer(root, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional3;
      (_this$currConditional3 = this.currConditionalRuleset) === null || _this$currConditional3 === void 0 || _this$currConditional3.addConditionPrecedence(parentConditions, Object.keys(rules).map((name) => "@layer ".concat(name)));
      forEach(rules, (layerRule, name) => {
        var conditions = [...parentConditions, "@layer ".concat(name)];
        this.addLayer(conditions);
        this.addConditionalRule({
          selector: root.selector,
          rule: omit(layerRule, specialKeys)
        }, conditions);
        if (root.type === "local") {
          this.transformSimplePseudos(root, layerRule, conditions);
          this.transformSelectors(root, layerRule, conditions);
        }
        this.transformMedia(root, layerRule["@media"], conditions);
        this.transformSupports(root, layerRule["@supports"], conditions);
        this.transformContainer(root, layerRule["@container"], conditions);
      });
    }
  }
  transformSupports(root, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional4;
      (_this$currConditional4 = this.currConditionalRuleset) === null || _this$currConditional4 === void 0 || _this$currConditional4.addConditionPrecedence(parentConditions, Object.keys(rules).map((query) => "@supports ".concat(query)));
      forEach(rules, (supportsRule, query) => {
        var conditions = [...parentConditions, "@supports ".concat(query)];
        this.addConditionalRule({
          selector: root.selector,
          rule: omit(supportsRule, specialKeys)
        }, conditions);
        if (root.type === "local") {
          this.transformSimplePseudos(root, supportsRule, conditions);
          this.transformSelectors(root, supportsRule, conditions);
        }
        this.transformLayer(root, supportsRule["@layer"], conditions);
        this.transformMedia(root, supportsRule["@media"], conditions);
        this.transformContainer(root, supportsRule["@container"], conditions);
      });
    }
  }
  transformSimplePseudos(root, rule, conditions) {
    for (var key of Object.keys(rule)) {
      if (simplePseudoLookup[key]) {
        if (root.type !== "local") {
          throw new Error("Simple pseudos are not valid in ".concat(root.type === "global" ? '"globalStyle"' : '"selectors"'));
        }
        if (conditions) {
          this.addConditionalRule({
            selector: "".concat(root.selector).concat(key),
            rule: rule[key]
          }, conditions);
        } else {
          this.addRule({
            conditions,
            selector: "".concat(root.selector).concat(key),
            rule: rule[key]
          });
        }
      }
    }
  }
  toCss() {
    var css = [];
    for (var fontFaceRule of this.fontFaceRules) {
      css.push(renderCss({
        "@font-face": fontFaceRule
      }));
    }
    for (var property of this.propertyRules) {
      css.push(renderCss({
        ["@property ".concat(property.name)]: property.rule
      }));
    }
    for (var keyframe of this.keyframesRules) {
      css.push(renderCss({
        ["@keyframes ".concat(keyframe.name)]: keyframe.rule
      }));
    }
    for (var layer of this.layers.values()) {
      var [definition, ...nesting] = layer.reverse();
      var cssObj = {
        [definition]: DECLARATION
      };
      for (var part of nesting) {
        cssObj = {
          [part]: cssObj
        };
      }
      css.push(renderCss(cssObj));
    }
    for (var rule of this.rules) {
      css.push(renderCss({
        [rule.selector]: rule.rule
      }));
    }
    for (var conditionalRuleset of this.conditionalRulesets) {
      for (var conditionalRule of conditionalRuleset.renderToArray()) {
        css.push(renderCss(conditionalRule));
      }
    }
    return css.filter(Boolean);
  }
};
function renderCss(v) {
  var indent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var rules = [];
  var _loop2 = function _loop22(key2) {
    var value = v[key2];
    if (value && Array.isArray(value)) {
      rules.push(...value.map((v2) => renderCss({
        [key2]: v2
      }, indent)));
    } else if (value && typeof value === "object") {
      var isEmpty2 = Object.keys(value).length === 0;
      if (!isEmpty2) {
        rules.push("".concat(indent).concat(key2, " {\n").concat(renderCss(value, indent + DOUBLE_SPACE), "\n").concat(indent, "}"));
      }
    } else if (value === DECLARATION) {
      rules.push("".concat(indent).concat(key2, ";"));
    } else {
      rules.push("".concat(indent).concat(key2.startsWith("--") ? key2 : dashify(key2), ": ").concat(value, ";"));
    }
  };
  for (var key of Object.keys(v)) {
    _loop2(key);
  }
  return rules.join("\n");
}
function transformCss(_ref5) {
  var {
    localClassNames: localClassNames2,
    cssObjs,
    composedClassLists: composedClassLists2
  } = _ref5;
  var stylesheet = new Stylesheet(localClassNames2, composedClassLists2);
  for (var root of cssObjs) {
    stylesheet.processCssObj(root);
  }
  return stylesheet.toCss();
}

// ../../node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn3) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn3) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
var _a5;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    constructor() {
      __publicField(this, "onabort");
      __publicField(this, "_onabort", []);
      __publicField(this, "reason");
      __publicField(this, "aborted", false);
    }
    addEventListener(_, fn3) {
      this._onabort.push(fn3);
    }
  };
  AC = class AbortController {
    constructor() {
      __publicField(this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      var _a7, _b3;
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn3 of this.signal._onabort) {
        fn3(reason);
      }
      (_b3 = (_a7 = this.signal).onabort) == null ? void 0 : _b3.call(_a7, reason);
    }
  };
  let printACPolyfillWarning = ((_a5 = PROCESS.env) == null ? void 0 : _a5.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max3) => !isPosInt(max3) ? null : max3 <= Math.pow(2, 8) ? Uint8Array : max3 <= Math.pow(2, 16) ? Uint16Array : max3 <= Math.pow(2, 32) ? Uint32Array : max3 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class _Stack {
  constructor(max3, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max3);
    this.length = 0;
  }
  static create(max3) {
    const HeapCls = getUintArray(max3);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s = new _Stack(max3, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
};
_constructing = new WeakMap();
// private constructor
__privateAdd(_Stack, _constructing, false);
var Stack = _Stack;
var _a6, _b2, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _memoMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn, delete_fn, clear_fn;
var _LRUCache = class _LRUCache {
  constructor(options) {
    __privateAdd(this, _LRUCache_instances);
    // options that cannot be changed without disaster
    __privateAdd(this, _max);
    __privateAdd(this, _maxSize);
    __privateAdd(this, _dispose);
    __privateAdd(this, _disposeAfter);
    __privateAdd(this, _fetchMethod);
    __privateAdd(this, _memoMethod);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size);
    __privateAdd(this, _calculatedSize);
    __privateAdd(this, _keyMap);
    __privateAdd(this, _keyList);
    __privateAdd(this, _valList);
    __privateAdd(this, _next);
    __privateAdd(this, _prev);
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _free);
    __privateAdd(this, _disposed);
    __privateAdd(this, _sizes);
    __privateAdd(this, _starts);
    __privateAdd(this, _ttls);
    __privateAdd(this, _hasDispose);
    __privateAdd(this, _hasFetchMethod);
    __privateAdd(this, _hasDisposeAfter);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => false);
    __privateAdd(this, _removeItemSize, (_i2) => {
    });
    __privateAdd(this, _addItemSize, (_i2, _s, _st) => {
    });
    __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    __publicField(this, _a6, "LRUCache");
    const { max: max3 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max3 !== 0 && !isPosInt(max3)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max3 ? getUintArray(max3) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max3);
    }
    __privateSet(this, _max, max3);
    __privateSet(this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    __privateSet(this, _memoMethod, memoMethod);
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    __privateSet(this, _fetchMethod, fetchMethod);
    __privateSet(this, _hasFetchMethod, !!fetchMethod);
    __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
    __privateSet(this, _keyList, new Array(max3).fill(void 0));
    __privateSet(this, _valList, new Array(max3).fill(void 0));
    __privateSet(this, _next, new UintArray(max3));
    __privateSet(this, _prev, new UintArray(max3));
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateSet(this, _free, Stack.create(max3));
    __privateSet(this, _size, 0);
    __privateSet(this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      __privateSet(this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      __privateSet(this, _disposeAfter, disposeAfter);
      __privateSet(this, _disposed, []);
    } else {
      __privateSet(this, _disposeAfter, void 0);
      __privateSet(this, _disposed, void 0);
    }
    __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
    __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0) {
        if (!isPosInt(__privateGet(this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      __privateMethod(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: __privateGet(c, _starts),
      ttls: __privateGet(c, _ttls),
      sizes: __privateGet(c, _sizes),
      keyMap: __privateGet(c, _keyMap),
      keyList: __privateGet(c, _keyList),
      valList: __privateGet(c, _valList),
      next: __privateGet(c, _next),
      prev: __privateGet(c, _prev),
      get head() {
        return __privateGet(c, _head);
      },
      get tail() {
        return __privateGet(c, _tail);
      },
      free: __privateGet(c, _free),
      // methods
      isBackgroundFetch: (p) => {
        var _a7;
        return __privateMethod(_a7 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a7, p);
      },
      backgroundFetch: (k2, index, options, context) => {
        var _a7;
        return __privateMethod(_a7 = c, _LRUCache_instances, backgroundFetch_fn).call(_a7, k2, index, options, context);
      },
      moveToTail: (index) => {
        var _a7;
        return __privateMethod(_a7 = c, _LRUCache_instances, moveToTail_fn).call(_a7, index);
      },
      indexes: (options) => {
        var _a7;
        return __privateMethod(_a7 = c, _LRUCache_instances, indexes_fn).call(_a7, options);
      },
      rindexes: (options) => {
        var _a7;
        return __privateMethod(_a7 = c, _LRUCache_instances, rindexes_fn).call(_a7, options);
      },
      isStale: (index) => {
        var _a7;
        return __privateGet(_a7 = c, _isStale).call(_a7, index);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  get memoMethod() {
    return __privateGet(this, _memoMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const k2 = __privateGet(this, _keyList)[i];
      if (k2 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield k2;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const k2 = __privateGet(this, _keyList)[i];
      if (k2 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield k2;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield __privateGet(this, _valList)[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield __privateGet(this, _valList)[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [(_b2 = Symbol.iterator, _a6 = Symbol.toStringTag, _b2)]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn3, getOptions = {}) {
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn3(value, __privateGet(this, _keyList)[i], this)) {
        return this.get(__privateGet(this, _keyList)[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn3, thisp = this) {
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn3.call(thisp, value, __privateGet(this, _keyList)[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn3, thisp = this) {
    for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn3.call(thisp, value, __privateGet(this, _keyList)[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
      if (__privateGet(this, _isStale).call(this, i)) {
        __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i = __privateGet(this, _keyMap).get(key);
    if (i === void 0)
      return void 0;
    const v = __privateGet(this, _valList)[i];
    const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      const ttl = __privateGet(this, _ttls)[i];
      const start = __privateGet(this, _starts)[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (__privateGet(this, _sizes)) {
      entry.size = __privateGet(this, _sizes)[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRLUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
      const key = __privateGet(this, _keyList)[i];
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i];
        const age = perf.now() - __privateGet(this, _starts)[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k2, v, setOptions = {}) {
    var _a7, _b3, _c, _d, _e3;
    if (v === void 0) {
      this.delete(k2);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = __privateGet(this, _requireSize).call(this, k2, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "set");
      return this;
    }
    let index = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k2);
    if (index === void 0) {
      index = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _LRUCache_instances, evict_fn).call(this, false) : __privateGet(this, _size);
      __privateGet(this, _keyList)[index] = k2;
      __privateGet(this, _valList)[index] = v;
      __privateGet(this, _keyMap).set(k2, index);
      __privateGet(this, _next)[__privateGet(this, _tail)] = index;
      __privateGet(this, _prev)[index] = __privateGet(this, _tail);
      __privateSet(this, _tail, index);
      __privateWrapper(this, _size)._++;
      __privateGet(this, _addItemSize).call(this, index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
      const oldVal = __privateGet(this, _valList)[index];
      if (v !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (__privateGet(this, _hasDispose)) {
              (_a7 = __privateGet(this, _dispose)) == null ? void 0 : _a7.call(this, s, k2, "set");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b3 = __privateGet(this, _disposed)) == null ? void 0 : _b3.push([s, k2, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (__privateGet(this, _hasDispose)) {
            (_c = __privateGet(this, _dispose)) == null ? void 0 : _c.call(this, oldVal, k2, "set");
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_d = __privateGet(this, _disposed)) == null ? void 0 : _d.push([oldVal, k2, "set"]);
          }
        }
        __privateGet(this, _removeItemSize).call(this, index);
        __privateGet(this, _addItemSize).call(this, index, size, status);
        __privateGet(this, _valList)[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !__privateGet(this, _ttls)) {
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _ttls)) {
      if (!noUpdateTTL) {
        __privateGet(this, _setItemTTL).call(this, index, ttl, start);
      }
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
    }
    if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt2 = __privateGet(this, _disposed);
      let task;
      while (task = dt2 == null ? void 0 : dt2.shift()) {
        (_e3 = __privateGet(this, _disposeAfter)) == null ? void 0 : _e3.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a7;
    try {
      while (__privateGet(this, _size)) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt2 = __privateGet(this, _disposed);
        let task;
        while (task = dt2 == null ? void 0 : dt2.shift()) {
          (_a7 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a7.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k2, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = __privateGet(this, _keyMap).get(k2);
    if (index !== void 0) {
      const v = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!__privateGet(this, _isStale).call(this, index)) {
        if (updateAgeOnHas) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status) {
          status.has = "hit";
          __privateGet(this, _statusTTL).call(this, status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        __privateGet(this, _statusTTL).call(this, status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k2, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = __privateGet(this, _keyMap).get(k2);
    if (index === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index)) {
      return;
    }
    const v = __privateGet(this, _valList)[index];
    return __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
  }
  async fetch(k2, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = __privateGet(this, _keyMap).get(k2);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k2, index, options, context);
      return p.__returned = p;
    } else {
      const v = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale2 = __privateGet(this, _isStale).call(this, index);
      if (!forceRefresh && !isStale2) {
        if (status)
          status.fetch = "hit";
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index);
        return v;
      }
      const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k2, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale2 ? "stale" : "refresh";
        if (staleVal && isStale2)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k2, fetchOptions = {}) {
    const v = await this.fetch(k2, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k2, memoOptions = {}) {
    const memoMethod = __privateGet(this, _memoMethod);
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const _a7 = memoOptions, { context, forceRefresh } = _a7, options = __objRest(_a7, ["context", "forceRefresh"]);
    const v = this.get(k2, options);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k2, v, {
      options,
      context
    });
    this.set(k2, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k2, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = __privateGet(this, _keyMap).get(k2);
    if (index !== void 0) {
      const value = __privateGet(this, _valList)[index];
      const fetching = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value);
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
      if (__privateGet(this, _isStale).call(this, index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k2) {
    return __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "delete");
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return __privateMethod(this, _LRUCache_instances, clear_fn).call(this, "delete");
  }
};
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_memoMethod = new WeakMap();
_size = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head = new WeakMap();
_tail = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_LRUCache_instances = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max));
  const starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls);
  __privateSet(this, _starts, starts);
  __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
    starts[index] = ttl !== 0 ? start : 0;
    ttls[index] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t = setTimeout(() => {
        if (__privateGet(this, _isStale).call(this, index)) {
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[index], "expire");
        }
      }, ttl + 1);
      if (t.unref) {
        t.unref();
      }
    }
  });
  __privateSet(this, _updateItemAge, (index) => {
    starts[index] = ttls[index] !== 0 ? perf.now() : 0;
  });
  __privateSet(this, _statusTTL, (status, index) => {
    if (ttls[index]) {
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start)
        return;
      status.ttl = ttl;
      status.start = start;
      status.now = cachedNow || getNow();
      const age = status.now - start;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n;
      const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t.unref) {
        t.unref();
      }
    }
    return n;
  };
  this.getRemainingTTL = (key) => {
    const index = __privateGet(this, _keyMap).get(key);
    if (index === void 0) {
      return 0;
    }
    const ttl = ttls[index];
    const start = starts[index];
    if (!ttl || !start) {
      return Infinity;
    }
    const age = (cachedNow || getNow()) - start;
    return ttl - age;
  };
  __privateSet(this, _isStale, (index) => {
    const s = starts[index];
    const t = ttls[index];
    return !!t && !!s && (cachedNow || getNow()) - s > t;
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _sizes, sizes);
  __privateSet(this, _removeItemSize, (index) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
    sizes[index] = 0;
  });
  __privateSet(this, _requireSize, (k2, v, size, sizeCalculation) => {
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
      return 0;
    }
    if (!isPosInt(size)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size = sizeCalculation(v, k2);
        if (!isPosInt(size)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size;
  });
  __privateSet(this, _addItemSize, (index, size, status) => {
    sizes[index] = size;
    if (__privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index];
      while (__privateGet(this, _calculatedSize) > maxSize) {
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
      }
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
    if (status) {
      status.entrySize = size;
      status.totalCalculatedSize = __privateGet(this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i = __privateGet(this, _tail); true; ) {
      if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
        yield i;
      }
      if (i === __privateGet(this, _head)) {
        break;
      } else {
        i = __privateGet(this, _prev)[i];
      }
    }
  }
};
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i = __privateGet(this, _head); true; ) {
      if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
        yield i;
      }
      if (i === __privateGet(this, _tail)) {
        break;
      } else {
        i = __privateGet(this, _next)[i];
      }
    }
  }
};
isValidIndex_fn = function(index) {
  return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
};
evict_fn = function(free) {
  var _a7, _b3;
  const head = __privateGet(this, _head);
  const k2 = __privateGet(this, _keyList)[head];
  const v = __privateGet(this, _valList)[head];
  if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
    v.__abortController.abort(new Error("evicted"));
  } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
    if (__privateGet(this, _hasDispose)) {
      (_a7 = __privateGet(this, _dispose)) == null ? void 0 : _a7.call(this, v, k2, "evict");
    }
    if (__privateGet(this, _hasDisposeAfter)) {
      (_b3 = __privateGet(this, _disposed)) == null ? void 0 : _b3.push([v, k2, "evict"]);
    }
  }
  __privateGet(this, _removeItemSize).call(this, head);
  if (free) {
    __privateGet(this, _keyList)[head] = void 0;
    __privateGet(this, _valList)[head] = void 0;
    __privateGet(this, _free).push(head);
  }
  if (__privateGet(this, _size) === 1) {
    __privateSet(this, _head, __privateSet(this, _tail, 0));
    __privateGet(this, _free).length = 0;
  } else {
    __privateSet(this, _head, __privateGet(this, _next)[head]);
  }
  __privateGet(this, _keyMap).delete(k2);
  __privateWrapper(this, _size)._--;
  return head;
};
backgroundFetch_fn = function(k2, index, options, context) {
  const v = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
  if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
    return v;
  }
  const ac = new AC();
  const { signal } = options;
  signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options,
    context
  };
  const cb = (v2, updateCache = false) => {
    const { aborted } = ac.signal;
    const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
    if (options.status) {
      if (aborted && !updateCache) {
        options.status.fetchAborted = true;
        options.status.fetchError = ac.signal.reason;
        if (ignoreAbort)
          options.status.fetchAbortIgnored = true;
      } else {
        options.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac.signal.reason);
    }
    const bf2 = p;
    if (__privateGet(this, _valList)[index] === p) {
      if (v2 === void 0) {
        if (bf2.__staleWhileFetching) {
          __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
        } else {
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "fetch");
        }
      } else {
        if (options.status)
          options.status.fetchUpdated = true;
        this.set(k2, v2, fetchOpts.options);
      }
    }
    return v2;
  };
  const eb = (er2) => {
    if (options.status) {
      options.status.fetchRejected = true;
      options.status.fetchError = er2;
    }
    return fetchFail(er2);
  };
  const fetchFail = (er2) => {
    const { aborted } = ac.signal;
    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
    const noDelete = allowStale || options.noDeleteOnFetchRejection;
    const bf2 = p;
    if (__privateGet(this, _valList)[index] === p) {
      const del = !noDelete || bf2.__staleWhileFetching === void 0;
      if (del) {
        __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "fetch");
      } else if (!allowStaleAborted) {
        __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options.status && bf2.__staleWhileFetching !== void 0) {
        options.status.returnedStale = true;
      }
      return bf2.__staleWhileFetching;
    } else if (bf2.__returned === bf2) {
      throw er2;
    }
  };
  const pcall = (res, rej) => {
    var _a7;
    const fmp = (_a7 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a7.call(this, k2, v, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
    }
    ac.signal.addEventListener("abort", () => {
      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
        res(void 0);
        if (options.allowStaleOnFetchAbort) {
          res = (v2) => cb(v2, true);
        }
      }
    });
  };
  if (options.status)
    options.status.fetchDispatched = true;
  const p = new Promise(pcall).then(cb, eb);
  const bf = Object.assign(p, {
    __abortController: ac,
    __staleWhileFetching: v,
    __returned: void 0
  });
  if (index === void 0) {
    this.set(k2, bf, __spreadProps(__spreadValues({}, fetchOpts.options), { status: void 0 }));
    index = __privateGet(this, _keyMap).get(k2);
  } else {
    __privateGet(this, _valList)[index] = bf;
  }
  return bf;
};
isBackgroundFetch_fn = function(p) {
  if (!__privateGet(this, _hasFetchMethod))
    return false;
  const b2 = p;
  return !!b2 && b2 instanceof Promise && b2.hasOwnProperty("__staleWhileFetching") && b2.__abortController instanceof AC;
};
connect_fn = function(p, n) {
  __privateGet(this, _prev)[n] = p;
  __privateGet(this, _next)[p] = n;
};
moveToTail_fn = function(index) {
  if (index !== __privateGet(this, _tail)) {
    if (index === __privateGet(this, _head)) {
      __privateSet(this, _head, __privateGet(this, _next)[index]);
    } else {
      __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
    }
    __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _tail), index);
    __privateSet(this, _tail, index);
  }
};
delete_fn = function(k2, reason) {
  var _a7, _b3, _c, _d;
  let deleted = false;
  if (__privateGet(this, _size) !== 0) {
    const index = __privateGet(this, _keyMap).get(k2);
    if (index !== void 0) {
      deleted = true;
      if (__privateGet(this, _size) === 1) {
        __privateMethod(this, _LRUCache_instances, clear_fn).call(this, reason);
      } else {
        __privateGet(this, _removeItemSize).call(this, index);
        const v = __privateGet(this, _valList)[index];
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          v.__abortController.abort(new Error("deleted"));
        } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
          if (__privateGet(this, _hasDispose)) {
            (_a7 = __privateGet(this, _dispose)) == null ? void 0 : _a7.call(this, v, k2, reason);
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_b3 = __privateGet(this, _disposed)) == null ? void 0 : _b3.push([v, k2, reason]);
          }
        }
        __privateGet(this, _keyMap).delete(k2);
        __privateGet(this, _keyList)[index] = void 0;
        __privateGet(this, _valList)[index] = void 0;
        if (index === __privateGet(this, _tail)) {
          __privateSet(this, _tail, __privateGet(this, _prev)[index]);
        } else if (index === __privateGet(this, _head)) {
          __privateSet(this, _head, __privateGet(this, _next)[index]);
        } else {
          const pi2 = __privateGet(this, _prev)[index];
          __privateGet(this, _next)[pi2] = __privateGet(this, _next)[index];
          const ni = __privateGet(this, _next)[index];
          __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index];
        }
        __privateWrapper(this, _size)._--;
        __privateGet(this, _free).push(index);
      }
    }
  }
  if (__privateGet(this, _hasDisposeAfter) && ((_c = __privateGet(this, _disposed)) == null ? void 0 : _c.length)) {
    const dt2 = __privateGet(this, _disposed);
    let task;
    while (task = dt2 == null ? void 0 : dt2.shift()) {
      (_d = __privateGet(this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
    }
  }
  return deleted;
};
clear_fn = function(reason) {
  var _a7, _b3, _c;
  for (const index of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
    const v = __privateGet(this, _valList)[index];
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
      v.__abortController.abort(new Error("deleted"));
    } else {
      const k2 = __privateGet(this, _keyList)[index];
      if (__privateGet(this, _hasDispose)) {
        (_a7 = __privateGet(this, _dispose)) == null ? void 0 : _a7.call(this, v, k2, reason);
      }
      if (__privateGet(this, _hasDisposeAfter)) {
        (_b3 = __privateGet(this, _disposed)) == null ? void 0 : _b3.push([v, k2, reason]);
      }
    }
  }
  __privateGet(this, _keyMap).clear();
  __privateGet(this, _valList).fill(void 0);
  __privateGet(this, _keyList).fill(void 0);
  if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
    __privateGet(this, _ttls).fill(0);
    __privateGet(this, _starts).fill(0);
  }
  if (__privateGet(this, _sizes)) {
    __privateGet(this, _sizes).fill(0);
  }
  __privateSet(this, _head, 0);
  __privateSet(this, _tail, 0);
  __privateGet(this, _free).length = 0;
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _size, 0);
  if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
    const dt2 = __privateGet(this, _disposed);
    let task;
    while (task = dt2 == null ? void 0 : dt2.shift()) {
      (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
    }
  }
};
var LRUCache = _LRUCache;

// ../../node_modules/.pnpm/@vanilla-extract+css@1.17.2/node_modules/@vanilla-extract/css/dist/vanilla-extract-css.esm.js
var import_cssesc2 = __toESM(require_cssesc());
var import_deepmerge = __toESM(require_cjs());
var localClassNames = /* @__PURE__ */ new Set();
var composedClassLists = [];
var bufferedCSSObjs = [];
var browserRuntimeAdapter = {
  appendCss: (cssObj) => {
    bufferedCSSObjs.push(cssObj);
  },
  registerClassName: (className) => {
    localClassNames.add(className);
  },
  registerComposition: (composition) => {
    composedClassLists.push(composition);
  },
  markCompositionUsed: () => {
  },
  onEndFileScope: (fileScope) => {
    var css = transformCss({
      localClassNames: Array.from(localClassNames),
      composedClassLists,
      cssObjs: bufferedCSSObjs
    }).join("\n");
    injectStyles({
      fileScope,
      css
    });
    bufferedCSSObjs = [];
  },
  getIdentOption: () => process.env.NODE_ENV === "production" ? "short" : "debug"
};
if (typeof window !== "undefined") {
  setAdapterIfNotSet(browserRuntimeAdapter);
}
var getLastSlashBeforeIndex = (path, index) => {
  var pathIndex = index - 1;
  while (pathIndex >= 0) {
    if (path[pathIndex] === "/") {
      return pathIndex;
    }
    pathIndex--;
  }
  return -1;
};
var _getDebugFileName = (path) => {
  var file;
  var lastIndexOfDotCss = path.lastIndexOf(".css");
  if (lastIndexOfDotCss === -1) {
    return "";
  }
  var lastSlashIndex = getLastSlashBeforeIndex(path, lastIndexOfDotCss);
  file = path.slice(lastSlashIndex + 1, lastIndexOfDotCss);
  if (lastSlashIndex === -1) {
    return file;
  }
  var secondLastSlashIndex = getLastSlashBeforeIndex(path, lastSlashIndex - 1);
  var dir = path.slice(secondLastSlashIndex + 1, lastSlashIndex);
  var debugFileName = file !== "index" ? file : dir;
  return debugFileName;
};
var memoizedGetDebugFileName = () => {
  var cache = new LRUCache({
    max: 500
  });
  return (path) => {
    var cachedResult = cache.get(path);
    if (cachedResult) {
      return cachedResult;
    }
    var result = _getDebugFileName(path);
    cache.set(path, result);
    return result;
  };
};
var getDebugFileName = memoizedGetDebugFileName();
function createGlobalThemeContract(tokens, mapFn) {
  return walkObject(tokens, (value, path) => {
    var rawVarName = typeof mapFn === "function" ? mapFn(value, path) : value;
    var varName = typeof rawVarName === "string" ? rawVarName.replace(/^\-\-/, "") : null;
    if (typeof varName !== "string" || varName !== (0, import_cssesc2.default)(varName, {
      isIdentifier: true
    })) {
      throw new Error('Invalid variable name for "'.concat(path.join("."), '": ').concat(varName));
    }
    return "var(--".concat(varName, ")");
  });
}

// ../../node_modules/.pnpm/@mysten+dapp-kit@0.14.44_@tanstack+react-query@5.76.0_react@19.1.0__@types+react-dom@18.3.7_@_ckag77vru7hslt4afqvecufmau/node_modules/@mysten/dapp-kit/dist/esm/index.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __esm = (fn3, res) => function __init() {
  return fn3 && (res = (0, fn3[__getOwnPropNames2(fn3)[0]])(fn3 = 0)), res;
};
var __commonJS2 = (cb, mod3) => function __require2() {
  return mod3 || (0, cb[__getOwnPropNames2(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod3, isNodeMode, target) => (target = mod3 != null ? __create2(__getProtoOf2(mod3)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp2(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var init_StyleMarker_css_ts_vanilla = __esm({
  "vanilla-extract-css-ns:src/components/styling/StyleMarker.css.ts.vanilla.css?source=OndoZXJlKCopIHsKICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogIGNvbG9yOiB2YXIoLS1kYXBwLWtpdC1jb2xvcnMtYm9keSk7CiAgZm9udC1mYW1pbHk6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udEZhbWlseSk7CiAgZm9udC1zaXplOiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1ub3JtYWwpOwogIGZvbnQtc3R5bGU6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udFN0eWxlKTsKICBmb250LXdlaWdodDogdmFyKC0tZGFwcC1raXQtZm9udFdlaWdodHMtbm9ybWFsKTsKICBsaW5lLWhlaWdodDogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1saW5lSGVpZ2h0KTsKICBsZXR0ZXItc3BhY2luZzogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1sZXR0ZXJTcGFjaW5nKTsKfQo6d2hlcmUoYnV0dG9uKSB7CiAgYXBwZWFyYW5jZTogbm9uZTsKICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7CiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7CiAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7CiAgY29sb3I6IGluaGVyaXQ7CiAgYm9yZGVyOiAwOwogIHBhZGRpbmc6IDA7CiAgbWFyZ2luOiAwOwp9Cjp3aGVyZShhKSB7CiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOwogIGNvbG9yOiBpbmhlcml0OwogIG91dGxpbmU6IG5vbmU7Cn0KOndoZXJlKG9sLCB1bCkgewogIGxpc3Qtc3R5bGU6IG5vbmU7CiAgbWFyZ2luOiAwOwogIHBhZGRpbmc6IDA7Cn0KOndoZXJlKGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYpIHsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7CiAgbWFyZ2luOiAwOwp9"() {
  }
});
var require_StyleMarker_css = __commonJS2({
  "src/components/styling/StyleMarker.css.ts"() {
    "use strict";
    init_StyleMarker_css_ts_vanilla();
  }
});
var walletMutationKeys = {
  all: { baseScope: "wallet" },
  connectWallet: formMutationKeyFn("connect-wallet"),
  autoconnectWallet: formMutationKeyFn("autoconnect-wallet"),
  disconnectWallet: formMutationKeyFn("disconnect-wallet"),
  signPersonalMessage: formMutationKeyFn("sign-personal-message"),
  signTransaction: formMutationKeyFn("sign-transaction"),
  signAndExecuteTransaction: formMutationKeyFn("sign-and-execute-transaction"),
  switchAccount: formMutationKeyFn("switch-account"),
  reportTransactionEffects: formMutationKeyFn("report-transaction-effects")
};
function formMutationKeyFn(baseEntity) {
  return function mutationKeyFn(additionalKeys = []) {
    return [__spreadProps(__spreadValues({}, walletMutationKeys.all), { baseEntity }), ...additionalKeys];
  };
}
var WalletContext = (0, import_react5.createContext)(null);
var styleDataAttributeName = "data-dapp-kit";
var styleDataAttributeSelector = `[${styleDataAttributeName}]`;
var styleDataAttribute = { [styleDataAttributeName]: "" };
var import_StyleMarker_css = __toESM2(require_StyleMarker_css());
var StyleMarker = (0, import_react6.forwardRef)((_a7, forwardedRef) => {
  var _b3 = _a7, { children } = _b3, props = __objRest(_b3, ["children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Slot, __spreadProps(__spreadValues(__spreadValues({ ref: forwardedRef }, props), styleDataAttribute), { children }));
});
StyleMarker.displayName = "StyleMarker";
var headingVariants = createRuntimeFn({ defaultClassName: "Heading__1aa835k0", variantClassNames: { size: { sm: "Heading_headingVariants_size_sm__1aa835k1", md: "Heading_headingVariants_size_md__1aa835k2", lg: "Heading_headingVariants_size_lg__1aa835k3", xl: "Heading_headingVariants_size_xl__1aa835k4" }, weight: { normal: "Heading_headingVariants_weight_normal__1aa835k5", bold: "Heading_headingVariants_weight_bold__1aa835k6" }, truncate: { true: "Heading_headingVariants_truncate_true__1aa835k7" } }, defaultVariants: { size: "lg", weight: "bold" }, compoundVariants: [] });
var Heading = (0, import_react7.forwardRef)(
  (_a7, forwardedRef) => {
    var _b3 = _a7, {
      children,
      className,
      asChild = false,
      as: Tag = "h1",
      size,
      weight,
      truncate: truncate3
    } = _b3, headingProps = __objRest(_b3, [
      "children",
      "className",
      "asChild",
      "as",
      "size",
      "weight",
      "truncate"
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      Slot,
      __spreadProps(__spreadValues({}, headingProps), {
        ref: forwardedRef,
        className: clsx_default(headingVariants({ size, weight, truncate: truncate3 }), className),
        children: asChild ? children : /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Tag, { children })
      })
    );
  }
);
Heading.displayName = "Heading";
var container = "IconButton_container__s6n7bq0";
var IconButton = (0, import_react8.forwardRef)(
  (_a7, forwardedRef) => {
    var _b3 = _a7, { className, asChild = false } = _b3, props = __objRest(_b3, ["className", "asChild"]);
    const Comp = asChild ? Slot : "button";
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Comp, __spreadProps(__spreadValues({}, props), { className: clsx_default(container, className), ref: forwardedRef }));
  }
);
IconButton.displayName = "Button";
var buttonVariants = createRuntimeFn({ defaultClassName: "Button_buttonVariants__x1s81q0", variantClassNames: { variant: { primary: "Button_buttonVariants_variant_primary__x1s81q1", outline: "Button_buttonVariants_variant_outline__x1s81q2" }, size: { md: "Button_buttonVariants_size_md__x1s81q3", lg: "Button_buttonVariants_size_lg__x1s81q4" } }, defaultVariants: { variant: "primary", size: "md" }, compoundVariants: [] });
var Button = (0, import_react9.forwardRef)(
  (_a7, forwardedRef) => {
    var _b3 = _a7, { className, variant, size, asChild = false } = _b3, props = __objRest(_b3, ["className", "variant", "size", "asChild"]);
    const Comp = asChild ? Slot : "button";
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
      Comp,
      __spreadProps(__spreadValues({}, props), {
        className: clsx_default(buttonVariants({ variant, size }), className),
        ref: forwardedRef
      })
    );
  }
);
Button.displayName = "Button";
var textVariants = createRuntimeFn({ defaultClassName: "Text__2bv1ur0", variantClassNames: { size: { sm: "Text_textVariants_size_sm__2bv1ur1" }, weight: { normal: "Text_textVariants_weight_normal__2bv1ur2", medium: "Text_textVariants_weight_medium__2bv1ur3", bold: "Text_textVariants_weight_bold__2bv1ur4" }, color: { muted: "Text_textVariants_color_muted__2bv1ur5", danger: "Text_textVariants_color_danger__2bv1ur6" }, mono: { true: "Text_textVariants_mono_true__2bv1ur7" } }, defaultVariants: { size: "sm", weight: "normal" }, compoundVariants: [] });
var Text = (0, import_react10.forwardRef)(
  (_a7, forwardedRef) => {
    var _b3 = _a7, {
      children,
      className,
      asChild = false,
      as: Tag = "div",
      size,
      weight,
      color,
      mono
    } = _b3, textProps = __objRest(_b3, [
      "children",
      "className",
      "asChild",
      "as",
      "size",
      "weight",
      "color",
      "mono"
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      Slot,
      __spreadProps(__spreadValues({}, textProps), {
        ref: forwardedRef,
        className: clsx_default(textVariants({ size, weight, color, mono }), className),
        children: asChild ? children : /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Tag, { children })
      })
    );
  }
);
Text.displayName = "Text";
var SuiClientContext = (0, import_react13.createContext)(null);
var DEFAULT_NETWORKS = {
  localnet: { url: getFullnodeUrl("localnet") }
};
function useSuiClientContext() {
  const suiClient = (0, import_react12.useContext)(SuiClientContext);
  if (!suiClient) {
    throw new Error(
      "Could not find SuiClientContext. Ensure that you have set up the SuiClientProvider"
    );
  }
  return suiClient;
}
function useSuiClient() {
  return useSuiClientContext().client;
}
function createInMemoryStore() {
  const store5 = /* @__PURE__ */ new Map();
  return {
    getItem(key) {
      return store5.get(key);
    },
    setItem(key, value) {
      store5.set(key, value);
    },
    removeItem(key) {
      store5.delete(key);
    }
  };
}
var DEFAULT_STORAGE = typeof window !== "undefined" && window.localStorage ? localStorage : createInMemoryStore();
var themeContractValues = {
  blurs: {
    modalOverlay: ""
  },
  backgroundColors: {
    primaryButton: "",
    primaryButtonHover: "",
    outlineButtonHover: "",
    walletItemHover: "",
    walletItemSelected: "",
    modalOverlay: "",
    modalPrimary: "",
    modalSecondary: "",
    iconButton: "",
    iconButtonHover: "",
    dropdownMenu: "",
    dropdownMenuSeparator: ""
  },
  borderColors: {
    outlineButton: ""
  },
  colors: {
    primaryButton: "",
    outlineButton: "",
    body: "",
    bodyMuted: "",
    bodyDanger: "",
    iconButton: ""
  },
  radii: {
    small: "",
    medium: "",
    large: "",
    xlarge: ""
  },
  shadows: {
    primaryButton: "",
    walletItemSelected: ""
  },
  fontWeights: {
    normal: "",
    medium: "",
    bold: ""
  },
  fontSizes: {
    small: "",
    medium: "",
    large: "",
    xlarge: ""
  },
  typography: {
    fontFamily: "",
    fontStyle: "",
    lineHeight: "",
    letterSpacing: ""
  }
};
var themeVars = createGlobalThemeContract(
  themeContractValues,
  (_, path) => `dapp-kit-${path.join("-")}`
);

// src/hooks/useFetchLpPosition.ts
function useFetchLpPosition(coinConfig, debug = false) {
  const suiClient = useSuiClient();
  const { address } = Ft();
  return useMutation({
    mutationFn: async () => {
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      if (!address) {
        throw new Error("Please connect wallet first");
      }
      const response = await suiClient.getOwnedObjects({
        owner: address,
        filter: {
          MatchAny: coinConfig.marketPositionTypeList.map((type) => ({
            StructType: type
          }))
        },
        options: {
          showContent: true
        }
      });
      const debugInfo = {
        moveCall: [
          {
            target: "query lp positions",
            arguments: [
              { name: "address", value: address },
              {
                name: "marketPositionTypeList",
                value: coinConfig.marketPositionTypeList.join(" ")
              },
              { name: "maturity", value: coinConfig.maturity },
              { name: "marketStateId", value: coinConfig.marketStateId }
            ],
            typeArguments: []
          }
        ],
        rawResult: {
          results: response.data
        }
      };
      const positions = response.data.map(
        (item) => {
          var _a7, _b3;
          return (_b3 = (_a7 = item.data) == null ? void 0 : _a7.content) == null ? void 0 : _b3.fields;
        }
      ).filter((item) => {
        return !!item && typeof item === "object" && "expiry" in item && "market_state_id" in item;
      }).filter(
        (item) => item.expiry === coinConfig.maturity && item.market_state_id === coinConfig.marketStateId
      ).sort(
        (a, b2) => Decimal.sub(b2.lp_amount, a.lp_amount).toNumber()
      ).map((position) => __spreadProps(__spreadValues({}, position), {
        lp_amount_display: new Decimal(position.lp_amount).div(10 ** Number(coinConfig.decimal)).toString()
      }));
      return debug ? [positions, debugInfo] : positions;
    }
  });
}

// src/hooks/useFetchPyPosition.ts
var useFetchPyPosition = (coinConfig, debug = false) => {
  const suiClient = useSuiClient();
  const { address } = Ft();
  return useMutation({
    mutationFn: async () => {
      if (!address || !coinConfig) {
        throw new Error("Missing required parameters");
      }
      const response = await suiClient.getOwnedObjects({
        owner: address,
        filter: {
          MatchAny: coinConfig.pyPositionTypeList.map((type) => ({
            StructType: type
          }))
        },
        options: {
          showContent: true
        }
      });
      const debugInfo = {
        moveCall: [
          {
            target: "suiClient_getOwnedObjects",
            arguments: [
              { name: "owner", value: address },
              { name: "maturity", value: coinConfig.maturity },
              { name: "pyStateId", value: coinConfig.pyStateId }
            ],
            typeArguments: coinConfig.pyPositionTypeList
          }
        ],
        rawResult: {
          results: [response]
        }
      };
      const positions = response.data.map(
        (item) => {
          var _a7, _b3;
          return (_b3 = (_a7 = item.data) == null ? void 0 : _a7.content) == null ? void 0 : _b3.fields;
        }
      ).filter((item) => !!item).filter(
        (item) => item.expiry === coinConfig.maturity && item.py_state_id === coinConfig.pyStateId
      ).map(
        ({ expiry, id, pt_balance, yt_balance, py_state_id }) => ({
          id: id.id,
          maturity: expiry,
          ptBalance: pt_balance,
          ytBalance: yt_balance,
          pyStateId: py_state_id
        })
      );
      return debug ? [positions, debugInfo] : [positions];
    }
  });
};
var useFetchPyPosition_default = useFetchPyPosition;

// src/lib/txHelper.ts
function splitCoinHelper(tx, coinData, amounts, coinType) {
  const totalTargetAmount = amounts.reduce(
    (sum3, amount) => sum3.add(new decimal_default(amount)),
    new decimal_default(0)
  );
  if (!coinType || [
    "0x2::sui::SUI",
    "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI"
  ].includes(coinType)) {
    const totalBalance = coinData.reduce(
      (sum3, coin) => sum3.add(coin.balance),
      new decimal_default(0)
    );
    if (totalBalance.lt(totalTargetAmount)) {
      throw new Error(coinType + " Insufficient balance");
    }
    return tx.splitCoins(tx.gas, amounts);
  } else {
    const firstCoinBalance = new decimal_default(coinData[0].balance);
    if (firstCoinBalance.gte(totalTargetAmount)) {
      if (firstCoinBalance.eq(totalTargetAmount) && amounts.length === 1) {
        return [tx.object(coinData[0].coinObjectId)];
      }
      return tx.splitCoins(tx.object(coinData[0].coinObjectId), amounts);
    }
    const coinsToUse = [];
    let accumulatedBalance = new decimal_default(0);
    for (const coin of coinData) {
      accumulatedBalance = accumulatedBalance.add(coin.balance);
      coinsToUse.push(coin.coinObjectId);
      if (accumulatedBalance.gte(totalTargetAmount)) {
        break;
      }
    }
    if (accumulatedBalance.lt(totalTargetAmount)) {
      throw new Error(coinType + " insufficient balance");
    }
    tx.mergeCoins(
      tx.object(coinsToUse[0]),
      coinsToUse.slice(1).map((id) => tx.object(id))
    );
    return tx.splitCoins(coinsToUse[0], amounts);
  }
}
var mergeLpPositions = (tx, coinConfig, lpPositions, lpAmount) => {
  const sortedPositions = [...lpPositions].sort(
    (a, b2) => Number(b2.lp_amount) - Number(a.lp_amount)
  );
  let accumulatedAmount = new decimal_default(0);
  const positionsToMerge = [];
  for (const position of sortedPositions) {
    accumulatedAmount = accumulatedAmount.add(position.lp_amount);
    positionsToMerge.push(position);
    if (accumulatedAmount.gte(lpAmount)) {
      break;
    }
  }
  if (accumulatedAmount.lt(lpAmount)) {
    throw new Error("Insufficient LP amount");
  }
  const mergedPosition = tx.object(positionsToMerge[0].id.id);
  if (positionsToMerge.length === 1) {
    return mergedPosition;
  }
  for (let i = 1; i < positionsToMerge.length; i++) {
    const joinMoveCall = {
      target: `${coinConfig.nemoContractId}::market_position::join`,
      arguments: [positionsToMerge[0].id.id, positionsToMerge[i].id.id, "0x6"],
      typeArguments: []
    };
    tx.moveCall(__spreadProps(__spreadValues({}, joinMoveCall), {
      arguments: joinMoveCall.arguments.map((arg) => tx.object(arg))
    }));
  }
  return mergedPosition;
};
function depositSyCoin(tx, coinConfig, splitCoin, coinType) {
  const depositMoveCall = {
    target: `${coinConfig.nemoContractId}::sy::deposit`,
    arguments: [coinConfig.version, "splitCoin", coinConfig.syStateId],
    typeArguments: [coinType, coinConfig.syCoinType]
  };
  const [syCoin] = tx.moveCall(__spreadProps(__spreadValues({}, depositMoveCall), {
    arguments: [
      tx.object(coinConfig.version),
      splitCoin,
      tx.object(coinConfig.syStateId)
    ]
  }));
  return syCoin;
}
var mintPY = (tx, coinConfig, syCoin, priceVoucher, pyPosition, returnDebugInfo) => {
  const debugInfo = {
    target: `${coinConfig.nemoContractId}::yield_factory::mint_py`,
    arguments: [
      { name: "version", value: coinConfig.version },
      { name: "sy_coin", value: "syCoin" },
      { name: "price_voucher", value: "priceVoucher" },
      { name: "py_position", value: "pyPosition" },
      { name: "py_state", value: coinConfig.pyStateId },
      { name: "yield_factory_config", value: coinConfig.yieldFactoryConfigId },
      { name: "clock", value: "0x6" }
    ],
    typeArguments: [coinConfig.syCoinType]
  };
  const txMoveCall = {
    target: debugInfo.target,
    arguments: [
      tx.object(coinConfig.version),
      syCoin,
      priceVoucher,
      pyPosition,
      tx.object(coinConfig.pyStateId),
      tx.object(coinConfig.yieldFactoryConfigId),
      tx.object("0x6")
    ],
    typeArguments: debugInfo.typeArguments
  };
  const result = tx.moveCall(txMoveCall);
  return returnDebugInfo ? [result, debugInfo] : result;
};
var redeemSyCoin = (tx, coinConfig, syCoin) => {
  const redeemMoveCall = {
    target: `${coinConfig.nemoContractId}::sy::redeem`,
    arguments: [coinConfig.version, "syCoin", coinConfig.syStateId],
    typeArguments: [coinConfig.coinType, coinConfig.syCoinType]
  };
  const [yieldToken] = tx.moveCall(__spreadProps(__spreadValues({}, redeemMoveCall), {
    arguments: [
      tx.object(coinConfig.version),
      syCoin,
      tx.object(coinConfig.syStateId)
    ]
  }));
  return yieldToken;
};
var burnLp = (tx, coinConfig, lpAmount, pyPosition, mergedPositionId) => {
  const burnLpMoveCall = {
    target: `${coinConfig.nemoContractId}::market::burn_lp`,
    arguments: [
      coinConfig.version,
      lpAmount,
      "pyPosition",
      coinConfig.marketStateId,
      "mergedPositionId",
      "0x6"
    ],
    typeArguments: [coinConfig.syCoinType]
  };
  const [syCoin] = tx.moveCall(__spreadProps(__spreadValues({}, burnLpMoveCall), {
    arguments: [
      tx.object(coinConfig.version),
      tx.pure.u64(lpAmount),
      pyPosition,
      tx.object(coinConfig.marketStateId),
      mergedPositionId,
      tx.object("0x6")
    ]
  }));
  return syCoin;
};
var swapExactPtForSy = (tx, coinConfig, ptAmount, pyPosition, priceVoucher, minSyOut, returnDebugInfo) => {
  const debugInfo = {
    target: `${coinConfig.nemoContractId}::market::swap_exact_pt_for_sy`,
    arguments: [
      { name: "version", value: coinConfig.version },
      { name: "pt_amount", value: ptAmount },
      { name: "min_sy_out", value: minSyOut },
      { name: "py_position", value: "pyPosition" },
      { name: "py_state", value: coinConfig.pyStateId },
      { name: "price_voucher", value: "priceVoucher" },
      {
        name: "market_factory_config",
        value: coinConfig.marketFactoryConfigId
      },
      { name: "market_state", value: coinConfig.marketStateId },
      { name: "clock", value: "0x6" }
    ],
    typeArguments: [coinConfig.syCoinType]
  };
  const txMoveCall = {
    target: debugInfo.target,
    arguments: [
      tx.object(coinConfig.version),
      tx.pure.u64(ptAmount),
      tx.pure.u64(minSyOut),
      pyPosition,
      tx.object(coinConfig.pyStateId),
      priceVoucher,
      tx.object(coinConfig.marketFactoryConfigId),
      tx.object(coinConfig.marketStateId),
      tx.object("0x6")
    ],
    typeArguments: debugInfo.typeArguments
  };
  const result = tx.moveCall(txMoveCall);
  return returnDebugInfo ? [result, debugInfo] : result;
};
var swapExactYtForSy = (tx, coinConfig, ytAmount, pyPosition, priceVoucher, minSyOut, returnDebugInfo) => {
  const debugInfo = {
    target: `${coinConfig.nemoContractId}::router::swap_exact_yt_for_sy`,
    arguments: [
      { name: "version", value: coinConfig.version },
      { name: "yt_amount", value: ytAmount },
      { name: "min_sy_out", value: minSyOut },
      { name: "py_position", value: "pyPosition" },
      { name: "py_state", value: coinConfig.pyStateId },
      { name: "price_voucher", value: "priceVoucher" },
      { name: "yield_factory_config", value: coinConfig.yieldFactoryConfigId },
      {
        name: "market_factory_config",
        value: coinConfig.marketFactoryConfigId
      },
      { name: "market_state", value: coinConfig.marketStateId },
      { name: "clock", value: "0x6" }
    ],
    typeArguments: [coinConfig.syCoinType]
  };
  const txMoveCall = {
    target: debugInfo.target,
    arguments: [
      tx.object(coinConfig.version),
      tx.pure.u64(ytAmount),
      tx.pure.u64(minSyOut),
      pyPosition,
      tx.object(coinConfig.pyStateId),
      priceVoucher,
      tx.object(coinConfig.yieldFactoryConfigId),
      tx.object(coinConfig.marketFactoryConfigId),
      tx.object(coinConfig.marketStateId),
      tx.object("0x6")
    ],
    typeArguments: debugInfo.typeArguments
  };
  const result = tx.moveCall(txMoveCall);
  return returnDebugInfo ? [result, debugInfo] : result;
};
var redeemPy = (tx, coinConfig, ytAmount, ptAmount, priceVoucher, pyPosition, returnDebugInfo) => {
  const debugInfo = {
    target: `${coinConfig.nemoContractId}::yield_factory::redeem_py`,
    arguments: [
      { name: "version", value: coinConfig.version },
      { name: "yt_amount", value: ytAmount },
      { name: "pt_amount", value: ptAmount },
      { name: "price_voucher", value: priceVoucher },
      { name: "py_position", value: pyPosition },
      { name: "py_state", value: coinConfig.pyStateId },
      { name: "yield_factory_config", value: coinConfig.yieldFactoryConfigId },
      { name: "clock", value: "0x6" }
    ],
    typeArguments: [coinConfig.syCoinType]
  };
  const txMoveCall = {
    target: debugInfo.target,
    arguments: [
      tx.object(coinConfig.version),
      tx.pure.u64(ytAmount),
      tx.pure.u64(ptAmount),
      priceVoucher,
      pyPosition,
      tx.object(coinConfig.pyStateId),
      tx.object(coinConfig.yieldFactoryConfigId),
      tx.object("0x6")
    ],
    typeArguments: debugInfo.typeArguments
  };
  const result = tx.moveCall(txMoveCall);
  return returnDebugInfo ? [result, debugInfo] : result;
};
var getPrice = (tx, coinConfig, priceVoucher) => {
  const moveCall = {
    target: `${coinConfig.oracleVoucherPackageId}::oracle_voucher::get_price`,
    arguments: ["priceVoucher"],
    typeArguments: [coinConfig.syCoinType]
  };
  const [price] = tx.moveCall(__spreadProps(__spreadValues({}, moveCall), {
    arguments: [priceVoucher]
  }));
  return price;
};
var mergeAllLpPositions = (tx, coinConfig, lpPositions, marketPosition) => {
  if (lpPositions.length === 0) {
    return marketPosition;
  }
  const joinMoveCall = {
    target: `${coinConfig.nemoContractId}::market_position::join`,
    arguments: [lpPositions[0].id.id, marketPosition, "0x6"],
    typeArguments: []
  };
  tx.moveCall(__spreadProps(__spreadValues({}, joinMoveCall), {
    arguments: joinMoveCall.arguments.map((arg) => tx.object(arg))
  }));
  for (let i = 1; i < lpPositions.length; i++) {
    const joinMoveCall2 = {
      target: `${coinConfig.nemoContractId}::market_position::join`,
      arguments: [lpPositions[0].id.id, lpPositions[i].id.id, "0x6"],
      typeArguments: []
    };
    tx.moveCall(__spreadProps(__spreadValues({}, joinMoveCall2), {
      arguments: joinMoveCall2.arguments.map((arg) => tx.object(arg))
    }));
  }
  return tx.object(lpPositions[0].id.id);
};
var swapExactSyForPt = (tx, coinConfig, syCoin, priceVoucher, pyPosition, minPtOut, approxPtOut, returnDebugInfo) => {
  const debugInfo = {
    target: `${coinConfig.nemoContractId}::router::swap_exact_sy_for_pt`,
    arguments: [
      { name: "version", value: coinConfig.version },
      { name: "min_pt_out", value: minPtOut },
      { name: "approx_pt_out", value: approxPtOut },
      { name: "sy_coin", value: "syCoin" },
      { name: "price_voucher", value: "priceVoucher" },
      { name: "py_position", value: "pyPosition" },
      { name: "py_state", value: coinConfig.pyStateId },
      {
        name: "market_factory_config",
        value: coinConfig.marketFactoryConfigId
      },
      { name: "market_state", value: coinConfig.marketStateId },
      { name: "clock", value: "0x6" }
    ],
    typeArguments: [coinConfig.syCoinType]
  };
  const txMoveCall = {
    target: debugInfo.target,
    arguments: [
      tx.object(coinConfig.version),
      tx.pure.u64(minPtOut),
      tx.pure.u64(approxPtOut),
      syCoin,
      priceVoucher,
      pyPosition,
      tx.object(coinConfig.pyStateId),
      tx.object(coinConfig.marketFactoryConfigId),
      tx.object(coinConfig.marketStateId),
      tx.object("0x6")
    ],
    typeArguments: debugInfo.typeArguments
  };
  tx.moveCall(txMoveCall);
  return returnDebugInfo ? debugInfo : void 0;
};
var mergeAllCoins = async (tx, address, coins, coinType = "0x2::sui::SUI") => {
  if (!coins || coins.length === 0) {
    throw new Error("No coins to merge or only one coin available");
  }
  if (coins.length === 1) {
    return coins[0].coinObjectId;
  }
  if (coinType === "0x2::sui::SUI") {
    const [mergedCoin] = tx.splitCoins(tx.gas, [
      tx.pure.u64(
        coins.reduce((total, coin) => total + Number(coin.balance), 0)
      )
    ]);
    tx.transferObjects([mergedCoin], address);
    return coins[0].coinObjectId;
  } else {
    const primaryCoin = coins[0].coinObjectId;
    const otherCoins = coins.slice(1).map((coin) => tx.object(coin.coinObjectId));
    tx.mergeCoins(tx.object(primaryCoin), otherCoins);
    return primaryCoin;
  }
};

// src/lib/txHelper/position.ts
var initPyPosition = ({
  tx,
  coinConfig,
  pyPositions,
  returnDebugInfo
}) => {
  let pyPosition;
  let created = false;
  if (!(pyPositions == null ? void 0 : pyPositions.length)) {
    created = true;
    const moveCallInfo = {
      target: `${coinConfig.nemoContractId}::py::init_py_position`,
      arguments: [
        { name: "version", value: coinConfig.version },
        { name: "py_state", value: coinConfig.pyStateId },
        { name: "clock", value: "0x6" }
      ],
      typeArguments: [coinConfig.syCoinType]
    };
    const txMoveCall = {
      target: moveCallInfo.target,
      arguments: [
        tx.object(coinConfig.version),
        tx.object(coinConfig.pyStateId),
        tx.object("0x6")
      ],
      typeArguments: moveCallInfo.typeArguments
    };
    const [result] = tx.moveCall(txMoveCall);
    pyPosition = result;
    return returnDebugInfo ? [{ pyPosition, created }, moveCallInfo] : { pyPosition, created };
  } else {
    const moveCallInfo = {
      target: `0x2::object::object`,
      arguments: [{ name: "id", value: pyPositions[0].id }],
      typeArguments: []
    };
    pyPosition = tx.object(pyPositions[0].id);
    return returnDebugInfo ? [{ pyPosition, created }, moveCallInfo] : { pyPosition, created };
  }
};

// ../../node_modules/.pnpm/@cetusprotocol+vaults-sdk@0.0.0-experimental-20250414153224_@jest+transform@29.7.0_@jest+type_wkprgkljhryhol365ibhpttqvq/node_modules/@cetusprotocol/vaults-sdk/dist/index.mjs
var import_bn8 = __toESM(require_bn(), 1);
var import_bn9 = __toESM(require_bn(), 1);
var import_bn10 = __toESM(require_bn(), 1);
var import_bn11 = __toESM(require_bn(), 1);
var import_bn12 = __toESM(require_bn(), 1);
var import_bn13 = __toESM(require_bn(), 1);
var import_bn14 = __toESM(require_bn(), 1);
var import_bn15 = __toESM(require_bn(), 1);
var import_bn16 = __toESM(require_bn(), 1);
var import_bn17 = __toESM(require_bn(), 1);
var import_bn18 = __toESM(require_bn(), 1);
var import_bn19 = __toESM(require_bn(), 1);
var import_bn20 = __toESM(require_bn(), 1);
var import_bn21 = __toESM(require_bn(), 1);
var import_bn22 = __toESM(require_bn(), 1);
var import_bn23 = __toESM(require_bn(), 1);
var import_bn24 = __toESM(require_bn(), 1);
var import_bn25 = __toESM(require_bn(), 1);
var import_bn26 = __toESM(require_bn(), 1);

// ../../node_modules/.pnpm/@cetusprotocol+aggregator-sdk@0.6.0_@jest+transform@29.7.0_@jest+types@29.6.3_typescript@5.8.3/node_modules/@cetusprotocol/aggregator-sdk/dist/index.mjs
var import_pyth_sui_js = __toESM(require_lib3(), 1);
var __create3 = Object.create;
var __defProp3 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropNames3 = Object.getOwnPropertyNames;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __getProtoOf3 = Object.getPrototypeOf;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp3.call(b2, prop))
      __defNormalProp2(a, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b2) => __defProps2(a, __getOwnPropDescs2(b2));
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a, b2) => (typeof require !== "undefined" ? require : a)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __commonJS3 = (cb, mod22) => function __require2() {
  return mod22 || (0, cb[__getOwnPropNames3(cb)[0]])((mod22 = { exports: {} }).exports, mod22), mod22.exports;
};
var __copyProps3 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames3(from))
      if (!__hasOwnProp3.call(to, key) && key !== except)
        __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM3 = (mod22, isNodeMode, target) => (target = mod22 != null ? __create3(__getProtoOf3(mod22)) : {}, __copyProps3(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  !mod22 || !mod22.__esModule ? __defProp3(target, "default", { value: mod22, enumerable: true }) : target,
  mod22
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var require_bn2 = __commonJS3({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module22, exports22) {
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN8(number2, base2, endian) {
        if (BN8.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module22 === "object") {
        module22.exports = BN8;
      } else {
        exports22.BN = BN8;
      }
      BN8.BN = BN8;
      BN8.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = __require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN8.isBN = function isBN(num) {
        if (num instanceof BN8) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN8.wordSize && Array.isArray(num.words);
      };
      BN8.max = function max22(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN8.min = function min22(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN8.prototype._init = function init(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN8.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN8.prototype._initArray = function _initArray(number2, base2, endian) {
        assert(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j2, w2;
        var off = 0;
        if (endian === "be") {
          for (i = number2.length - 1, j2 = 0; i >= 0; i -= 3) {
            w2 = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j2 = 0; i < number2.length; i += 3) {
            w2 = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c = string2.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r2 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r2;
      }
      BN8.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j2 = 0;
        var w2;
        if (endian === "be") {
          for (i = number2.length - 1; i >= start; i -= 2) {
            w2 = parseHexByte(number2, start, i) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
            w2 = parseHexByte(number2, start, i) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul22) {
        var r2 = 0;
        var b2 = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r2 *= mul22;
          if (c >= 49) {
            b2 = c - 49 + 10;
          } else if (c >= 17) {
            b2 = c - 17 + 10;
          } else {
            b2 = c;
          }
          assert(c >= 0 && b2 < mul22, "Invalid character");
          r2 += b2;
        }
        return r2;
      }
      BN8.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod22 = total % limbLen;
        var end = Math.min(total, total - mod22) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number2, i, i + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod22 !== 0) {
          var pow22 = 1;
          word = parseBase(number2, i, number2.length, base2);
          for (i = 0; i < mod22; i++) {
            pow22 *= base2;
          }
          this.imuln(pow22);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN8.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN8.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN8.prototype.clone = function clone22() {
        var r2 = new BN8(null);
        this.copy(r2);
        return r2;
      };
      BN8.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN8.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN8.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN8.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN8.prototype.inspect = inspect;
        }
      } else {
        BN8.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN8.prototype.toString = function toString(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w2 = this.words[i];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r2 = c.modrn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN8.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN8.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN8.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN8.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN8.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN8.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN8.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN8.prototype._countBits = function _countBits(w2) {
          return 32 - Math.clz32(w2);
        };
      } else {
        BN8.prototype._countBits = function _countBits(w2) {
          var t = w2;
          var r2 = 0;
          if (t >= 4096) {
            r2 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r2 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r2 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r2 += 2;
            t >>>= 2;
          }
          return r2 + t;
        };
      }
      BN8.prototype._zeroBits = function _zeroBits(w2) {
        if (w2 === 0) return 26;
        var t = w2;
        var r2 = 0;
        if ((t & 8191) === 0) {
          r2 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r2 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r2 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r2 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN8.prototype.bitLength = function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi3 = this._countBits(w2);
        return (this.length - 1) * 26 + hi3;
      };
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = num.words[off] >>> wbit & 1;
        }
        return w2;
      }
      BN8.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r2 = 0;
        for (var i = 0; i < this.length; i++) {
          var b2 = this._zeroBits(this.words[i]);
          r2 += b2;
          if (b2 !== 26) break;
        }
        return r2;
      };
      BN8.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN8.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN8.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN8.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN8.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN8.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN8.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN8.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN8.prototype.or = function or2(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN8.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN8.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b2.length;
        return this._strip();
      };
      BN8.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN8.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN8.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN8.prototype.iuxor = function iuxor(num) {
        var a;
        var b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = a.words[i] ^ b2.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN8.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN8.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN8.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN8.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN8.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN8.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN8.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a, b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r2 = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN8.prototype.add = function add22(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN8.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp2 = this.cmp(num);
        if (cmp2 === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b2;
        if (cmp2 > 0) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r2 = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN8.prototype.sub = function sub22(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a * b2;
        var lo2 = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i = k2 - j2 | 0;
            a = self2.words[i] | 0;
            b2 = num.words[j2] | 0;
            r2 = a * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b2 = num.words;
        var o = out.words;
        var c = 0;
        var lo2;
        var mid;
        var hi3;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi3 = Math.imul(ah0, bh0);
        var w0 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi3 = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi3 = hi3 + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi3 = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi3 = hi3 + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi3 = hi3 + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi3 = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi3 = hi3 + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi3 = hi3 + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi3 = hi3 + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi3 = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi3 = hi3 + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi3 = hi3 + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi3 = hi3 + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi3 = hi3 + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi3 = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi3 = hi3 + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi3 = hi3 + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi3 = hi3 + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi3 = hi3 + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi3 = hi3 + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi3 = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi3 = hi3 + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi3 = hi3 + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi3 = hi3 + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi3 = hi3 + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi3 = hi3 + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi3 = hi3 + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi3 = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi3 = hi3 + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi3 = hi3 + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi3 = hi3 + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi3 = hi3 + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi3 = hi3 + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi3 = hi3 + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi3 = hi3 + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi3 = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi3 = hi3 + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi3 = hi3 + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi3 = hi3 + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi3 = hi3 + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi3 = hi3 + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi3 = hi3 + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi3 = hi3 + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi3 = hi3 + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi3 = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi3 = hi3 + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi3 = hi3 + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi3 = hi3 + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi3 = hi3 + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi3 = hi3 + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi3 = hi3 + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi3 = hi3 + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi3 = hi3 + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi3 = hi3 + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi3 = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi3 = hi3 + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi3 = hi3 + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi3 = hi3 + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi3 = hi3 + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi3 = hi3 + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi3 = hi3 + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi3 = hi3 + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi3 = hi3 + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi3 = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi3 = hi3 + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi3 = hi3 + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi3 = hi3 + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi3 = hi3 + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi3 = hi3 + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi3 = hi3 + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi3 = hi3 + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi3 = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi3 = hi3 + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi3 = hi3 + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi3 = hi3 + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi3 = hi3 + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi3 = hi3 + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi3 = hi3 + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi3 = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi3 = hi3 + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi3 = hi3 + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi3 = hi3 + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi3 = hi3 + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi3 = hi3 + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi3 = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi3 = hi3 + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi3 = hi3 + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi3 = hi3 + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi3 = hi3 + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi3 = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi3 = hi3 + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi3 = hi3 + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi3 = hi3 + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi3 = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi3 = hi3 + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi3 = hi3 + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi3 = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi3 = hi3 + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi3 = Math.imul(ah9, bh9);
        var w18 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c = (hi3 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i = k2 - j2;
            var a = self2.words[i] | 0;
            var b2 = num.words[j2] | 0;
            var r2 = a * b2;
            var lo2 = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN8.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      BN8.prototype.mul = function mul22(num) {
        var out = new BN8(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN8.prototype.mulf = function mulf(num) {
        var out = new BN8(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN8.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN8.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w2 = (this.words[i] | 0) * num;
          var lo2 = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN8.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN8.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN8.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN8.prototype.pow = function pow22(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0) return new BN8(1);
        var res = this;
        for (var i = 0; i < w2.length; i++, res = res.sqr()) {
          if (w2[i] !== 0) break;
        }
        if (++i < w2.length) {
          for (var q3 = res.sqr(); i < w2.length; i++, q3 = q3.sqr()) {
            if (w2[i] === 0) continue;
            res = res.mul(q3);
          }
        }
        return res;
      };
      BN8.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i;
        if (r2 !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r2;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN8.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN8.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r2 = bits % 26;
        var s = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN8.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN8.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN8.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN8.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN8.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN8.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q3 = 1 << r2;
        if (this.length <= s) return false;
        var w2 = this.words[s];
        return !!(w2 & q3);
      };
      BN8.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r2 !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN8.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN8.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN8.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN8.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN8.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN8.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN8.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN8.prototype.abs = function abs22() {
        return this.clone().iabs();
      };
      BN8.prototype._ishlnsubmul = function _ishlnsubmul(num, mul22, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w2 = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul22;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w2 & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w2 = (this.words[i + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i + shift] = w2 & 67108863;
        }
        if (carry === 0) return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w2 = -(this.words[i] | 0) + carry;
          carry = w2 >> 26;
          this.words[i] = w2 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN8.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m = a.length - b2.length;
        var q3;
        if (mode !== "mod") {
          q3 = new BN8(null);
          q3.length = m + 1;
          q3.words = new Array(q3.length);
          for (var i = 0; i < q3.length; i++) {
            q3.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b2, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q3) {
            q3.words[m] = 1;
          }
        }
        for (var j2 = m - 1; j2 >= 0; j2--) {
          var qj = (a.words[b2.length + j2] | 0) * 67108864 + (a.words[b2.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b2, qj, j2);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b2, 1, j2);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q3) {
            q3.words[j2] = qj;
          }
        }
        if (q3) {
          q3._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q3 || null,
          mod: a
        };
      };
      BN8.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN8(0),
            mod: new BN8(0)
          };
        }
        var div22, mod22, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div22 = res.div.neg();
          }
          if (mode !== "div") {
            mod22 = res.mod.neg();
            if (positive && mod22.negative !== 0) {
              mod22.iadd(num);
            }
          }
          return {
            div: div22,
            mod: mod22
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div22 = res.div.neg();
          }
          return {
            div: div22,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod22 = res.mod.neg();
            if (positive && mod22.negative !== 0) {
              mod22.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod22
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN8(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN8(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN8(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN8.prototype.div = function div22(num) {
        return this.divmod(num, "div", false).div;
      };
      BN8.prototype.mod = function mod22(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN8.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN8.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod22 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp2 = mod22.cmp(half);
        if (cmp2 < 0 || r2 === 1 && cmp2 === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN8.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN8.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN8.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w2 = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w2 / num | 0;
          carry = w2 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN8.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN8.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x2 = this;
        var y = p.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p);
        } else {
          x2 = x2.clone();
        }
        var A = new BN8(1);
        var B2 = new BN8(0);
        var C2 = new BN8(0);
        var D = new BN8(1);
        var g = 0;
        while (x2.isEven() && y.isEven()) {
          x2.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i = 0, im = 1; (x2.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x2.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B2.isOdd()) {
                A.iadd(yp);
                B2.isub(xp);
              }
              A.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            y.iushrn(j2);
            while (j2-- > 0) {
              if (C2.isOdd() || D.isOdd()) {
                C2.iadd(yp);
                D.isub(xp);
              }
              C2.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x2.cmp(y) >= 0) {
            x2.isub(y);
            A.isub(C2);
            B2.isub(D);
          } else {
            y.isub(x2);
            C2.isub(A);
            D.isub(B2);
          }
        }
        return {
          a: C2,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN8.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b2 = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN8(1);
        var x2 = new BN8(0);
        var delta = b2.clone();
        while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            b2.iushrn(j2);
            while (j2-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b2) >= 0) {
            a.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN8.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b2 = num.clone();
        a.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a.isEven() && b2.isEven(); shift++) {
          a.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a.cmp(b2);
          if (r2 < 0) {
            var t = a;
            a = b2;
            b2 = t;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN8.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN8.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN8.prototype.isOdd = function isOdd22() {
        return (this.words[0] & 1) === 1;
      };
      BN8.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN8.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q3 = 1 << r2;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q3;
          return this;
        }
        var carry = q3;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w2 = this.words[i] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i] = w2;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN8.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN8.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN8.prototype.cmp = function cmp2(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN8.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b2 = num.words[i] | 0;
          if (a === b2) continue;
          if (a < b2) {
            res = -1;
          } else if (a > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN8.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN8.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN8.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN8.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN8.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN8.prototype.lt = function lt2(num) {
        return this.cmp(num) === -1;
      };
      BN8.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN8.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN8.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN8.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN8.red = function red(num) {
        return new Red(num);
      };
      BN8.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN8.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN8.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN8.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN8.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN8.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN8.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN8.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN8.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN8.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN8.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN8.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN8.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN8.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN8.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN8.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN8.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN8(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN8(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN8(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp2 = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp2 === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp2 > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i = 0; i < num.length; i++) {
          var w2 = num.words[i] | 0;
          lo2 += w2 * 977;
          num.words[i] = lo2 & 67108863;
          lo2 = w2 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi3 = (num.words[i] | 0) * 19 + carry;
          var lo2 = hi3 & 67108863;
          hi3 >>>= 26;
          num.words[i] = lo2;
          carry = hi3;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN8._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN8._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b2) {
        assert((a.negative | b2.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add22(a, b2) {
        this._verify2(a, b2);
        var res = a.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b2) {
        this._verify2(a, b2);
        var res = a.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub22(a, b2) {
        this._verify2(a, b2);
        var res = a.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b2) {
        this._verify2(a, b2);
        var res = a.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.imul(b2));
      };
      Red.prototype.mul = function mul22(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.mul(b2));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt22(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow22 = this.m.add(new BN8(1)).iushrn(2);
          return this.pow(a, pow22);
        }
        var q3 = this.m.subn(1);
        var s = 0;
        while (!q3.isZero() && q3.andln(1) === 0) {
          s++;
          q3.iushrn(1);
        }
        assert(!q3.isZero());
        var one = new BN8(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN8(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q3);
        var r2 = this.pow(a, q3.addn(1).iushrn(1));
        var t = this.pow(a, q3);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b2 = this.pow(c, new BN8(1).iushln(m - i - 1));
          r2 = r2.redMul(b2);
          c = b2.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow22(a, num) {
        if (num.isZero()) return new BN8(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN8(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j2 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN8.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN8(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b2) {
        if (a.isZero() || b2.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul22(a, b2) {
        if (a.isZero() || b2.isZero()) return new BN8(0)._forceRed(this);
        var t = a.mul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});
var EXP_LIMIT2 = 9e15;
var MAX_DIGITS2 = 1e9;
var NUMERALS2 = "0123456789abcdef";
var LN102 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI2 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS2 = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT2,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT2,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var inexact2;
var quadrant2;
var external2 = true;
var decimalError2 = "[DecimalError] ";
var invalidArgument2 = decimalError2 + "Invalid argument: ";
var precisionLimitExceeded2 = decimalError2 + "Precision limit exceeded";
var cryptoUnavailable2 = decimalError2 + "crypto unavailable";
var tag2 = "[object Decimal]";
var mathfloor2 = Math.floor;
var mathpow2 = Math.pow;
var isBinary2 = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex3 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal2 = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal2 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE2 = 1e7;
var LOG_BASE2 = 7;
var MAX_SAFE_INTEGER2 = 9007199254740991;
var LN10_PRECISION2 = LN102.length - 1;
var PI_PRECISION2 = PI2.length - 1;
var P2 = { toStringTag: tag2 };
P2.absoluteValue = P2.abs = function() {
  var x2 = new this.constructor(this);
  if (x2.s < 0) x2.s = 1;
  return finalise2(x2);
};
P2.ceil = function() {
  return finalise2(new this.constructor(this), this.e + 1, 2);
};
P2.clampedTo = P2.clamp = function(min22, max22) {
  var k2, x2 = this, Ctor = x2.constructor;
  min22 = new Ctor(min22);
  max22 = new Ctor(max22);
  if (!min22.s || !max22.s) return new Ctor(NaN);
  if (min22.gt(max22)) throw Error(invalidArgument2 + max22);
  k2 = x2.cmp(min22);
  return k2 < 0 ? min22 : x2.cmp(max22) > 0 ? max22 : new Ctor(x2);
};
P2.comparedTo = P2.cmp = function(y) {
  var i, j2, xdL, ydL, x2 = this, xd = x2.d, yd = (y = new x2.constructor(y)).d, xs = x2.s, ys2 = y.s;
  if (!xd || !yd) {
    return !xs || !ys2 ? NaN : xs !== ys2 ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys2 : 0;
  if (xs !== ys2) return xs;
  if (x2.e !== y.e) return x2.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j2 = xdL < ydL ? xdL : ydL; i < j2; ++i) {
    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P2.cosine = P2.cos = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.d) return new Ctor(NaN);
  if (!x2.d[0]) return new Ctor(1);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + Math.max(x2.e, x2.sd()) + LOG_BASE2;
  Ctor.rounding = 1;
  x2 = cosine2(Ctor, toLessThanHalfPi2(Ctor, x2));
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return finalise2(quadrant2 == 2 || quadrant2 == 3 ? x2.neg() : x2, pr2, rm, true);
};
P2.cubeRoot = P2.cbrt = function() {
  var e, m, n, r2, rep, s, sd, t, t3, t3plusx, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero()) return new Ctor(x2);
  external2 = false;
  s = x2.s * mathpow2(x2.s * x2, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString2(x2.d);
    e = x2.e;
    if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow2(n, 1 / 3);
    e = mathfloor2((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r2 = new Ctor(n);
    r2.s = x2.s;
  } else {
    r2 = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r2;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x2);
    r2 = divide2(t3plusx.plus(x2).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString2(t.d).slice(0, sd) === (n = digitsToString2(r2.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise2(t, e + 1, 0);
          if (t.times(t).times(t).eq(x2)) {
            r2 = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise2(r2, e + 1, 1);
          m = !r2.times(r2).times(r2).eq(x2);
        }
        break;
      }
    }
  }
  external2 = true;
  return finalise2(r2, e, Ctor.rounding, m);
};
P2.decimalPlaces = P2.dp = function() {
  var w2, d = this.d, n = NaN;
  if (d) {
    w2 = d.length - 1;
    n = (w2 - mathfloor2(this.e / LOG_BASE2)) * LOG_BASE2;
    w2 = d[w2];
    if (w2) for (; w2 % 10 == 0; w2 /= 10) n--;
    if (n < 0) n = 0;
  }
  return n;
};
P2.dividedBy = P2.div = function(y) {
  return divide2(this, new this.constructor(y));
};
P2.dividedToIntegerBy = P2.divToInt = function(y) {
  var x2 = this, Ctor = x2.constructor;
  return finalise2(divide2(x2, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P2.equals = P2.eq = function(y) {
  return this.cmp(y) === 0;
};
P2.floor = function() {
  return finalise2(new this.constructor(this), this.e + 1, 3);
};
P2.greaterThan = P2.gt = function(y) {
  return this.cmp(y) > 0;
};
P2.greaterThanOrEqualTo = P2.gte = function(y) {
  var k2 = this.cmp(y);
  return k2 == 1 || k2 === 0;
};
P2.hyperbolicCosine = P2.cosh = function() {
  var k2, n, pr2, rm, len, x2 = this, Ctor = x2.constructor, one = new Ctor(1);
  if (!x2.isFinite()) return new Ctor(x2.s ? 1 / 0 : NaN);
  if (x2.isZero()) return one;
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + Math.max(x2.e, x2.sd()) + 4;
  Ctor.rounding = 1;
  len = x2.d.length;
  if (len < 32) {
    k2 = Math.ceil(len / 3);
    n = (1 / tinyPow2(4, k2)).toString();
  } else {
    k2 = 16;
    n = "2.3283064365386962890625e-10";
  }
  x2 = taylorSeries2(Ctor, 1, x2.times(n), new Ctor(1), true);
  var cosh2_x, i = k2, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x2.times(x2);
    x2 = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise2(x2, Ctor.precision = pr2, Ctor.rounding = rm, true);
};
P2.hyperbolicSine = P2.sinh = function() {
  var k2, pr2, rm, len, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + Math.max(x2.e, x2.sd()) + 4;
  Ctor.rounding = 1;
  len = x2.d.length;
  if (len < 3) {
    x2 = taylorSeries2(Ctor, 2, x2, x2, true);
  } else {
    k2 = 1.4 * Math.sqrt(len);
    k2 = k2 > 16 ? 16 : k2 | 0;
    x2 = x2.times(1 / tinyPow2(5, k2));
    x2 = taylorSeries2(Ctor, 2, x2, x2, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k2--; ) {
      sinh2_x = x2.times(x2);
      x2 = x2.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return finalise2(x2, pr2, rm, true);
};
P2.hyperbolicTangent = P2.tanh = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite()) return new Ctor(x2.s);
  if (x2.isZero()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + 7;
  Ctor.rounding = 1;
  return divide2(x2.sinh(), x2.cosh(), Ctor.precision = pr2, Ctor.rounding = rm);
};
P2.inverseCosine = P2.acos = function() {
  var halfPi, x2 = this, Ctor = x2.constructor, k2 = x2.abs().cmp(1), pr2 = Ctor.precision, rm = Ctor.rounding;
  if (k2 !== -1) {
    return k2 === 0 ? x2.isNeg() ? getPi2(Ctor, pr2, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x2.isZero()) return getPi2(Ctor, pr2 + 4, rm).times(0.5);
  Ctor.precision = pr2 + 6;
  Ctor.rounding = 1;
  x2 = x2.asin();
  halfPi = getPi2(Ctor, pr2 + 4, rm).times(0.5);
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return halfPi.minus(x2);
};
P2.inverseHyperbolicCosine = P2.acosh = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (x2.lte(1)) return new Ctor(x2.eq(1) ? 0 : NaN);
  if (!x2.isFinite()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + Math.max(Math.abs(x2.e), x2.sd()) + 4;
  Ctor.rounding = 1;
  external2 = false;
  x2 = x2.times(x2).minus(1).sqrt().plus(x2);
  external2 = true;
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return x2.ln();
};
P2.inverseHyperbolicSine = P2.asinh = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite() || x2.isZero()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + 2 * Math.max(Math.abs(x2.e), x2.sd()) + 6;
  Ctor.rounding = 1;
  external2 = false;
  x2 = x2.times(x2).plus(1).sqrt().plus(x2);
  external2 = true;
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return x2.ln();
};
P2.inverseHyperbolicTangent = P2.atanh = function() {
  var pr2, rm, wpr, xsd, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite()) return new Ctor(NaN);
  if (x2.e >= 0) return new Ctor(x2.abs().eq(1) ? x2.s / 0 : x2.isZero() ? x2 : NaN);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x2.sd();
  if (Math.max(xsd, pr2) < 2 * -x2.e - 1) return finalise2(new Ctor(x2), pr2, rm, true);
  Ctor.precision = wpr = xsd - x2.e;
  x2 = divide2(x2.plus(1), new Ctor(1).minus(x2), wpr + pr2, 1);
  Ctor.precision = pr2 + 4;
  Ctor.rounding = 1;
  x2 = x2.ln();
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return x2.times(0.5);
};
P2.inverseSine = P2.asin = function() {
  var halfPi, k2, pr2, rm, x2 = this, Ctor = x2.constructor;
  if (x2.isZero()) return new Ctor(x2);
  k2 = x2.abs().cmp(1);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  if (k2 !== -1) {
    if (k2 === 0) {
      halfPi = getPi2(Ctor, pr2 + 4, rm).times(0.5);
      halfPi.s = x2.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr2 + 6;
  Ctor.rounding = 1;
  x2 = x2.div(new Ctor(1).minus(x2.times(x2)).sqrt().plus(1)).atan();
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return x2.times(2);
};
P2.inverseTangent = P2.atan = function() {
  var i, j2, k2, n, px, t, r2, wpr, x2, x3 = this, Ctor = x3.constructor, pr2 = Ctor.precision, rm = Ctor.rounding;
  if (!x3.isFinite()) {
    if (!x3.s) return new Ctor(NaN);
    if (pr2 + 4 <= PI_PRECISION2) {
      r2 = getPi2(Ctor, pr2 + 4, rm).times(0.5);
      r2.s = x3.s;
      return r2;
    }
  } else if (x3.isZero()) {
    return new Ctor(x3);
  } else if (x3.abs().eq(1) && pr2 + 4 <= PI_PRECISION2) {
    r2 = getPi2(Ctor, pr2 + 4, rm).times(0.25);
    r2.s = x3.s;
    return r2;
  }
  Ctor.precision = wpr = pr2 + 10;
  Ctor.rounding = 1;
  k2 = Math.min(28, wpr / LOG_BASE2 + 2 | 0);
  for (i = k2; i; --i) x3 = x3.div(x3.times(x3).plus(1).sqrt().plus(1));
  external2 = false;
  j2 = Math.ceil(wpr / LOG_BASE2);
  n = 1;
  x2 = x3.times(x3);
  r2 = new Ctor(x3);
  px = x3;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r2.minus(px.div(n += 2));
    px = px.times(x2);
    r2 = t.plus(px.div(n += 2));
    if (r2.d[j2] !== void 0) for (i = j2; r2.d[i] === t.d[i] && i--; ) ;
  }
  if (k2) r2 = r2.times(2 << k2 - 1);
  external2 = true;
  return finalise2(r2, Ctor.precision = pr2, Ctor.rounding = rm, true);
};
P2.isFinite = function() {
  return !!this.d;
};
P2.isInteger = P2.isInt = function() {
  return !!this.d && mathfloor2(this.e / LOG_BASE2) > this.d.length - 2;
};
P2.isNaN = function() {
  return !this.s;
};
P2.isNegative = P2.isNeg = function() {
  return this.s < 0;
};
P2.isPositive = P2.isPos = function() {
  return this.s > 0;
};
P2.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P2.lessThan = P2.lt = function(y) {
  return this.cmp(y) < 0;
};
P2.lessThanOrEqualTo = P2.lte = function(y) {
  return this.cmp(y) < 1;
};
P2.logarithm = P2.log = function(base2) {
  var isBase10, d, denominator, k2, inf, num, sd, r2, arg = this, Ctor = arg.constructor, pr2 = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base2 == null) {
    base2 = new Ctor(10);
    isBase10 = true;
  } else {
    base2 = new Ctor(base2);
    d = base2.d;
    if (base2.s < 0 || !d || !d[0] || base2.eq(1)) return new Ctor(NaN);
    isBase10 = base2.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k2 = d[0]; k2 % 10 === 0; ) k2 /= 10;
      inf = k2 !== 1;
    }
  }
  external2 = false;
  sd = pr2 + guard;
  num = naturalLogarithm2(arg, sd);
  denominator = isBase10 ? getLn102(Ctor, sd + 10) : naturalLogarithm2(base2, sd);
  r2 = divide2(num, denominator, sd, 1);
  if (checkRoundingDigits2(r2.d, k2 = pr2, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm2(arg, sd);
      denominator = isBase10 ? getLn102(Ctor, sd + 10) : naturalLogarithm2(base2, sd);
      r2 = divide2(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString2(r2.d).slice(k2 + 1, k2 + 15) + 1 == 1e14) {
          r2 = finalise2(r2, pr2 + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits2(r2.d, k2 += 10, rm));
  }
  external2 = true;
  return finalise2(r2, pr2, rm);
};
P2.minus = P2.sub = function(y) {
  var d, e, i, j2, k2, len, pr2, rm, xd, xe3, xLTy, yd, x2 = this, Ctor = x2.constructor;
  y = new Ctor(y);
  if (!x2.d || !y.d) {
    if (!x2.s || !y.s) y = new Ctor(NaN);
    else if (x2.d) y.s = -y.s;
    else y = new Ctor(y.d || x2.s !== y.s ? x2 : NaN);
    return y;
  }
  if (x2.s != y.s) {
    y.s = -y.s;
    return x2.plus(y);
  }
  xd = x2.d;
  yd = y.d;
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0]) y.s = -y.s;
    else if (xd[0]) y = new Ctor(x2);
    else return new Ctor(rm === 3 ? -0 : 0);
    return external2 ? finalise2(y, pr2, rm) : y;
  }
  e = mathfloor2(y.e / LOG_BASE2);
  xe3 = mathfloor2(x2.e / LOG_BASE2);
  xd = xd.slice();
  k2 = xe3 - e;
  if (k2) {
    xLTy = k2 < 0;
    if (xLTy) {
      d = xd;
      k2 = -k2;
      len = yd.length;
    } else {
      d = yd;
      e = xe3;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr2 / LOG_BASE2), len) + 2;
    if (k2 > i) {
      k2 = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k2; i--; ) d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k2 = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
  for (i = yd.length; i > k2; ) {
    if (xd[--i] < yd[i]) {
      for (j2 = i; j2 && xd[--j2] === 0; ) xd[j2] = BASE2 - 1;
      --xd[j2];
      xd[i] += BASE2;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; ) xd.pop();
  for (; xd[0] === 0; xd.shift()) --e;
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent2(xd, e);
  return external2 ? finalise2(y, pr2, rm) : y;
};
P2.modulo = P2.mod = function(y) {
  var q3, x2 = this, Ctor = x2.constructor;
  y = new Ctor(y);
  if (!x2.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
  if (!y.d || x2.d && !x2.d[0]) {
    return finalise2(new Ctor(x2), Ctor.precision, Ctor.rounding);
  }
  external2 = false;
  if (Ctor.modulo == 9) {
    q3 = divide2(x2, y.abs(), 0, 3, 1);
    q3.s *= y.s;
  } else {
    q3 = divide2(x2, y, 0, Ctor.modulo, 1);
  }
  q3 = q3.times(y);
  external2 = true;
  return x2.minus(q3);
};
P2.naturalExponential = P2.exp = function() {
  return naturalExponential2(this);
};
P2.naturalLogarithm = P2.ln = function() {
  return naturalLogarithm2(this);
};
P2.negated = P2.neg = function() {
  var x2 = new this.constructor(this);
  x2.s = -x2.s;
  return finalise2(x2);
};
P2.plus = P2.add = function(y) {
  var carry, d, e, i, k2, len, pr2, rm, xd, yd, x2 = this, Ctor = x2.constructor;
  y = new Ctor(y);
  if (!x2.d || !y.d) {
    if (!x2.s || !y.s) y = new Ctor(NaN);
    else if (!x2.d) y = new Ctor(y.d || x2.s === y.s ? x2 : NaN);
    return y;
  }
  if (x2.s != y.s) {
    y.s = -y.s;
    return x2.minus(y);
  }
  xd = x2.d;
  yd = y.d;
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0]) y = new Ctor(x2);
    return external2 ? finalise2(y, pr2, rm) : y;
  }
  k2 = mathfloor2(x2.e / LOG_BASE2);
  e = mathfloor2(y.e / LOG_BASE2);
  xd = xd.slice();
  i = k2 - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k2;
      len = xd.length;
    }
    k2 = Math.ceil(pr2 / LOG_BASE2);
    len = k2 > len ? k2 + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; ) d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE2 | 0;
    xd[i] %= BASE2;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop();
  y.d = xd;
  y.e = getBase10Exponent2(xd, e);
  return external2 ? finalise2(y, pr2, rm) : y;
};
P2.precision = P2.sd = function(z) {
  var k2, x2 = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument2 + z);
  if (x2.d) {
    k2 = getPrecision2(x2.d);
    if (z && x2.e + 1 > k2) k2 = x2.e + 1;
  } else {
    k2 = NaN;
  }
  return k2;
};
P2.round = function() {
  var x2 = this, Ctor = x2.constructor;
  return finalise2(new Ctor(x2), x2.e + 1, Ctor.rounding);
};
P2.sine = P2.sin = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite()) return new Ctor(NaN);
  if (x2.isZero()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + Math.max(x2.e, x2.sd()) + LOG_BASE2;
  Ctor.rounding = 1;
  x2 = sine2(Ctor, toLessThanHalfPi2(Ctor, x2));
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return finalise2(quadrant2 > 2 ? x2.neg() : x2, pr2, rm, true);
};
P2.squareRoot = P2.sqrt = function() {
  var m, n, sd, r2, rep, t, x2 = this, d = x2.d, e = x2.e, s = x2.s, Ctor = x2.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x2 : 1 / 0);
  }
  external2 = false;
  s = Math.sqrt(+x2);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString2(d);
    if ((n.length + e) % 2 == 0) n += "0";
    s = Math.sqrt(n);
    e = mathfloor2((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r2 = new Ctor(n);
  } else {
    r2 = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r2;
    r2 = t.plus(divide2(x2, t, sd + 2, 1)).times(0.5);
    if (digitsToString2(t.d).slice(0, sd) === (n = digitsToString2(r2.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise2(t, e + 1, 0);
          if (t.times(t).eq(x2)) {
            r2 = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise2(r2, e + 1, 1);
          m = !r2.times(r2).eq(x2);
        }
        break;
      }
    }
  }
  external2 = true;
  return finalise2(r2, e, Ctor.rounding, m);
};
P2.tangent = P2.tan = function() {
  var pr2, rm, x2 = this, Ctor = x2.constructor;
  if (!x2.isFinite()) return new Ctor(NaN);
  if (x2.isZero()) return new Ctor(x2);
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr2 + 10;
  Ctor.rounding = 1;
  x2 = x2.sin();
  x2.s = 1;
  x2 = divide2(x2, new Ctor(1).minus(x2.times(x2)).sqrt(), pr2 + 10, 0);
  Ctor.precision = pr2;
  Ctor.rounding = rm;
  return finalise2(quadrant2 == 2 || quadrant2 == 4 ? x2.neg() : x2, pr2, rm, true);
};
P2.times = P2.mul = function(y) {
  var carry, e, i, k2, r2, rL, t, xdL, ydL, x2 = this, Ctor = x2.constructor, xd = x2.d, yd = (y = new Ctor(y)).d;
  y.s *= x2.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor2(x2.e / LOG_BASE2) + mathfloor2(y.e / LOG_BASE2);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r2 = xd;
    xd = yd;
    yd = r2;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r2 = [];
  rL = xdL + ydL;
  for (i = rL; i--; ) r2.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k2 = xdL + i; k2 > i; ) {
      t = r2[k2] + yd[i] * xd[k2 - i - 1] + carry;
      r2[k2--] = t % BASE2 | 0;
      carry = t / BASE2 | 0;
    }
    r2[k2] = (r2[k2] + carry) % BASE2 | 0;
  }
  for (; !r2[--rL]; ) r2.pop();
  if (carry) ++e;
  else r2.shift();
  y.d = r2;
  y.e = getBase10Exponent2(r2, e);
  return external2 ? finalise2(y, Ctor.precision, Ctor.rounding) : y;
};
P2.toBinary = function(sd, rm) {
  return toStringBinary2(this, 2, sd, rm);
};
P2.toDecimalPlaces = P2.toDP = function(dp, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (dp === void 0) return x2;
  checkInt322(dp, 0, MAX_DIGITS2);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt322(rm, 0, 8);
  return finalise2(x2, dp + x2.e + 1, rm);
};
P2.toExponential = function(dp, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = finiteToString2(x2, true);
  } else {
    checkInt322(dp, 0, MAX_DIGITS2);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt322(rm, 0, 8);
    x2 = finalise2(new Ctor(x2), dp + 1, rm);
    str = finiteToString2(x2, true, dp + 1);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P2.toFixed = function(dp, rm) {
  var str, y, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = finiteToString2(x2);
  } else {
    checkInt322(dp, 0, MAX_DIGITS2);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt322(rm, 0, 8);
    y = finalise2(new Ctor(x2), dp + x2.e + 1, rm);
    str = finiteToString2(y, false, dp + y.e + 1);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P2.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k2, n, n0, n1, pr2, q3, r2, x2 = this, xd = x2.d, Ctor = x2.constructor;
  if (!xd) return new Ctor(x2);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision2(xd) - x2.e - 1;
  k2 = e % LOG_BASE2;
  d.d[0] = mathpow2(10, k2 < 0 ? LOG_BASE2 + k2 : k2);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument2 + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external2 = false;
  n = new Ctor(digitsToString2(xd));
  pr2 = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE2 * 2;
  for (; ; ) {
    q3 = divide2(n, d, 0, 1, 1);
    d2 = d0.plus(q3.times(d1));
    if (d2.cmp(maxD) == 1) break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q3.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q3.times(d2));
    n = d2;
  }
  d2 = divide2(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x2.s;
  r2 = divide2(n1, d1, e, 1).minus(x2).abs().cmp(divide2(n0, d0, e, 1).minus(x2).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr2;
  external2 = true;
  return r2;
};
P2.toHexadecimal = P2.toHex = function(sd, rm) {
  return toStringBinary2(this, 16, sd, rm);
};
P2.toNearest = function(y, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (y == null) {
    if (!x2.d) return x2;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt322(rm, 0, 8);
    }
    if (!x2.d) return y.s ? x2 : y;
    if (!y.d) {
      if (y.s) y.s = x2.s;
      return y;
    }
  }
  if (y.d[0]) {
    external2 = false;
    x2 = divide2(x2, y, 0, rm, 1).times(y);
    external2 = true;
    finalise2(x2);
  } else {
    y.s = x2.s;
    x2 = y;
  }
  return x2;
};
P2.toNumber = function() {
  return +this;
};
P2.toOctal = function(sd, rm) {
  return toStringBinary2(this, 8, sd, rm);
};
P2.toPower = P2.pow = function(y) {
  var e, k2, pr2, r2, rm, s, x2 = this, Ctor = x2.constructor, yn3 = +(y = new Ctor(y));
  if (!x2.d || !y.d || !x2.d[0] || !y.d[0]) return new Ctor(mathpow2(+x2, yn3));
  x2 = new Ctor(x2);
  if (x2.eq(1)) return x2;
  pr2 = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1)) return finalise2(x2, pr2, rm);
  e = mathfloor2(y.e / LOG_BASE2);
  if (e >= y.d.length - 1 && (k2 = yn3 < 0 ? -yn3 : yn3) <= MAX_SAFE_INTEGER2) {
    r2 = intPow2(Ctor, x2, k2, pr2);
    return y.s < 0 ? new Ctor(1).div(r2) : finalise2(r2, pr2, rm);
  }
  s = x2.s;
  if (s < 0) {
    if (e < y.d.length - 1) return new Ctor(NaN);
    if ((y.d[e] & 1) == 0) s = 1;
    if (x2.e == 0 && x2.d[0] == 1 && x2.d.length == 1) {
      x2.s = s;
      return x2;
    }
  }
  k2 = mathpow2(+x2, yn3);
  e = k2 == 0 || !isFinite(k2) ? mathfloor2(yn3 * (Math.log("0." + digitsToString2(x2.d)) / Math.LN10 + x2.e + 1)) : new Ctor(k2 + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
  external2 = false;
  Ctor.rounding = x2.s = 1;
  k2 = Math.min(12, (e + "").length);
  r2 = naturalExponential2(y.times(naturalLogarithm2(x2, pr2 + k2)), pr2);
  if (r2.d) {
    r2 = finalise2(r2, pr2 + 5, 1);
    if (checkRoundingDigits2(r2.d, pr2, rm)) {
      e = pr2 + 10;
      r2 = finalise2(naturalExponential2(y.times(naturalLogarithm2(x2, e + k2)), e), e + 5, 1);
      if (+digitsToString2(r2.d).slice(pr2 + 1, pr2 + 15) + 1 == 1e14) {
        r2 = finalise2(r2, pr2 + 1, 0);
      }
    }
  }
  r2.s = s;
  external2 = true;
  Ctor.rounding = rm;
  return finalise2(r2, pr2, rm);
};
P2.toPrecision = function(sd, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    str = finiteToString2(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  } else {
    checkInt322(sd, 1, MAX_DIGITS2);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt322(rm, 0, 8);
    x2 = finalise2(new Ctor(x2), sd, rm);
    str = finiteToString2(x2, sd <= x2.e || x2.e <= Ctor.toExpNeg, sd);
  }
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P2.toSignificantDigits = P2.toSD = function(sd, rm) {
  var x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt322(sd, 1, MAX_DIGITS2);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt322(rm, 0, 8);
  }
  return finalise2(new Ctor(x2), sd, rm);
};
P2.toString = function() {
  var x2 = this, Ctor = x2.constructor, str = finiteToString2(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  return x2.isNeg() && !x2.isZero() ? "-" + str : str;
};
P2.truncated = P2.trunc = function() {
  return finalise2(new this.constructor(this), this.e + 1, 1);
};
P2.valueOf = P2.toJSON = function() {
  var x2 = this, Ctor = x2.constructor, str = finiteToString2(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
  return x2.isNeg() ? "-" + str : str;
};
function digitsToString2(d) {
  var i, k2, ws, indexOfLastWord = d.length - 1, str = "", w2 = d[0];
  if (indexOfLastWord > 0) {
    str += w2;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k2 = LOG_BASE2 - ws.length;
      if (k2) str += getZeroString2(k2);
      str += ws;
    }
    w2 = d[i];
    ws = w2 + "";
    k2 = LOG_BASE2 - ws.length;
    if (k2) str += getZeroString2(k2);
  } else if (w2 === 0) {
    return "0";
  }
  for (; w2 % 10 === 0; ) w2 /= 10;
  return str + w2;
}
function checkInt322(i, min22, max22) {
  if (i !== ~~i || i < min22 || i > max22) {
    throw Error(invalidArgument2 + i);
  }
}
function checkRoundingDigits2(d, i, rm, repeating) {
  var di, k2, r2, rd;
  for (k2 = d[0]; k2 >= 10; k2 /= 10) --i;
  if (--i < 0) {
    i += LOG_BASE2;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE2);
    i %= LOG_BASE2;
  }
  k2 = mathpow2(10, LOG_BASE2 - i);
  rd = d[di] % k2 | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0) rd = rd / 100 | 0;
      else if (i == 1) rd = rd / 10 | 0;
      r2 = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r2 = (rm < 4 && rd + 1 == k2 || rm > 3 && rd + 1 == k2 / 2) && (d[di + 1] / k2 / 100 | 0) == mathpow2(10, i - 2) - 1 || (rd == k2 / 2 || rd == 0) && (d[di + 1] / k2 / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0) rd = rd / 1e3 | 0;
      else if (i == 1) rd = rd / 100 | 0;
      else if (i == 2) rd = rd / 10 | 0;
      r2 = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r2 = ((repeating || rm < 4) && rd + 1 == k2 || !repeating && rm > 3 && rd + 1 == k2 / 2) && (d[di + 1] / k2 / 1e3 | 0) == mathpow2(10, i - 3) - 1;
    }
  }
  return r2;
}
function convertBase2(str, baseIn, baseOut) {
  var j2, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
    arr[0] += NUMERALS2.indexOf(str.charAt(i++));
    for (j2 = 0; j2 < arr.length; j2++) {
      if (arr[j2] > baseOut - 1) {
        if (arr[j2 + 1] === void 0) arr[j2 + 1] = 0;
        arr[j2 + 1] += arr[j2] / baseOut | 0;
        arr[j2] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine2(Ctor, x2) {
  var k2, len, y;
  if (x2.isZero()) return x2;
  len = x2.d.length;
  if (len < 32) {
    k2 = Math.ceil(len / 3);
    y = (1 / tinyPow2(4, k2)).toString();
  } else {
    k2 = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k2;
  x2 = taylorSeries2(Ctor, 1, x2.times(y), new Ctor(1));
  for (var i = k2; i--; ) {
    var cos2x = x2.times(x2);
    x2 = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k2;
  return x2;
}
var divide2 = /* @__PURE__ */ function() {
  function multiplyInteger(x2, k2, base2) {
    var temp, carry = 0, i = x2.length;
    for (x2 = x2.slice(); i--; ) {
      temp = x2[i] * k2 + carry;
      x2[i] = temp % base2 | 0;
      carry = temp / base2 | 0;
    }
    if (carry) x2.unshift(carry);
    return x2;
  }
  function compare2(a, b2, aL, bL) {
    var i, r2;
    if (aL != bL) {
      r2 = aL > bL ? 1 : -1;
    } else {
      for (i = r2 = 0; i < aL; i++) {
        if (a[i] != b2[i]) {
          r2 = a[i] > b2[i] ? 1 : -1;
          break;
        }
      }
    }
    return r2;
  }
  function subtract(a, b2, aL, base2) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b2[aL] ? 1 : 0;
      a[aL] = i * base2 + a[aL] - b2[aL];
    }
    for (; !a[0] && a.length > 1; ) a.shift();
  }
  return function(x2, y, pr2, rm, dp, base2) {
    var cmp2, e, i, k2, logBase, more, prod, prodL, q3, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x2.constructor, sign22 = x2.s == y.s ? 1 : -1, xd = x2.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x2.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign22 * 0 : sign22 / 0
        )
      );
    }
    if (base2) {
      logBase = 1;
      e = x2.e - y.e;
    } else {
      base2 = BASE2;
      logBase = LOG_BASE2;
      e = mathfloor2(x2.e / logBase) - mathfloor2(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q3 = new Ctor(sign22);
    qd = q3.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++) ;
    if (yd[i] > (xd[i] || 0)) e--;
    if (pr2 == null) {
      sd = pr2 = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr2 + (x2.e - y.e) + 1;
    } else {
      sd = pr2;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k2 = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k2) && sd--; i++) {
          t = k2 * base2 + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k2 = t % yd | 0;
        }
        more = k2 || i < xL;
      } else {
        k2 = base2 / (yd[0] + 1) | 0;
        if (k2 > 1) {
          yd = multiplyInteger(yd, k2, base2);
          xd = multiplyInteger(xd, k2, base2);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; ) rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base2 / 2) ++yd0;
        do {
          k2 = 0;
          cmp2 = compare2(yd, rem, yL, remL);
          if (cmp2 < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base2 + (rem[1] || 0);
            k2 = rem0 / yd0 | 0;
            if (k2 > 1) {
              if (k2 >= base2) k2 = base2 - 1;
              prod = multiplyInteger(yd, k2, base2);
              prodL = prod.length;
              remL = rem.length;
              cmp2 = compare2(prod, rem, prodL, remL);
              if (cmp2 == 1) {
                k2--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base2);
              }
            } else {
              if (k2 == 0) cmp2 = k2 = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL) prod.unshift(0);
            subtract(rem, prod, remL, base2);
            if (cmp2 == -1) {
              remL = rem.length;
              cmp2 = compare2(yd, rem, yL, remL);
              if (cmp2 < 1) {
                k2++;
                subtract(rem, yL < remL ? yz : yd, remL, base2);
              }
            }
            remL = rem.length;
          } else if (cmp2 === 0) {
            k2++;
            rem = [0];
          }
          qd[i++] = k2;
          if (cmp2 && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0]) qd.shift();
    }
    if (logBase == 1) {
      q3.e = e;
      inexact2 = more;
    } else {
      for (i = 1, k2 = qd[0]; k2 >= 10; k2 /= 10) i++;
      q3.e = i + e * logBase - 1;
      finalise2(q3, dp ? pr2 + q3.e + 1 : pr2, rm, more);
    }
    return q3;
  };
}();
function finalise2(x2, sd, rm, isTruncated) {
  var digits, i, j2, k2, rd, roundUp, w2, xd, xdi, Ctor = x2.constructor;
  out: if (sd != null) {
    xd = x2.d;
    if (!xd) return x2;
    for (digits = 1, k2 = xd[0]; k2 >= 10; k2 /= 10) digits++;
    i = sd - digits;
    if (i < 0) {
      i += LOG_BASE2;
      j2 = sd;
      w2 = xd[xdi = 0];
      rd = w2 / mathpow2(10, digits - j2 - 1) % 10 | 0;
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE2);
      k2 = xd.length;
      if (xdi >= k2) {
        if (isTruncated) {
          for (; k2++ <= xdi; ) xd.push(0);
          w2 = rd = 0;
          digits = 1;
          i %= LOG_BASE2;
          j2 = i - LOG_BASE2 + 1;
        } else {
          break out;
        }
      } else {
        w2 = k2 = xd[xdi];
        for (digits = 1; k2 >= 10; k2 /= 10) digits++;
        i %= LOG_BASE2;
        j2 = i - LOG_BASE2 + digits;
        rd = j2 < 0 ? 0 : w2 / mathpow2(10, digits - j2 - 1) % 10 | 0;
      }
    }
    isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j2 < 0 ? w2 : w2 % mathpow2(10, digits - j2 - 1));
    roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j2 > 0 ? w2 / mathpow2(10, digits - j2) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
    if (sd < 1 || !xd[0]) {
      xd.length = 0;
      if (roundUp) {
        sd -= x2.e + 1;
        xd[0] = mathpow2(10, (LOG_BASE2 - sd % LOG_BASE2) % LOG_BASE2);
        x2.e = -sd || 0;
      } else {
        xd[0] = x2.e = 0;
      }
      return x2;
    }
    if (i == 0) {
      xd.length = xdi;
      k2 = 1;
      xdi--;
    } else {
      xd.length = xdi + 1;
      k2 = mathpow2(10, LOG_BASE2 - i);
      xd[xdi] = j2 > 0 ? (w2 / mathpow2(10, digits - j2) % mathpow2(10, j2) | 0) * k2 : 0;
    }
    if (roundUp) {
      for (; ; ) {
        if (xdi == 0) {
          for (i = 1, j2 = xd[0]; j2 >= 10; j2 /= 10) i++;
          j2 = xd[0] += k2;
          for (k2 = 1; j2 >= 10; j2 /= 10) k2++;
          if (i != k2) {
            x2.e++;
            if (xd[0] == BASE2) xd[0] = 1;
          }
          break;
        } else {
          xd[xdi] += k2;
          if (xd[xdi] != BASE2) break;
          xd[xdi--] = 0;
          k2 = 1;
        }
      }
    }
    for (i = xd.length; xd[--i] === 0; ) xd.pop();
  }
  if (external2) {
    if (x2.e > Ctor.maxE) {
      x2.d = null;
      x2.e = NaN;
    } else if (x2.e < Ctor.minE) {
      x2.e = 0;
      x2.d = [0];
    }
  }
  return x2;
}
function finiteToString2(x2, isExp, sd) {
  if (!x2.isFinite()) return nonFiniteToString2(x2);
  var k2, e = x2.e, str = digitsToString2(x2.d), len = str.length;
  if (isExp) {
    if (sd && (k2 = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString2(k2);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x2.e < 0 ? "e" : "e+") + x2.e;
  } else if (e < 0) {
    str = "0." + getZeroString2(-e - 1) + str;
    if (sd && (k2 = sd - len) > 0) str += getZeroString2(k2);
  } else if (e >= len) {
    str += getZeroString2(e + 1 - len);
    if (sd && (k2 = sd - e - 1) > 0) str = str + "." + getZeroString2(k2);
  } else {
    if ((k2 = e + 1) < len) str = str.slice(0, k2) + "." + str.slice(k2);
    if (sd && (k2 = sd - len) > 0) {
      if (e + 1 === len) str += ".";
      str += getZeroString2(k2);
    }
  }
  return str;
}
function getBase10Exponent2(digits, e) {
  var w2 = digits[0];
  for (e *= LOG_BASE2; w2 >= 10; w2 /= 10) e++;
  return e;
}
function getLn102(Ctor, sd, pr2) {
  if (sd > LN10_PRECISION2) {
    external2 = true;
    if (pr2) Ctor.precision = pr2;
    throw Error(precisionLimitExceeded2);
  }
  return finalise2(new Ctor(LN102), sd, 1, true);
}
function getPi2(Ctor, sd, rm) {
  if (sd > PI_PRECISION2) throw Error(precisionLimitExceeded2);
  return finalise2(new Ctor(PI2), sd, rm, true);
}
function getPrecision2(digits) {
  var w2 = digits.length - 1, len = w2 * LOG_BASE2 + 1;
  w2 = digits[w2];
  if (w2) {
    for (; w2 % 10 == 0; w2 /= 10) len--;
    for (w2 = digits[0]; w2 >= 10; w2 /= 10) len++;
  }
  return len;
}
function getZeroString2(k2) {
  var zs = "";
  for (; k2--; ) zs += "0";
  return zs;
}
function intPow2(Ctor, x2, n, pr2) {
  var isTruncated, r2 = new Ctor(1), k2 = Math.ceil(pr2 / LOG_BASE2 + 4);
  external2 = false;
  for (; ; ) {
    if (n % 2) {
      r2 = r2.times(x2);
      if (truncate2(r2.d, k2)) isTruncated = true;
    }
    n = mathfloor2(n / 2);
    if (n === 0) {
      n = r2.d.length - 1;
      if (isTruncated && r2.d[n] === 0) ++r2.d[n];
      break;
    }
    x2 = x2.times(x2);
    truncate2(x2.d, k2);
  }
  external2 = true;
  return r2;
}
function isOdd2(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin2(Ctor, args, ltgt) {
  var y, x2 = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x2 = y;
      break;
    } else if (x2[ltgt](y)) {
      x2 = y;
    }
  }
  return x2;
}
function naturalExponential2(x2, sd) {
  var denominator, guard, j2, pow22, sum22, t, wpr, rep = 0, i = 0, k2 = 0, Ctor = x2.constructor, rm = Ctor.rounding, pr2 = Ctor.precision;
  if (!x2.d || !x2.d[0] || x2.e > 17) {
    return new Ctor(x2.d ? !x2.d[0] ? 1 : x2.s < 0 ? 0 : 1 / 0 : x2.s ? x2.s < 0 ? 0 : x2 : 0 / 0);
  }
  if (sd == null) {
    external2 = false;
    wpr = pr2;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x2.e > -2) {
    x2 = x2.times(t);
    k2 += 5;
  }
  guard = Math.log(mathpow2(2, k2)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow22 = sum22 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow22 = finalise2(pow22.times(x2), wpr, 1);
    denominator = denominator.times(++i);
    t = sum22.plus(divide2(pow22, denominator, wpr, 1));
    if (digitsToString2(t.d).slice(0, wpr) === digitsToString2(sum22.d).slice(0, wpr)) {
      j2 = k2;
      while (j2--) sum22 = finalise2(sum22.times(sum22), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits2(sum22.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow22 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise2(sum22, Ctor.precision = pr2, rm, external2 = true);
        }
      } else {
        Ctor.precision = pr2;
        return sum22;
      }
    }
    sum22 = t;
  }
}
function naturalLogarithm2(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum22, t, wpr, x1, x2, n = 1, guard = 10, x3 = y, xd = x3.d, Ctor = x3.constructor, rm = Ctor.rounding, pr2 = Ctor.precision;
  if (x3.s < 0 || !xd || !xd[0] || !x3.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x3.s != 1 ? NaN : xd ? 0 : x3);
  }
  if (sd == null) {
    external2 = false;
    wpr = pr2;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString2(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x3.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x3 = x3.times(y);
      c = digitsToString2(x3.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x3.e;
    if (c0 > 1) {
      x3 = new Ctor("0." + c);
      e++;
    } else {
      x3 = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn102(Ctor, wpr + 2, pr2).times(e + "");
    x3 = naturalLogarithm2(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr2;
    return sd == null ? finalise2(x3, pr2, rm, external2 = true) : x3;
  }
  x1 = x3;
  sum22 = numerator = x3 = divide2(x3.minus(1), x3.plus(1), wpr, 1);
  x2 = finalise2(x3.times(x3), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise2(numerator.times(x2), wpr, 1);
    t = sum22.plus(divide2(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString2(t.d).slice(0, wpr) === digitsToString2(sum22.d).slice(0, wpr)) {
      sum22 = sum22.times(2);
      if (e !== 0) sum22 = sum22.plus(getLn102(Ctor, wpr + 2, pr2).times(e + ""));
      sum22 = divide2(sum22, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits2(sum22.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x3 = divide2(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise2(x3.times(x3), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise2(sum22, Ctor.precision = pr2, rm, external2 = true);
        }
      } else {
        Ctor.precision = pr2;
        return sum22;
      }
    }
    sum22 = t;
    denominator += 2;
  }
}
function nonFiniteToString2(x2) {
  return String(x2.s * x2.s / 0);
}
function parseDecimal2(x2, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++) ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x2.e = e = e - i - 1;
    x2.d = [];
    i = (e + 1) % LOG_BASE2;
    if (e < 0) i += LOG_BASE2;
    if (i < len) {
      if (i) x2.d.push(+str.slice(0, i));
      for (len -= LOG_BASE2; i < len; ) x2.d.push(+str.slice(i, i += LOG_BASE2));
      str = str.slice(i);
      i = LOG_BASE2 - str.length;
    } else {
      i -= len;
    }
    for (; i--; ) str += "0";
    x2.d.push(+str);
    if (external2) {
      if (x2.e > x2.constructor.maxE) {
        x2.d = null;
        x2.e = NaN;
      } else if (x2.e < x2.constructor.minE) {
        x2.e = 0;
        x2.d = [0];
      }
    }
  } else {
    x2.e = 0;
    x2.d = [0];
  }
  return x2;
}
function parseOther2(x2, str) {
  var base2, Ctor, divisor, i, isFloat, len, p, xd, xe3;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal2.test(str)) return parseDecimal2(x2, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str) x2.s = NaN;
    x2.e = NaN;
    x2.d = null;
    return x2;
  }
  if (isHex3.test(str)) {
    base2 = 16;
    str = str.toLowerCase();
  } else if (isBinary2.test(str)) {
    base2 = 2;
  } else if (isOctal2.test(str)) {
    base2 = 8;
  } else {
    throw Error(invalidArgument2 + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x2.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow2(Ctor, new Ctor(base2), i, i * 2);
  }
  xd = convertBase2(str, base2, BASE2);
  xe3 = xd.length - 1;
  for (i = xe3; xd[i] === 0; --i) xd.pop();
  if (i < 0) return new Ctor(x2.s * 0);
  x2.e = getBase10Exponent2(xd, xe3);
  x2.d = xd;
  external2 = false;
  if (isFloat) x2 = divide2(x2, divisor, len * 4);
  if (p) x2 = x2.times(Math.abs(p) < 54 ? mathpow2(2, p) : Decimal2.pow(2, p));
  external2 = true;
  return x2;
}
function sine2(Ctor, x2) {
  var k2, len = x2.d.length;
  if (len < 3) {
    return x2.isZero() ? x2 : taylorSeries2(Ctor, 2, x2, x2);
  }
  k2 = 1.4 * Math.sqrt(len);
  k2 = k2 > 16 ? 16 : k2 | 0;
  x2 = x2.times(1 / tinyPow2(5, k2));
  x2 = taylorSeries2(Ctor, 2, x2, x2);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k2--; ) {
    sin2_x = x2.times(x2);
    x2 = x2.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x2;
}
function taylorSeries2(Ctor, n, x2, y, isHyperbolic) {
  var j2, t, u, x22, pr2 = Ctor.precision, k2 = Math.ceil(pr2 / LOG_BASE2);
  external2 = false;
  x22 = x2.times(x2);
  u = new Ctor(y);
  for (; ; ) {
    t = divide2(u.times(x22), new Ctor(n++ * n++), pr2, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide2(t.times(x22), new Ctor(n++ * n++), pr2, 1);
    t = u.plus(y);
    if (t.d[k2] !== void 0) {
      for (j2 = k2; t.d[j2] === u.d[j2] && j2--; ) ;
      if (j2 == -1) break;
    }
    j2 = u;
    u = y;
    y = t;
    t = j2;
  }
  external2 = true;
  t.d.length = k2 + 1;
  return t;
}
function tinyPow2(b2, e) {
  var n = b2;
  while (--e) n *= b2;
  return n;
}
function toLessThanHalfPi2(Ctor, x2) {
  var t, isNeg = x2.s < 0, pi2 = getPi2(Ctor, Ctor.precision, 1), halfPi = pi2.times(0.5);
  x2 = x2.abs();
  if (x2.lte(halfPi)) {
    quadrant2 = isNeg ? 4 : 1;
    return x2;
  }
  t = x2.divToInt(pi2);
  if (t.isZero()) {
    quadrant2 = isNeg ? 3 : 2;
  } else {
    x2 = x2.minus(t.times(pi2));
    if (x2.lte(halfPi)) {
      quadrant2 = isOdd2(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x2;
    }
    quadrant2 = isOdd2(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x2.minus(pi2).abs();
}
function toStringBinary2(x2, baseOut, sd, rm) {
  var base2, e, i, k2, len, roundUp, str, xd, y, Ctor = x2.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt322(sd, 1, MAX_DIGITS2);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt322(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x2.isFinite()) {
    str = nonFiniteToString2(x2);
  } else {
    str = finiteToString2(x2);
    i = str.indexOf(".");
    if (isExp) {
      base2 = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base2 = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase2(finiteToString2(y), 10, base2);
      y.e = y.d.length;
    }
    xd = convertBase2(str, 10, base2);
    e = len = xd.length;
    for (; xd[--len] == 0; ) xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x2 = new Ctor(x2);
        x2.d = xd;
        x2.e = e;
        x2 = divide2(x2, y, sd, rm, 0, base2);
        xd = x2.d;
        e = x2.e;
        roundUp = inexact2;
      }
      i = xd[sd];
      k2 = base2 / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x2.s < 0 ? 3 : 2)) : i > k2 || i === k2 && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x2.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base2 - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len) ;
      for (i = 0, str = ""; i < len; i++) str += NUMERALS2.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++) str += "0";
            xd = convertBase2(str, base2, baseOut);
            for (len = xd.length; !xd[len - 1]; --len) ;
            for (i = 1, str = "1."; i < len; i++) str += NUMERALS2.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; ) str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len) for (e -= len; e--; ) str += "0";
        else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x2.s < 0 ? "-" + str : str;
}
function truncate2(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs2(x2) {
  return new this(x2).abs();
}
function acos2(x2) {
  return new this(x2).acos();
}
function acosh2(x2) {
  return new this(x2).acosh();
}
function add3(x2, y) {
  return new this(x2).plus(y);
}
function asin2(x2) {
  return new this(x2).asin();
}
function asinh2(x2) {
  return new this(x2).asinh();
}
function atan3(x2) {
  return new this(x2).atan();
}
function atanh2(x2) {
  return new this(x2).atanh();
}
function atan22(y, x2) {
  y = new this(y);
  x2 = new this(x2);
  var r2, pr2 = this.precision, rm = this.rounding, wpr = pr2 + 4;
  if (!y.s || !x2.s) {
    r2 = new this(NaN);
  } else if (!y.d && !x2.d) {
    r2 = getPi2(this, wpr, 1).times(x2.s > 0 ? 0.25 : 0.75);
    r2.s = y.s;
  } else if (!x2.d || y.isZero()) {
    r2 = x2.s < 0 ? getPi2(this, pr2, rm) : new this(0);
    r2.s = y.s;
  } else if (!y.d || x2.isZero()) {
    r2 = getPi2(this, wpr, 1).times(0.5);
    r2.s = y.s;
  } else if (x2.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r2 = this.atan(divide2(y, x2, wpr, 1));
    x2 = getPi2(this, wpr, 1);
    this.precision = pr2;
    this.rounding = rm;
    r2 = y.s < 0 ? r2.minus(x2) : r2.plus(x2);
  } else {
    r2 = this.atan(divide2(y, x2, wpr, 1));
  }
  return r2;
}
function cbrt2(x2) {
  return new this(x2).cbrt();
}
function ceil2(x2) {
  return finalise2(x2 = new this(x2), x2.e + 1, 2);
}
function clamp2(x2, min22, max22) {
  return new this(x2).clamp(min22, max22);
}
function config2(obj) {
  if (!obj || typeof obj !== "object") throw Error(decimalError2 + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS2,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT2,
    0,
    "toExpPos",
    0,
    EXP_LIMIT2,
    "maxE",
    0,
    EXP_LIMIT2,
    "minE",
    -EXP_LIMIT2,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults) this[p] = DEFAULTS2[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor2(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument2 + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults) this[p] = DEFAULTS2[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable2);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument2 + p + ": " + v);
    }
  }
  return this;
}
function cos2(x2) {
  return new this(x2).cos();
}
function cosh2(x2) {
  return new this(x2).cosh();
}
function clone2(obj) {
  var i, p, ps;
  function Decimal22(v) {
    var e, i2, t, x2 = this;
    if (!(x2 instanceof Decimal22)) return new Decimal22(v);
    x2.constructor = Decimal22;
    if (isDecimalInstance2(v)) {
      x2.s = v.s;
      if (external2) {
        if (!v.d || v.e > Decimal22.maxE) {
          x2.e = NaN;
          x2.d = null;
        } else if (v.e < Decimal22.minE) {
          x2.e = 0;
          x2.d = [0];
        } else {
          x2.e = v.e;
          x2.d = v.d.slice();
        }
      } else {
        x2.e = v.e;
        x2.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x2.s = 1 / v < 0 ? -1 : 1;
        x2.e = 0;
        x2.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x2.s = -1;
      } else {
        x2.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
        if (external2) {
          if (e > Decimal22.maxE) {
            x2.e = NaN;
            x2.d = null;
          } else if (e < Decimal22.minE) {
            x2.e = 0;
            x2.d = [0];
          } else {
            x2.e = e;
            x2.d = [v];
          }
        } else {
          x2.e = e;
          x2.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v) x2.s = NaN;
        x2.e = NaN;
        x2.d = null;
        return;
      }
      return parseDecimal2(x2, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument2 + v);
    }
    if ((i2 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x2.s = -1;
    } else {
      if (i2 === 43) v = v.slice(1);
      x2.s = 1;
    }
    return isDecimal2.test(v) ? parseDecimal2(x2, v) : parseOther2(x2, v);
  }
  Decimal22.prototype = P2;
  Decimal22.ROUND_UP = 0;
  Decimal22.ROUND_DOWN = 1;
  Decimal22.ROUND_CEIL = 2;
  Decimal22.ROUND_FLOOR = 3;
  Decimal22.ROUND_HALF_UP = 4;
  Decimal22.ROUND_HALF_DOWN = 5;
  Decimal22.ROUND_HALF_EVEN = 6;
  Decimal22.ROUND_HALF_CEIL = 7;
  Decimal22.ROUND_HALF_FLOOR = 8;
  Decimal22.EUCLID = 9;
  Decimal22.config = Decimal22.set = config2;
  Decimal22.clone = clone2;
  Decimal22.isDecimal = isDecimalInstance2;
  Decimal22.abs = abs2;
  Decimal22.acos = acos2;
  Decimal22.acosh = acosh2;
  Decimal22.add = add3;
  Decimal22.asin = asin2;
  Decimal22.asinh = asinh2;
  Decimal22.atan = atan3;
  Decimal22.atanh = atanh2;
  Decimal22.atan2 = atan22;
  Decimal22.cbrt = cbrt2;
  Decimal22.ceil = ceil2;
  Decimal22.clamp = clamp2;
  Decimal22.cos = cos2;
  Decimal22.cosh = cosh2;
  Decimal22.div = div2;
  Decimal22.exp = exp2;
  Decimal22.floor = floor2;
  Decimal22.hypot = hypot2;
  Decimal22.ln = ln3;
  Decimal22.log = log3;
  Decimal22.log10 = log102;
  Decimal22.log2 = log22;
  Decimal22.max = max2;
  Decimal22.min = min2;
  Decimal22.mod = mod2;
  Decimal22.mul = mul2;
  Decimal22.pow = pow2;
  Decimal22.random = random2;
  Decimal22.round = round2;
  Decimal22.sign = sign2;
  Decimal22.sin = sin2;
  Decimal22.sinh = sinh2;
  Decimal22.sqrt = sqrt2;
  Decimal22.sub = sub2;
  Decimal22.sum = sum2;
  Decimal22.tan = tan2;
  Decimal22.tanh = tanh2;
  Decimal22.trunc = trunc2;
  if (obj === void 0) obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }
  }
  Decimal22.config(obj);
  return Decimal22;
}
function div2(x2, y) {
  return new this(x2).div(y);
}
function exp2(x2) {
  return new this(x2).exp();
}
function floor2(x2) {
  return finalise2(x2 = new this(x2), x2.e + 1, 3);
}
function hypot2() {
  var i, n, t = new this(0);
  external2 = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external2 = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external2 = true;
  return t.sqrt();
}
function isDecimalInstance2(obj) {
  return obj instanceof Decimal2 || obj && obj.toStringTag === tag2 || false;
}
function ln3(x2) {
  return new this(x2).ln();
}
function log3(x2, y) {
  return new this(x2).log(y);
}
function log22(x2) {
  return new this(x2).log(2);
}
function log102(x2) {
  return new this(x2).log(10);
}
function max2() {
  return maxOrMin2(this, arguments, "lt");
}
function min2() {
  return maxOrMin2(this, arguments, "gt");
}
function mod2(x2, y) {
  return new this(x2).mod(y);
}
function mul2(x2, y) {
  return new this(x2).mul(y);
}
function pow2(x2, y) {
  return new this(x2).pow(y);
}
function random2(sd) {
  var d, e, k2, n, i = 0, r2 = new this(1), rd = [];
  if (sd === void 0) sd = this.precision;
  else checkInt322(sd, 1, MAX_DIGITS2);
  k2 = Math.ceil(sd / LOG_BASE2);
  if (!this.crypto) {
    for (; i < k2; ) rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k2));
    for (; i < k2; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k2 *= 4);
    for (; i < k2; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k2 / 4;
  } else {
    throw Error(cryptoUnavailable2);
  }
  k2 = rd[--i];
  sd %= LOG_BASE2;
  if (k2 && sd) {
    n = mathpow2(10, LOG_BASE2 - sd);
    rd[i] = (k2 / n | 0) * n;
  }
  for (; rd[i] === 0; i--) rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE2) rd.shift();
    for (k2 = 1, n = rd[0]; n >= 10; n /= 10) k2++;
    if (k2 < LOG_BASE2) e -= LOG_BASE2 - k2;
  }
  r2.e = e;
  r2.d = rd;
  return r2;
}
function round2(x2) {
  return finalise2(x2 = new this(x2), x2.e + 1, this.rounding);
}
function sign2(x2) {
  x2 = new this(x2);
  return x2.d ? x2.d[0] ? x2.s : 0 * x2.s : x2.s || NaN;
}
function sin2(x2) {
  return new this(x2).sin();
}
function sinh2(x2) {
  return new this(x2).sinh();
}
function sqrt2(x2) {
  return new this(x2).sqrt();
}
function sub2(x2, y) {
  return new this(x2).sub(y);
}
function sum2() {
  var i = 0, args = arguments, x2 = new this(args[i]);
  external2 = false;
  for (; x2.s && ++i < args.length; ) x2 = x2.plus(args[i]);
  external2 = true;
  return finalise2(x2, this.precision, this.rounding);
}
function tan2(x2) {
  return new this(x2).tan();
}
function tanh2(x2) {
  return new this(x2).tanh();
}
function trunc2(x2) {
  return finalise2(x2 = new this(x2), x2.e + 1, 1);
}
P2[Symbol.for("nodejs.util.inspect.custom")] = P2.toString;
P2[Symbol.toStringTag] = "Decimal";
var Decimal2 = P2.constructor = clone2(DEFAULTS2);
LN102 = new Decimal2(LN102);
PI2 = new Decimal2(PI2);
var decimal_default2 = Decimal2;
var import_bn5 = __toESM3(require_bn2());
var import_bn = __toESM3(require_bn2());
var Aftermath = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Aftermath only supported on mainnet");
    }
    this.slippage = "900000000000000000";
    this.poolRegistry = "0xfcc774493db2c45c79f688f88d28023a3e7d98e4ee9f48bbf5c7990f651577ae";
    this.protocolFeeVault = "0xf194d9b1bcad972e45a7dd67dd49b3ee1e3357a00a50850c52cd51bb450e13b4";
    this.treasury = "0x28e499dff5e864a2eafe476269a4f5035f1c16f338da7be18b103499abf271ce";
    this.insuranceFund = "0xf0c40d67b078000e18032334c3325c47b9ec9f3d9ae4128be820d54663d14e3b";
    this.referrealVault = "0x35d35b0e5b177593d8c3a801462485572fc30861e6ce96a55af6dc4730709278";
  }
  amountLimit(exportAmountOut) {
    return new import_bn.default(exportAmountOut).mul(new import_bn.default(this.slippage)).div(new import_bn.default("1000000000000000000")).toString();
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      if (path.extendedDetails == null) {
        throw new Error("Extended details not supported");
      } else {
        if (path.extendedDetails.aftermathLpSupplyType == null) {
          throw new Error("LP supply type not supported");
        }
      }
      const args = [
        txb.object(path.id),
        txb.object(this.poolRegistry),
        txb.object(this.protocolFeeVault),
        txb.object(this.treasury),
        txb.object(this.insuranceFund),
        txb.object(this.referrealVault),
        txb.pure.u64(this.amountLimit(path.amountOut)),
        txb.pure.u64(this.slippage),
        inputCoin
      ];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::aftermath::${func}`,
        typeArguments: [
          coinAType,
          coinBType,
          path.extendedDetails.aftermathLpSupplyType
        ],
        arguments: args
      });
      return res;
    });
  }
};
var DEEPBOOK_PACKAGE_ID = "0x000000000000000000000000000000000000000000000000000000000000dee9";
var DeepbookV2 = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Aftermath only supported on mainnet");
    }
  }
  getAccountCap(client, owner) {
    return __async(this, null, function* () {
      let limit = 50;
      let cursor = null;
      while (true) {
        const ownedObjects = client.getOwnedObjects({
          owner,
          cursor,
          limit,
          filter: {
            MoveModule: {
              package: DEEPBOOK_PACKAGE_ID,
              module: "custodian_v2"
            }
          }
        });
        if (ownedObjects != null && ownedObjects.data != null) {
          if (ownedObjects.data.length !== 0) {
            return ownedObjects.data[0].data.objectId;
          }
          if (ownedObjects.data.length < 50) {
            break;
          }
        } else {
          break;
        }
      }
      return null;
    });
  }
  getOrCreateAccountCap(txb, client, owner) {
    return __async(this, null, function* () {
      let accountCapStr = yield this.getAccountCap(client, owner);
      if (accountCapStr !== null) {
        return {
          accountCap: txb.object(accountCapStr),
          isCreate: false
        };
      }
      const accountCap = txb.moveCall({
        target: `${DEEPBOOK_PACKAGE_ID}::clob_v2::create_account`,
        typeArguments: [],
        arguments: []
      });
      return {
        accountCap,
        isCreate: true
      };
    });
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      const accountCapRes = yield this.getOrCreateAccountCap(
        txb,
        client.client,
        client.signer
      );
      const args = [
        txb.object(path.id),
        inputCoin,
        accountCapRes.accountCap,
        txb.object(CLOCK_ADDRESS)
      ];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::deepbook::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      if (accountCapRes.isCreate) {
        txb.transferObjects([accountCapRes.accountCap], client.signer);
      }
      return res;
    });
  }
};
var KriyaV2 = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Kriya amm only supported on mainnet");
    }
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      const args = [txb.object(path.id), inputCoin];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::kriya_amm::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
var KriyaV3 = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Kriya clmm only supported on mainnet");
    }
    this.version = "0xf5145a7ac345ca8736cf8c76047d00d6d378f30e81be6f6eb557184d9de93c78";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      const args = [
        txb.object(path.id),
        inputCoin,
        txb.object(this.version),
        txb.object(CLOCK_ADDRESS)
      ];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::kriya_clmm::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
var FlowxV2 = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Flowx only supported on mainnet");
    }
    this.container = "0xb65dcbf63fd3ad5d0ebfbf334780dc9f785eff38a4459e37ab08fa79576ee511";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      const args = [txb.object(this.container), inputCoin];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::flowx_amm::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
var FlowxV3 = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Flowx clmm only supported on mainnet");
    }
    this.versioned = "0x67624a1533b5aff5d0dfcf5e598684350efd38134d2d245f475524c03a64e656";
    this.poolRegistry = "0x27565d24a4cd51127ac90e4074a841bbe356cca7bf5759ddc14a975be1632abc";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      const args = [
        txb.object(this.poolRegistry),
        txb.pure.u64(path.feeRate * 1e6),
        inputCoin,
        txb.object(this.versioned),
        txb.object(CLOCK_ADDRESS)
      ];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::flowx_clmm::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
var Turbos = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Turbos only supported on mainnet");
    }
    this.versioned = "0xf1cf0e81048df168ebeb1b8030fad24b3e0b53ae827c25053fff0779c1445b6f";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      if (path.extendedDetails == null) {
        throw new Error("Extended details not supported");
      } else {
        if (path.extendedDetails.turbosFeeType == null) {
          throw new Error("Turbos fee type not supported");
        }
      }
      const args = [
        txb.object(path.id),
        inputCoin,
        txb.object(CLOCK_ADDRESS),
        txb.object(this.versioned)
      ];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::turbos::${func}`,
        typeArguments: [coinAType, coinBType, path.extendedDetails.turbosFeeType],
        arguments: args
      });
      return res;
    });
  }
};
var Cetus = class {
  constructor(env, partner) {
    this.globalConfig = env === 0 ? "0xdaa46292632c3c4d8f31f23ea0f9b36a28ff3677e9684980e4438403a67a3d8f" : "0x9774e359588ead122af1c7e7f64e14ade261cfeecdb5d0eb4a5b3b4c8ab8bd3e";
    this.partner = partner != null ? partner : env === 0 ? "0x639b5e433da31739e800cd085f356e64cae222966d0f1b11bd9dc76b322ff58b" : "0x1f5fa5c820f40d43fc47815ad06d95e40a1942ff72a732a92e8ef4aa8cde70a5";
  }
  flash_swap(client, txb, path, by_amount_in, packages) {
    const { direction, from, target } = path;
    const [func, coinAType, coinBType] = direction ? ["flash_swap_a2b", from, target] : ["flash_swap_b2a", target, from];
    let amount = by_amount_in ? path.amountIn : path.amountOut;
    const args = [
      txb.object(this.globalConfig),
      txb.object(path.id),
      txb.object(this.partner),
      txb.pure.u64(amount),
      txb.pure.bool(by_amount_in),
      txb.object(CLOCK_ADDRESS)
    ];
    const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
    const res = txb.moveCall({
      target: `${publishedAt}::cetus::${func}`,
      typeArguments: [coinAType, coinBType],
      arguments: args
    });
    return {
      targetCoin: res[0],
      flashReceipt: res[1],
      payAmount: res[2]
    };
  }
  repay_flash_swap(client, txb, path, inputCoin, receipt, packages) {
    const { direction, from, target } = path;
    const [func, coinAType, coinBType] = direction ? ["repay_flash_swap_a2b", from, target] : ["repay_flash_swap_b2a", target, from];
    const args = [
      txb.object(this.globalConfig),
      txb.object(path.id),
      txb.object(this.partner),
      inputCoin,
      receipt
    ];
    const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
    const res = txb.moveCall({
      target: `${publishedAt}::cetus::${func}`,
      typeArguments: [coinAType, coinBType],
      arguments: args
    });
    return res[0];
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      const args = [
        txb.object(this.globalConfig),
        txb.object(path.id),
        txb.object(this.partner),
        inputCoin,
        txb.object(CLOCK_ADDRESS)
      ];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::cetus::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
function composeType(address, ...args) {
  const generics = Array.isArray(args[args.length - 1]) ? args.pop() : [];
  const chains = [address, ...args].filter(Boolean);
  let result = chains.join("::");
  if (generics && generics.length) {
    result += `<${generics.join(", ")}>`;
  }
  return result;
}
function extractStructTagFromType(type) {
  var _a7;
  try {
    let _type = type.replace(/\s/g, "");
    const genericsString = _type.match(/(<.+>)$/);
    const generics = (_a7 = genericsString == null ? void 0 : genericsString[0]) == null ? void 0 : _a7.match(/(\w+::\w+::\w+)(?:<.*?>(?!>))?/g);
    if (generics) {
      _type = _type.slice(0, _type.indexOf("<"));
      const tag22 = extractStructTagFromType(_type);
      const structTag2 = __spreadProps2(__spreadValues2({}, tag22), {
        type_arguments: generics.map((item) => extractStructTagFromType(item).source_address)
      });
      structTag2.type_arguments = structTag2.type_arguments.map((item) => {
        return CoinUtils.isSuiCoin(item) ? item : extractStructTagFromType(item).source_address;
      });
      structTag2.source_address = composeType(structTag2.full_address, structTag2.type_arguments);
      return structTag2;
    }
    const parts = _type.split("::");
    const isSuiCoin = _type === GAS_TYPE_ARG || _type === GAS_TYPE_ARG_LONG;
    const structTag = {
      full_address: _type,
      address: isSuiCoin ? "0x2" : normalizeSuiObjectId(parts[0]),
      module: parts[1],
      name: parts[2],
      type_arguments: [],
      source_address: ""
    };
    structTag.full_address = `${structTag.address}::${structTag.module}::${structTag.name}`;
    structTag.source_address = composeType(structTag.full_address, structTag.type_arguments);
    return structTag;
  } catch (error) {
    return {
      full_address: type,
      address: "",
      module: "",
      name: "",
      type_arguments: [],
      source_address: type
    };
  }
}
function normalizeCoinType(coinType) {
  return extractStructTagFromType(coinType).source_address;
}
var COIN_TYPE = "0x2::coin::Coin";
var COIN_TYPE_ARG_REGEX = /^0x2::coin::Coin<(.+)>$/;
var GAS_TYPE_ARG = "0x2::sui::SUI";
var GAS_TYPE_ARG_LONG = "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI";
var CoinUtils = class _CoinUtils {
  /**
   * Get the coin type argument from a SuiMoveObject.
   *
   * @param obj The SuiMoveObject to get the coin type argument from.
   * @returns The coin type argument, or null if it is not found.
   */
  static getCoinTypeArg(obj) {
    const res = obj.type.match(COIN_TYPE_ARG_REGEX);
    return res ? res[1] : null;
  }
  /**
   * Get whether a SuiMoveObject is a SUI coin.
   *
   * @param obj The SuiMoveObject to check.
   * @returns Whether the SuiMoveObject is a SUI coin.
   */
  static isSUI(obj) {
    const arg = _CoinUtils.getCoinTypeArg(obj);
    return arg ? _CoinUtils.getCoinSymbol(arg) === "SUI" : false;
  }
  /**
   * Get the coin symbol from a coin type argument.
   *
   * @param coinTypeArg The coin type argument to get the symbol from.
   * @returns The coin symbol.
   */
  static getCoinSymbol(coinTypeArg) {
    return coinTypeArg.substring(coinTypeArg.lastIndexOf(":") + 1);
  }
  /**
   * Get the balance of a SuiMoveObject.
   *
   * @param obj The SuiMoveObject to get the balance from.
   * @returns The balance of the SuiMoveObject.
   */
  static getBalance(obj) {
    return BigInt(obj.fields.balance);
  }
  /**
   * Get the total balance of a list of CoinAsset objects for a given coin address.
   *
   * @param objs The list of CoinAsset objects to get the total balance for.
   * @param coinAddress The coin address to get the total balance for.
   * @returns The total balance of the CoinAsset objects for the given coin address.
   */
  static totalBalance(objs, coinAddress) {
    let balanceTotal = BigInt(0);
    objs.forEach((obj) => {
      if (coinAddress === obj.coinAddress) {
        balanceTotal += BigInt(obj.balance);
      }
    });
    return balanceTotal;
  }
  /**
   * Get the ID of a SuiMoveObject.
   *
   * @param obj The SuiMoveObject to get the ID from.
   * @returns The ID of the SuiMoveObject.
   */
  static getID(obj) {
    return obj.fields.id.id;
  }
  /**
   * Get the coin type from a coin type argument.
   *
   * @param coinTypeArg The coin type argument to get the coin type from.
   * @returns The coin type.
   */
  static getCoinTypeFromArg(coinTypeArg) {
    return `${COIN_TYPE}<${coinTypeArg}>`;
  }
  /**
   * Get the CoinAsset objects for a given coin type.
   *
   * @param coinType The coin type to get the CoinAsset objects for.
   * @param allSuiObjects The list of all SuiMoveObjects.
   * @returns The CoinAsset objects for the given coin type.
   */
  static getCoinAssets(coinType, allSuiObjects) {
    const coins = [];
    allSuiObjects.forEach((anObj) => {
      if (normalizeCoinType(anObj.coinAddress) === normalizeCoinType(coinType)) {
        coins.push(anObj);
      }
    });
    return coins;
  }
  /**
   * Get whether a coin address is a SUI coin.
   *
   * @param coinAddress The coin address to check.
   * @returns Whether the coin address is a SUI coin.
   */
  static isSuiCoin(coinAddress) {
    return extractStructTagFromType(coinAddress).full_address === GAS_TYPE_ARG;
  }
  /**
   * Select the CoinAsset objects from a list of CoinAsset objects that have a balance greater than or equal to a given amount.
   *
   * @param coins The list of CoinAsset objects to select from.
   * @param amount The amount to select CoinAsset objects with a balance greater than or equal to.
   * @param exclude A list of CoinAsset objects to exclude from the selection.
   * @returns The CoinAsset objects that have a balance greater than or equal to the given amount.
   */
  static selectCoinObjectIdGreaterThanOrEqual(coins, amount, exclude = []) {
    const selectedResult = _CoinUtils.selectCoinAssetGreaterThanOrEqual(coins, amount, exclude);
    const objectArray = selectedResult.selectedCoins.map((item) => item.coinObjectId);
    const remainCoins = selectedResult.remainingCoins;
    const amountArray = selectedResult.selectedCoins.map((item) => item.balance.toString());
    return { objectArray, remainCoins, amountArray };
  }
  /**
   * Select the CoinAsset objects from a list of CoinAsset objects that have a balance greater than or equal to a given amount.
   *
   * @param coins The list of CoinAsset objects to select from.
   * @param amount The amount to select CoinAsset objects with a balance greater than or equal to.
   * @param exclude A list of CoinAsset objects to exclude from the selection.
   * @returns The CoinAsset objects that have a balance greater than or equal to the given amount.
   */
  static selectCoinAssetGreaterThanOrEqual(coins, amount, exclude = []) {
    const sortedCoins = _CoinUtils.sortByBalance(coins.filter((c) => !exclude.includes(c.coinObjectId)));
    const total = _CoinUtils.calculateTotalBalance(sortedCoins);
    if (total < amount) {
      return { selectedCoins: [], remainingCoins: sortedCoins };
    }
    if (total === amount) {
      return { selectedCoins: sortedCoins, remainingCoins: [] };
    }
    let sum22 = BigInt(0);
    const selectedCoins = [];
    const remainingCoins = [...sortedCoins];
    while (sum22 < total) {
      const target = amount - sum22;
      const coinWithSmallestSufficientBalanceIndex = remainingCoins.findIndex((c) => c.balance >= target);
      if (coinWithSmallestSufficientBalanceIndex !== -1) {
        selectedCoins.push(remainingCoins[coinWithSmallestSufficientBalanceIndex]);
        remainingCoins.splice(coinWithSmallestSufficientBalanceIndex, 1);
        break;
      }
      const coinWithLargestBalance = remainingCoins.pop();
      if (coinWithLargestBalance.balance > 0) {
        selectedCoins.push(coinWithLargestBalance);
        sum22 += coinWithLargestBalance.balance;
      }
    }
    return { selectedCoins: _CoinUtils.sortByBalance(selectedCoins), remainingCoins: _CoinUtils.sortByBalance(remainingCoins) };
  }
  /**
   * Sort the CoinAsset objects by their balance.
   *
   * @param coins The CoinAsset objects to sort.
   * @returns The sorted CoinAsset objects.
   */
  static sortByBalance(coins) {
    return coins.sort((a, b2) => a.balance < b2.balance ? -1 : a.balance > b2.balance ? 1 : 0);
  }
  static sortByBalanceDes(coins) {
    return coins.sort((a, b2) => a.balance > b2.balance ? -1 : a.balance < b2.balance ? 0 : 1);
  }
  /**
   * Calculate the total balance of a list of CoinAsset objects.
   *
   * @param coins The list of CoinAsset objects to calculate the total balance for.
   * @returns The total balance of the CoinAsset objects.
   */
  static calculateTotalBalance(coins) {
    return coins.reduce((partialSum, c) => partialSum + c.balance, BigInt(0));
  }
};
function getAggregatorServerErrorMessage(code) {
  switch (code) {
    case 1e4:
      return "Calculate error";
    case 10001:
      return "Input number too large can not fit in target type";
    case 10002:
      return "No router";
    case 10003:
      return "Insufficient Liquidity";
    case 10004:
      return "Target token is detected as a HoneyPot scam";
    case 10005:
      return "Too many requests. Please try again later";
    default:
      return "Unknown error";
  }
}
function completionCoin(s) {
  const index = s.indexOf("::");
  if (index === -1) {
    return s;
  }
  const prefix = s.substring(0, index);
  const rest = s.substring(index);
  if (!prefix.startsWith("0x")) {
    return s;
  }
  const hexStr = prefix.substring(2);
  if (hexStr.length > 64) {
    return s;
  }
  const paddedHexStr = hexStr.padStart(64, "0");
  return `0x${paddedHexStr}${rest}`;
}
function compareCoins(coinA, coinB) {
  coinA = completionCoin(coinA);
  coinB = completionCoin(coinB);
  const minLength = Math.min(coinA.length, coinB.length);
  for (let i = 0; i < minLength; i++) {
    if (coinA[i] > coinB[i]) {
      return true;
    } else if (coinA[i] < coinB[i]) {
      return false;
    }
  }
  return true;
}
function mintZeroCoin(txb, coinType) {
  return txb.moveCall({
    target: "0x2::coin::zero",
    typeArguments: [coinType]
  });
}
function buildInputCoin(txb, allCoins, amount, coinType) {
  const usedCoinAsests = CoinUtils.getCoinAssets(coinType, allCoins);
  if (amount === BigInt(0)) {
    if (CoinUtils.isSuiCoin(coinType) || usedCoinAsests.length === 0 && !CoinUtils.isSuiCoin(coinType)) {
      const zeroCoin = mintZeroCoin(txb, coinType);
      return {
        targetCoin: zeroCoin,
        isMintZeroCoin: true,
        targetCoinAmount: 0
      };
    } else {
      return {
        targetCoin: txb.object(usedCoinAsests[0].coinObjectId),
        isMintZeroCoin: false,
        targetCoinAmount: Number(usedCoinAsests[0].balance.toString())
      };
    }
  }
  let totalCoinBalance = CoinUtils.calculateTotalBalance(usedCoinAsests);
  if (totalCoinBalance < amount) {
    throw new AggregateError(
      "Insufficient balance when build merge coin, coinType: " + coinType,
      "InsufficientBalance" + coinType
    );
  }
  if (CoinUtils.isSuiCoin(coinType)) {
    const resultCoin = txb.splitCoins(txb.gas, [
      txb.pure.u64(amount.toString())
    ]);
    return {
      targetCoin: resultCoin,
      isMintZeroCoin: true,
      targetCoinAmount: Number(amount.toString())
    };
  }
  let sortCoinAssets = CoinUtils.sortByBalance(usedCoinAsests);
  let totalThreeCoinBalance = sortCoinAssets.slice(0, 3).reduce((acc, coin) => acc + coin.balance, BigInt(0));
  if (totalThreeCoinBalance < BigInt(amount)) {
    sortCoinAssets = CoinUtils.sortByBalanceDes(usedCoinAsests);
  }
  let selectedCoinResult = CoinUtils.selectCoinObjectIdGreaterThanOrEqual(
    sortCoinAssets,
    amount
  );
  const [masterCoin, ...mergedCoin] = selectedCoinResult.objectArray;
  if (mergedCoin.length > 0) {
    txb.mergeCoins(
      masterCoin,
      mergedCoin.map((coin) => txb.object(coin))
    );
  }
  const targetCoin = txb.splitCoins(txb.object(masterCoin), [
    txb.pure.u64(amount.toString())
  ]);
  return {
    targetCoin,
    isMintZeroCoin: false,
    targetCoinAmount: Number(amount.toString())
  };
}
function checkInvalidSuiAddress(address) {
  if (!address.startsWith("0x") || address.length !== 66) {
    return false;
  }
  return true;
}
var import_bn4 = __toESM3(require_bn2());
var import_bn3 = __toESM3(require_bn2());
var import_bn2 = __toESM3(require_bn2());
var ZERO = new import_bn2.default(0);
var ONE = new import_bn2.default(1);
var TWO = new import_bn2.default(2);
var U128 = TWO.pow(new import_bn2.default(128));
var U64_MAX_BN = new import_bn2.default("18446744073709551615");
var TEN_POW_NINE = 1e9;
function CalculateAmountLimit(expectAmount, byAmountIn, slippage) {
  let amountLimit = ZERO;
  if (byAmountIn) {
    amountLimit = expectAmount.mul(new import_bn3.default(TEN_POW_NINE - slippage * TEN_POW_NINE)).div(new import_bn3.default(TEN_POW_NINE));
  } else {
    amountLimit = expectAmount.mul(new import_bn3.default(TEN_POW_NINE + slippage * TEN_POW_NINE)).div(new import_bn3.default(TEN_POW_NINE));
  }
  return Number(amountLimit.toString());
}
function CalculateAmountLimitBN(expectAmount, byAmountIn, slippage) {
  let amountLimit = ZERO;
  if (byAmountIn) {
    amountLimit = expectAmount.mul(new import_bn3.default(TEN_POW_NINE - slippage * TEN_POW_NINE)).div(new import_bn3.default(TEN_POW_NINE));
  } else {
    amountLimit = expectAmount.mul(new import_bn3.default(TEN_POW_NINE + slippage * TEN_POW_NINE)).div(new import_bn3.default(TEN_POW_NINE));
  }
  return amountLimit;
}
function sqrtPriceX64ToPrice(sqrtPriceStr, decimalsA, decimalsB) {
  const sqrtPriceX64 = new decimal_default2(sqrtPriceStr).mul(decimal_default2.pow(2, -64));
  return sqrtPriceX64.pow(2).mul(decimal_default2.pow(10, decimalsA - decimalsB));
}
function swapInPools(client, params, sender, env) {
  return __async(this, null, function* () {
    var _a7, _b3, _c, _d, _e3;
    const { from, target, amount, byAmountIn, pools } = params;
    const fromCoin = completionCoin(from);
    const targetCoin = completionCoin(target);
    const tx = new Transaction();
    const direction = compareCoins(fromCoin, targetCoin);
    const integratePublishedAt = env === 0 ? "0x2d8c2e0fc6dd25b0214b3fa747e0fd27fd54608142cd2e4f64c1cd350cc4add4" : "0x4f920e1ef6318cfba77e20a0538a419a5a504c14230169438b99aba485db40a6";
    const coinA = direction ? fromCoin : targetCoin;
    const coinB = direction ? targetCoin : fromCoin;
    const typeArguments = [coinA, coinB];
    for (let i = 0; i < pools.length; i++) {
      const args = [
        tx.object(pools[i]),
        tx.pure.bool(direction),
        tx.pure.bool(byAmountIn),
        tx.pure.u64(amount.toString())
      ];
      tx.moveCall({
        target: `${integratePublishedAt}::fetcher_script::calculate_swap_result`,
        arguments: args,
        typeArguments
      });
    }
    if (!checkInvalidSuiAddress(sender)) {
      throw new AggregateError(
        "Aggregator package not set",
        "InvalidWallet"
        /* InvalidWallet */
      );
    }
    const simulateRes = yield client.devInspectTransactionBlock({
      transactionBlock: tx,
      sender
    });
    if (simulateRes.error != null) {
      console.log("simulateRes.error", simulateRes.error);
      throw new AggregateError(
        "Aggregator package not set",
        "SimulateError"
        /* SimulateError */
      );
    }
    const valueData = (_a7 = simulateRes.events) == null ? void 0 : _a7.filter((item) => {
      return item.type.includes("CalculatedSwapResultEvent");
    });
    if (valueData.length === 0 || valueData.length !== pools.length) {
      throw new AggregateError(
        "Simulate event result error",
        "simulateEventError"
        /* SimulateEventError */
      );
    }
    let tempMaxAmount = byAmountIn ? ZERO : U64_MAX_BN;
    let tempIndex = 0;
    for (let i = 0; i < valueData.length; i += 1) {
      if (valueData[i].parsedJson.data.is_exceed) {
        continue;
      }
      if (params.byAmountIn) {
        const amount2 = new import_bn4.BN(valueData[i].parsedJson.data.amount_out);
        if (amount2.gt(tempMaxAmount)) {
          tempIndex = i;
          tempMaxAmount = amount2;
        }
      } else {
        const amount2 = new import_bn4.BN(valueData[i].parsedJson.data.amount_out);
        if (amount2.lt(tempMaxAmount)) {
          tempIndex = i;
          tempMaxAmount = amount2;
        }
      }
    }
    const event = valueData[tempIndex].parsedJson.data;
    const currentSqrtPrice = event.step_results[0].current_sqrt_price;
    const [decimalA, decimalB] = yield Promise.all([
      client.getCoinMetadata({ coinType: coinA }).then((metadata) => metadata == null ? void 0 : metadata.decimals),
      client.getCoinMetadata({ coinType: coinB }).then((metadata) => metadata == null ? void 0 : metadata.decimals)
    ]);
    if (decimalA == null || decimalB == null) {
      throw new AggregateError(
        "Simulate event result error",
        "CannotGetDecimals"
        /* CannotGetDecimals */
      );
    }
    const initialPrice = sqrtPriceX64ToPrice(
      currentSqrtPrice,
      decimalA,
      decimalB
    );
    const feeRate = Number(event.fee_rate) / 1e6;
    const pureAmountIn = new import_bn4.BN((_b3 = event.amount_in) != null ? _b3 : 0);
    const feeAmount = new import_bn4.BN((_c = event.fee_amount) != null ? _c : 0);
    const amountIn = pureAmountIn.add(feeAmount);
    const routeData = {
      amountIn,
      amountOut: new import_bn4.BN((_d = event.amount_out) != null ? _d : 0),
      routes: [
        {
          path: [
            {
              id: pools[tempIndex],
              direction,
              provider: "CETUS",
              from: fromCoin,
              target: targetCoin,
              feeRate,
              amountIn: event.amount_in,
              amountOut: event.amount_out,
              extendedDetails: {
                afterSqrtPrice: event.after_sqrt_price
              }
            }
          ],
          amountIn,
          amountOut: new import_bn4.BN((_e3 = event.amount_out) != null ? _e3 : 0),
          initialPrice
        }
      ],
      insufficientLiquidity: false,
      byAmountIn: params.byAmountIn
    };
    const result = {
      isExceed: event.is_exceed,
      routeData
    };
    return result;
  });
}
var Haedal = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Haedal only supported on mainnet");
    }
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction } = path;
      const func = direction ? "swap_a2b" : "swap_b2a";
      const args = [txb.object(path.id), txb.object("0x5"), inputCoin];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::haedal::${func}`,
        typeArguments: [],
        arguments: args
      });
      return res;
    });
  }
};
var Afsui = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Afsui only supported on mainnet");
    }
    this.stakedSuiVault = "0x2f8f6d5da7f13ea37daa397724280483ed062769813b6f31e9788e59cc88994d";
    this.safe = "0xeb685899830dd5837b47007809c76d91a098d52aabbf61e8ac467c59e5cc4610";
    this.referVault = "0x4ce9a19b594599536c53edb25d22532f82f18038dc8ef618afd00fbbfb9845ef";
    this.validator = "0xd30018ec3f5ff1a3c75656abf927a87d7f0529e6dc89c7ddd1bd27ecb05e3db2";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction } = path;
      if (!direction) {
        throw new Error("Afsui not support b2a swap");
      }
      const func = "swap_a2b";
      const args = [
        txb.object(this.stakedSuiVault),
        txb.object(this.safe),
        txb.object("0x5"),
        txb.object(this.referVault),
        txb.object(this.validator),
        inputCoin
      ];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::afsui::${func}`,
        typeArguments: [],
        arguments: args
      });
      return res;
    });
  }
};
var Volo = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Volo only supported on mainnet");
    }
    this.nativePool = "0x7fa2faa111b8c65bea48a23049bfd81ca8f971a262d981dcd9a17c3825cb5baf";
    this.metadata = "0x680cd26af32b2bde8d3361e804c53ec1d1cfe24c7f039eb7f549e8dfde389a60";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction } = path;
      if (!direction) {
        throw new Error("Volo not support b2a swap");
      }
      const func = "swap_a2b";
      const args = [
        txb.object(this.nativePool),
        txb.object(this.metadata),
        txb.object("0x5"),
        inputCoin
      ];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::volo::${func}`,
        typeArguments: [],
        arguments: args
      });
      return res;
    });
  }
};
var Bluemove = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Bluemove only supported on mainnet");
    }
    this.dexInfo = "0x3f2d9f724f4a1ce5e71676448dc452be9a6243dac9c5b975a588c8c867066e92";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      const args = [txb.object(this.dexInfo), inputCoin];
      const publishedAt = getAggregatorV2PublishedAt(client.publishedAtV2(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::bluemove::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
var DeepbookV3 = class {
  constructor(env) {
    this.deepbookV3Config = env === 0 ? "0x699d455ab8c5e02075b4345ea1f91be55bf46064ae6026cc2528e701ce3ac135" : "0xe19b5d072346cae83a037d4e3c8492068a74410a74e5830b3a68012db38296aa";
  }
  swap(client, txb, path, inputCoin, packages, deepbookv3DeepFee) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b_v2", from, target] : ["swap_b2a_v2", target, from];
      let deepFee;
      if (deepbookv3DeepFee) {
        deepFee = deepbookv3DeepFee;
      } else {
        deepFee = mintZeroCoin(txb, client.deepbookv3DeepFeeType());
      }
      const args = [
        txb.object(this.deepbookV3Config),
        txb.object(path.id),
        inputCoin,
        deepFee,
        txb.object(CLOCK_ADDRESS)
      ];
      const publishedAt = getAggregatorV2ExtendPublishedAt(client.publishedAtV2Extend(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::deepbookv3::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
var Scallop = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Scallop only supported on mainnet");
    }
    this.version = env === 0 ? "0x07871c4b3c847a0f674510d4978d5cf6f960452795e8ff6f189fd2088a3f6ac7" : "0x0";
    this.market = env === 0 ? "0xa757975255146dc9686aa823b7838b507f315d704f428cbadad2f4ea061939d9" : "0x0";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", from, target];
      if (path.extendedDetails == null) {
        throw new Error("Extended details not supported");
      } else {
        if (path.extendedDetails.scallopScoinTreasury == null) {
          throw new Error("Scallop coin treasury not supported");
        }
      }
      const args = [
        txb.object(this.version),
        txb.object(this.market),
        txb.object(path.extendedDetails.scallopScoinTreasury),
        inputCoin,
        txb.object(CLOCK_ADDRESS)
      ];
      const publishedAt = getAggregatorV2ExtendPublishedAt(client.publishedAtV2Extend(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::scallop::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
var Suilend = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Suilend only supported on mainnet");
    }
    this.sui_system_state = env === 0 ? "0x0000000000000000000000000000000000000000000000000000000000000005" : "0x0";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, springCoinType] = direction ? ["swap_a2b", target] : ["swap_b2a", from];
      const args = [
        txb.object(path.id),
        txb.object(this.sui_system_state),
        inputCoin
      ];
      const publishedAt = getAggregatorV2ExtendPublishedAt(client.publishedAtV2Extend(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::suilend::${func}`,
        typeArguments: [springCoinType],
        arguments: args
      });
      return res;
    });
  }
};
var Bluefin = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Bluefin only supported on mainnet");
    }
    this.globalConfig = "0x03db251ba509a8d5d8777b6338836082335d93eecbdd09a11e190a1cff51c352";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      const args = [
        txb.object(this.globalConfig),
        txb.object(path.id),
        inputCoin,
        txb.object(CLOCK_ADDRESS)
      ];
      const publishedAt = getAggregatorV2ExtendPublishedAt(client.publishedAtV2Extend(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::bluefin::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
var HaedalPmm = class {
  constructor(env, pythPriceIDs) {
    if (env === 1) {
      throw new Error("HaedalPmm is not supported on testnet");
    }
    this.pythPriceIDs = pythPriceIDs;
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      let basePriceSeed;
      let quotePriceSeed;
      if (path.extendedDetails == null) {
        throw new Error("Extended details not supported haedal pmm");
      } else {
        if (!path.extendedDetails.haedalPmmBasePriceSeed || !path.extendedDetails.haedalPmmQuotePriceSeed) {
          throw new Error("Base price seed or quote price seed not supported");
        }
        basePriceSeed = path.extendedDetails.haedalPmmBasePriceSeed;
        quotePriceSeed = path.extendedDetails.haedalPmmQuotePriceSeed;
      }
      const basePriceInfoObjectId = this.pythPriceIDs.get(basePriceSeed);
      const quotePriceInfoObjectId = this.pythPriceIDs.get(quotePriceSeed);
      if (!basePriceInfoObjectId || !quotePriceInfoObjectId) {
        throw new Error(
          "Base price info object id or quote price info object id not found"
        );
      }
      const args = [
        txb.object(path.id),
        txb.object(basePriceInfoObjectId),
        txb.object(quotePriceInfoObjectId),
        inputCoin,
        txb.object(CLOCK_ADDRESS)
      ];
      const publishedAt = getAggregatorV2ExtendPublishedAt(
        client.publishedAtV2Extend(),
        packages
      );
      const res = txb.moveCall({
        target: `${publishedAt}::haedalpmm::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
var Alphafi = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Alphafi only supported on mainnet");
    }
    this.sui_system_state = env === 0 ? "0x0000000000000000000000000000000000000000000000000000000000000005" : "0x0";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, stCoinType] = direction ? ["swap_a2b", target] : ["swap_b2a", from];
      const args = [
        txb.object(path.id),
        txb.object(this.sui_system_state),
        inputCoin
      ];
      const publishedAt = getAggregatorV2ExtendPublishedAt(client.publishedAtV2Extend(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::alphafi::${func}`,
        typeArguments: [stCoinType],
        arguments: args
      });
      return res;
    });
  }
};
var Steamm = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("Steamm only supported on mainnet");
    }
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      if (path.extendedDetails == null) {
        throw new Error("Extended details not supported");
      } else {
        if (path.extendedDetails.steammBankA == null) {
          throw new Error("Steamm bank a type not supported");
        }
        if (path.extendedDetails.steammBankB == null) {
          throw new Error("Steamm bank b type not supported");
        }
        if (path.extendedDetails.steammLendingMarket == null) {
          throw new Error("Steamm lending market not supported");
        }
        if (path.extendedDetails.steammLendingMarketType == null) {
          throw new Error("Steamm lending market type not supported");
        }
        if (path.extendedDetails.steammBCoinAType == null) {
          throw new Error("Steamm b coin a type not supported");
        }
        if (path.extendedDetails.steammBCoinBType == null) {
          throw new Error("Steamm b coin b type not supported");
        }
        if (path.extendedDetails.steammLPToken == null) {
          throw new Error("Steamm lp token not supported");
        }
      }
      const args = [
        txb.object(path.id),
        txb.object(path.extendedDetails.steammBankA),
        txb.object(path.extendedDetails.steammBankB),
        txb.object(path.extendedDetails.steammLendingMarket),
        inputCoin,
        txb.object(CLOCK_ADDRESS)
      ];
      const publishedAt = getAggregatorV2ExtendPublishedAt(client.publishedAtV2Extend(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::steammfe::${func}`,
        typeArguments: [
          path.extendedDetails.steammLendingMarketType,
          coinAType,
          coinBType,
          path.extendedDetails.steammBCoinAType,
          path.extendedDetails.steammBCoinBType,
          path.extendedDetails.steammLPToken
        ],
        arguments: args
      });
      return res;
    });
  }
};
var SUPER_SUI_TYPE = "0x790f258062909e3a0ffc78b3c53ac2f62d7084c3bab95644bdeb05add7250001::super_sui::SUPER_SUI";
var MUSD_TYPE = "0xe44df51c0b21a27ab915fa1fe2ca610cd3eaa6d9666fe5e62b988bf7f0bd8722::musd::MUSD";
var METH_TYPE = "0xccd628c2334c5ed33e6c47d6c21bb664f8b6307b2ac32c2462a61f69a31ebcee::meth::METH";
var Metastable = class {
  constructor(env, pythPriceIDs) {
    if (env !== 0) {
      throw new Error("Metastable only supported on mainnet");
    }
    this.versionID = "0x4696559327b35ff2ab26904e7426a1646312e9c836d5c6cff6709a5ccc30915c";
    this.pythPriceIDs = pythPriceIDs;
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, createCapFunc, coinType, metaCoinType] = direction ? ["swap_a2b", "create_deposit_cap", from, target] : ["swap_b2a", "create_withdraw_cap", target, from];
      let createExchangePkgId = "";
      let createDepositModule = "pyth";
      let metaSingletonId = "";
      if (path.extendedDetails == null) {
        throw new Error("Extended details not supported metastable");
      } else {
        if (!path.extendedDetails.metastableCreateCapPkgId || !path.extendedDetails.metastableCreateCapModule || !path.extendedDetails.metastableRegistryId || !path.extendedDetails.metastableWhitelistedAppId) {
          throw new Error("CreateCapPkgId or CreateCapModule or RegistryId or WhitelistedAppId or CreateCapAllTypeParams not supported");
        }
        createExchangePkgId = path.extendedDetails.metastableCreateCapPkgId;
        createDepositModule = path.extendedDetails.metastableCreateCapModule;
        metaSingletonId = path.extendedDetails.metastableWhitelistedAppId;
      }
      const createDepositCapTypeArgs = [
        metaCoinType
      ];
      if (path.extendedDetails.metastableCreateCapAllTypeParams) {
        createDepositCapTypeArgs.push(coinType);
      }
      const depositArgs = [
        txb.object(metaSingletonId),
        txb.object(path.id)
      ];
      switch (metaCoinType) {
        case SUPER_SUI_TYPE: {
          if (!path.extendedDetails.metastableRegistryId) {
            throw new Error("Not found registry id for super sui");
          }
          depositArgs.push(txb.object(path.extendedDetails.metastableRegistryId));
          break;
        }
        case MUSD_TYPE: {
          if (path.extendedDetails.metastablePriceSeed != null) {
            const priceId = this.pythPriceIDs.get(path.extendedDetails.metastablePriceSeed);
            if (priceId == null) {
              throw new Error("Invalid Pyth price feed: " + path.extendedDetails.metastablePriceSeed);
            }
            depositArgs.push(txb.object(priceId));
          }
          if (path.extendedDetails.metastableETHPriceSeed != null) {
            const priceId = this.pythPriceIDs.get(path.extendedDetails.metastableETHPriceSeed);
            if (priceId == null) {
              throw new Error("Invalid Pyth price feed: " + path.extendedDetails.metastableETHPriceSeed);
            }
            depositArgs.push(txb.object(priceId));
          }
          depositArgs.push(txb.object(CLOCK_ADDRESS));
          break;
        }
        case METH_TYPE: {
          if (path.extendedDetails.metastablePriceSeed != null) {
            const priceId = this.pythPriceIDs.get(path.extendedDetails.metastablePriceSeed);
            if (priceId == null) {
              throw new Error("Invalid Pyth price feed: " + path.extendedDetails.metastablePriceSeed);
            }
            depositArgs.push(txb.object(priceId));
          }
          if (path.extendedDetails.metastableETHPriceSeed != null) {
            const priceId = this.pythPriceIDs.get(path.extendedDetails.metastableETHPriceSeed);
            if (priceId == null) {
              throw new Error("Invalid Pyth price feed: " + path.extendedDetails.metastableETHPriceSeed);
            }
            depositArgs.push(txb.object(priceId));
          }
          depositArgs.push(txb.object(CLOCK_ADDRESS));
          break;
        }
        default:
          throw new Error("Invalid Metacoin: " + metaCoinType);
      }
      const depositResult = txb.moveCall({
        target: `${createExchangePkgId}::${createDepositModule}::${createCapFunc}`,
        typeArguments: createDepositCapTypeArgs,
        arguments: depositArgs
      });
      const swapArgs = [
        txb.object(path.id),
        txb.object(this.versionID),
        depositResult,
        inputCoin
      ];
      const publishedAt = getAggregatorV2ExtendPublishedAt(client.publishedAtV2Extend(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::metastable::${func}`,
        typeArguments: [
          coinType,
          metaCoinType
        ],
        arguments: swapArgs
      });
      return res;
    });
  }
};
var Obric = class {
  constructor(env, pythPriceIDs) {
    if (env === 1) {
      throw new Error("Obric is not supported on testnet");
    }
    this.pythPriceIDs = pythPriceIDs;
    this.pythStateObjectId = "0x1f9310238ee9298fb703c3419030b35b22bb1cc37113e3bb5007c99aec79e5b8";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction, from, target } = path;
      const [func, coinAType, coinBType] = direction ? ["swap_a2b", from, target] : ["swap_b2a", target, from];
      let coinAPriceSeed;
      let coinBPriceSeed;
      let coinAPriceInfoObjectId;
      let coinBPriceInfoObjectId;
      if (path.extendedDetails == null) {
        throw new Error("Extended details not supported in obric");
      } else {
        if (path.extendedDetails.obricCoinAPriceSeed && path.extendedDetails.obricCoinBPriceSeed) {
          coinAPriceSeed = path.extendedDetails.obricCoinAPriceSeed;
          coinAPriceInfoObjectId = this.pythPriceIDs.get(coinAPriceSeed);
          coinBPriceSeed = path.extendedDetails.obricCoinBPriceSeed;
          coinBPriceInfoObjectId = this.pythPriceIDs.get(coinBPriceSeed);
        } else {
          if (!path.extendedDetails.obricCoinAPriceId || !path.extendedDetails.obricCoinBPriceId) {
            throw new Error("Base price id or quote price id not supported");
          } else {
            coinAPriceInfoObjectId = path.extendedDetails.obricCoinAPriceId;
            coinBPriceInfoObjectId = path.extendedDetails.obricCoinBPriceId;
          }
        }
      }
      if (!coinAPriceInfoObjectId || !coinBPriceInfoObjectId) {
        throw new Error(
          "Base price info object id or quote price info object id not found"
        );
      }
      const args = [
        txb.object(path.id),
        inputCoin,
        txb.object(this.pythStateObjectId),
        txb.object(coinAPriceInfoObjectId),
        txb.object(coinBPriceInfoObjectId),
        txb.object(CLOCK_ADDRESS)
      ];
      const publishedAt = getAggregatorV2ExtendPublishedAt(
        client.publishedAtV2Extend(),
        packages
      );
      const res = txb.moveCall({
        target: `${publishedAt}::obric::${func}`,
        typeArguments: [coinAType, coinBType],
        arguments: args
      });
      return res;
    });
  }
};
var HaWAL = class {
  constructor(env) {
    if (env !== 0) {
      throw new Error("HaWAL only supported on mainnet");
    }
    this.staking = env === 0 ? "0x10b9d30c28448939ce6c4d6c6e0ffce4a7f8a4ada8248bdad09ef8b70e4a3904" : "0x0";
    this.validator = env === 0 ? "0x7b3ba6de2ae58283f60d5b8dc04bb9e90e4796b3b2e0dea75569f491275242e7" : "0x0";
  }
  swap(client, txb, path, inputCoin, packages) {
    return __async(this, null, function* () {
      const { direction } = path;
      const func = direction ? "swap_a2b" : "swap_b2a";
      const args = [
        txb.object(this.staking),
        txb.object(path.id),
        inputCoin,
        txb.object(this.validator)
      ];
      const publishedAt = getAggregatorV2ExtendPublishedAt(client.publishedAtV2Extend(), packages);
      const res = txb.moveCall({
        target: `${publishedAt}::hawal::${func}`,
        typeArguments: [],
        arguments: args
      });
      return res;
    });
  }
};
var CETUS = "CETUS";
var DEEPBOOKV2 = "DEEPBOOK";
var KRIYA = "KRIYA";
var FLOWXV2 = "FLOWX";
var FLOWXV3 = "FLOWXV3";
var KRIYAV3 = "KRIYAV3";
var TURBOS = "TURBOS";
var AFTERMATH2 = "AFTERMATH";
var HAEDAL2 = "HAEDAL";
var VOLO2 = "VOLO";
var AFSUI = "AFSUI";
var BLUEMOVE = "BLUEMOVE";
var DEEPBOOKV3 = "DEEPBOOKV3";
var SCALLOP2 = "SCALLOP";
var SUILEND = "SUILEND";
var BLUEFIN = "BLUEFIN";
var HAEDALPMM = "HAEDALPMM";
var ALPHAFI = "ALPHAFI";
var SPRINGSUI = "SPRINGSUI";
var STEAMM = "STEAMM";
var METASTABLE = "METASTABLE";
var OBRIC = "OBRIC";
var HAWAL = "HAWAL";
var DEFAULT_ENDPOINT = "https://api-sui.cetus.zone/router_v2";
function isBuilderRouterSwapParams(params) {
  return Array.isArray(params.routers);
}
function isBuilderFastRouterSwapParams(params) {
  return Array.isArray(params.routers);
}
var _AggregatorClient = class _AggregatorClient2 {
  constructor(params) {
    var _a7, _b3;
    this.endpoint = params.endpoint ? processEndpoint(params.endpoint) : DEFAULT_ENDPOINT;
    this.client = params.client || new SuiClient({ url: getFullnodeUrl("mainnet") });
    this.signer = params.signer || "";
    this.env = params.env || 0;
    this.allCoins = /* @__PURE__ */ new Map();
    const config22 = _AggregatorClient2.CONFIG[this.env];
    this.pythConnections = this.newPythClients((_a7 = params.pythUrls) != null ? _a7 : []);
    this.pythClient = new import_pyth_sui_js.SuiPythClient(
      this.client,
      config22.pythStateId,
      config22.wormholeStateId
    );
    this.apiKey = params.apiKey || "";
    this.partner = params.partner;
    if (params.overlayFeeRate) {
      if (params.overlayFeeRate > 0 && params.overlayFeeRate <= 0.01) {
        this.overlayFeeRate = params.overlayFeeRate * 1e6;
      } else {
        throw new Error("Overlay fee rate must be between 0 and 0.01");
      }
    } else {
      this.overlayFeeRate = 0;
    }
    this.overlayFeeReceiver = (_b3 = params.overlayFeeReceiver) != null ? _b3 : "0x0";
  }
  newPythClients(pythUrls) {
    if (!pythUrls.includes("https://hermes.pyth.network")) {
      pythUrls.push("https://hermes.pyth.network");
    }
    const connections = pythUrls.map((url) => new import_pyth_sui_js.SuiPriceServiceConnection(url, { timeout: 3e3 }));
    return connections;
  }
  getCoins(coinType, refresh = true) {
    return __async(this, null, function* () {
      if (this.signer === "") {
        throw new Error("Signer is required, but not provided.");
      }
      let cursor = null;
      let limit = 50;
      if (!refresh) {
        const gotFromCoins = this.allCoins.get(coinType);
        if (gotFromCoins) {
          return gotFromCoins;
        }
      }
      const allCoins = [];
      while (true) {
        try {
          const gotCoins = yield this.client.getCoins({
            owner: this.signer,
            coinType,
            cursor,
            limit
          });
          for (const coin of gotCoins.data) {
            allCoins.push({
              coinAddress: extractStructTagFromType(coin.coinType).source_address,
              coinObjectId: coin.coinObjectId,
              balance: BigInt(coin.balance)
            });
          }
          if (!gotCoins.hasNextPage) {
            break;
          }
          cursor = gotCoins.nextCursor;
        } catch (e) {
          console.error("getCoins error:", e);
          break;
        }
      }
      this.allCoins.set(coinType, allCoins);
      return allCoins;
    });
  }
  findRouters(params) {
    return __async(this, null, function* () {
      return getRouterResult(this.endpoint, this.apiKey, params, this.overlayFeeRate, this.overlayFeeReceiver);
    });
  }
  executeFlexibleInputSwap(txb, inputCoin, routers, expectedAmountOut, amountLimit, pythPriceIDs, partner, deepbookv3DeepFee, packages) {
    return __async(this, null, function* () {
      if (routers.length === 0) {
        throw new Error("No router found");
      }
      const outputCoinType = routers[0].path[routers[0].path.length - 1].target;
      const outputCoins = [];
      for (let i = 0; i < routers.length - 1; i++) {
        if (routers[i].path.length === 0) {
          throw new Error("Empty path");
        }
        const splitCoin = txb.splitCoins(inputCoin, [routers[i].amountIn.toString()]);
        let nextCoin = splitCoin[0];
        for (const path of routers[i].path) {
          const dex = this.newDex(path.provider, pythPriceIDs, partner);
          nextCoin = yield dex.swap(
            this,
            txb,
            path,
            nextCoin,
            packages,
            deepbookv3DeepFee
          );
        }
        outputCoins.push(nextCoin);
      }
      if (routers[routers.length - 1].path.length === 0) {
        throw new Error("Empty path");
      }
      let lastCoin = inputCoin;
      for (const path of routers[routers.length - 1].path) {
        const dex = this.newDex(path.provider, pythPriceIDs, partner);
        lastCoin = yield dex.swap(
          this,
          txb,
          path,
          lastCoin,
          packages,
          deepbookv3DeepFee
        );
      }
      outputCoins.push(lastCoin);
      const aggregatorV2ExtendPublishedAt = getAggregatorV2ExtendPublishedAt(
        this.publishedAtV2Extend(),
        packages
      );
      const mergedTargetCoin = this.checkCoinThresholdAndMergeCoin(
        txb,
        outputCoins,
        outputCoinType,
        expectedAmountOut,
        amountLimit,
        aggregatorV2ExtendPublishedAt
      );
      return mergedTargetCoin;
    });
  }
  expectInputSwap(txb, inputCoin, routers, expectedAmountOut, amountLimit, pythPriceIDs, partner, deepbookv3DeepFee, packages) {
    return __async(this, null, function* () {
      if (routers.length === 0) {
        throw new Error("No router found");
      }
      const splitAmounts = routers.map((router) => router.amountIn.toString());
      const inputCoinType = routers[0].path[0].from;
      const outputCoinType = routers[0].path[routers[0].path.length - 1].target;
      const inputCoins = txb.splitCoins(inputCoin, splitAmounts);
      const outputCoins = [];
      for (let i = 0; i < routers.length; i++) {
        if (routers[i].path.length === 0) {
          throw new Error("Empty path");
        }
        let nextCoin = inputCoins[i];
        for (const path of routers[i].path) {
          const dex = this.newDex(path.provider, pythPriceIDs, partner);
          nextCoin = yield dex.swap(
            this,
            txb,
            path,
            nextCoin,
            packages,
            deepbookv3DeepFee
          );
        }
        outputCoins.push(nextCoin);
      }
      const aggregatorV2PublishedAt = getAggregatorV2PublishedAt(
        this.publishedAtV2(),
        packages
      );
      const aggregatorV2ExtendPublishedAt = getAggregatorV2ExtendPublishedAt(
        this.publishedAtV2Extend(),
        packages
      );
      this.transferOrDestoryCoin(
        txb,
        inputCoin,
        inputCoinType,
        aggregatorV2PublishedAt
      );
      const mergedTargetCoins = this.checkCoinThresholdAndMergeCoin(
        txb,
        outputCoins,
        outputCoinType,
        expectedAmountOut,
        amountLimit,
        aggregatorV2ExtendPublishedAt
      );
      return mergedTargetCoins;
    });
  }
  expectOutputSwap(txb, inputCoin, routers, partner, packages) {
    return __async(this, null, function* () {
      const returnCoins = [];
      const receipts = [];
      const targetCoins = [];
      const dex = new Cetus(this.env, partner);
      const aggregatorV2PublishedAt = getAggregatorV2PublishedAt(
        this.publishedAtV2(),
        packages
      );
      for (let i = 0; i < routers.length; i++) {
        const router = routers[i];
        for (let j2 = router.path.length - 1; j2 >= 0; j2--) {
          const path = router.path[j2];
          const flashSwapResult = dex.flash_swap(this, txb, path, false);
          returnCoins.unshift(flashSwapResult.targetCoin);
          receipts.unshift(flashSwapResult.flashReceipt);
        }
        let nextRepayCoin = inputCoin;
        for (let j2 = 0; j2 < router.path.length; j2++) {
          const path = router.path[j2];
          const repayResult = dex.repay_flash_swap(
            this,
            txb,
            path,
            nextRepayCoin,
            receipts[j2]
          );
          nextRepayCoin = returnCoins[j2];
          if (j2 === 0) {
            inputCoin = repayResult;
          } else {
            this.transferOrDestoryCoin(
              txb,
              repayResult,
              path.from,
              aggregatorV2PublishedAt
            );
          }
          if (j2 === router.path.length - 1) {
            targetCoins.push(nextRepayCoin);
          }
        }
      }
      const inputCoinType = routers[0].path[0].from;
      this.transferOrDestoryCoin(
        txb,
        inputCoin,
        inputCoinType,
        aggregatorV2PublishedAt
      );
      if (targetCoins.length > 1) {
        const vec = txb.makeMoveVec({ elements: targetCoins.slice(1) });
        txb.moveCall({
          target: `${SUI_FRAMEWORK_ADDRESS}::pay::join_vec`,
          typeArguments: [routers[0].path[routers[0].path.length - 1].target],
          arguments: [targetCoins[0], vec]
        });
      }
      return targetCoins[0];
    });
  }
  swapInPools(params) {
    return __async(this, null, function* () {
      let result;
      try {
        result = yield swapInPools(this.client, params, this.signer, this.env);
      } catch (e) {
        console.error("swapInPools error:", e);
        return null;
      }
      return result;
    });
  }
  routerSwap(params) {
    return __async(this, null, function* () {
      const { routers, inputCoin, slippage, txb, deepbookv3DeepFee, partner } = params;
      if (slippage > 1 || slippage < 0) {
        throw new Error("Invalid slippage value. Must be between 0 and 1 (e.g., 0.01 represents 1% slippage)");
      }
      const routerData = Array.isArray(routers) ? routers : routers.routes;
      const byAmountIn = isBuilderRouterSwapParams(params) ? params.byAmountIn : params.routers.byAmountIn;
      const amountIn = routerData.reduce(
        (acc, router) => acc.add(router.amountIn),
        new import_bn5.default(0)
      );
      const amountOut = routerData.reduce(
        (acc, router) => acc.add(router.amountOut),
        new import_bn5.default(0)
      );
      let overlayFee = new import_bn5.default(0);
      if (this.overlayFeeRate > 0 && this.overlayFeeReceiver !== "0x0") {
        if (byAmountIn) {
          overlayFee = amountOut.mul(new import_bn5.default(this.overlayFeeRate)).div(new import_bn5.default(1e6));
        } else {
          overlayFee = amountIn.mul(new import_bn5.default(this.overlayFeeRate)).div(new import_bn5.default(1e6));
        }
      }
      const expectedAmountOut = byAmountIn ? amountOut.sub(overlayFee) : amountOut;
      const expectedAmountIn = byAmountIn ? amountIn : amountIn.add(overlayFee);
      const amountLimit = CalculateAmountLimitBN(
        byAmountIn ? expectedAmountOut : expectedAmountIn,
        byAmountIn,
        slippage
      );
      const packages = isBuilderRouterSwapParams(params) ? void 0 : params.routers.packages;
      const aggregatorV2PublishedAt = getAggregatorV2PublishedAt(
        this.publishedAtV2(),
        packages
      );
      const priceIDs = findPythPriceIDs(routerData);
      const priceInfoObjectIds = priceIDs.length > 0 ? yield this.updatePythPriceIDs(priceIDs, txb) : /* @__PURE__ */ new Map();
      if (byAmountIn) {
        const targetCoin2 = yield this.expectInputSwap(
          txb,
          inputCoin,
          routerData,
          amountOut.toString(),
          amountLimit.toString(),
          priceInfoObjectIds,
          partner != null ? partner : this.partner,
          deepbookv3DeepFee,
          packages
        );
        return targetCoin2;
      }
      const overlayFeeCoin = txb.splitCoins(inputCoin, [
        overlayFee.toString()
      ]);
      if (this.overlayFeeRate > 0 && this.overlayFeeReceiver !== "0x0") {
        txb.transferObjects([overlayFeeCoin], this.overlayFeeReceiver);
      }
      const splitedInputCoins = txb.splitCoins(inputCoin, [
        amountLimit.sub(overlayFee).toString()
      ]);
      this.transferOrDestoryCoin(
        txb,
        inputCoin,
        routerData[0].path[0].from,
        aggregatorV2PublishedAt
      );
      const targetCoin = yield this.expectOutputSwap(
        txb,
        splitedInputCoins[0],
        routerData,
        partner != null ? partner : this.partner
      );
      return targetCoin;
    });
  }
  fixableRouterSwap(params) {
    return __async(this, null, function* () {
      const { routers, inputCoin, slippage, txb, deepbookv3DeepFee, partner } = params;
      const routerData = Array.isArray(routers) ? routers : routers.routes;
      const byAmountIn = params.routers.byAmountIn;
      const amountIn = routerData.reduce(
        (acc, router) => acc.add(router.amountIn),
        new import_bn5.default(0)
      );
      const amountOut = routerData.reduce(
        (acc, router) => acc.add(router.amountOut),
        new import_bn5.default(0)
      );
      let overlayFee = 0;
      if (this.overlayFeeRate > 0 && this.overlayFeeReceiver !== "0x0") {
        if (byAmountIn) {
          overlayFee = Number(amountOut.mul(new import_bn5.default(this.overlayFeeRate)).div(new import_bn5.default(1e6)).toString());
        } else {
          overlayFee = Number(amountIn.mul(new import_bn5.default(this.overlayFeeRate)).div(new import_bn5.default(1e6)).toString());
        }
      }
      const expectedAmountOut = byAmountIn ? amountOut.sub(new import_bn5.default(overlayFee)) : amountOut;
      const expectedAmountIn = byAmountIn ? amountIn : amountIn.add(new import_bn5.default(overlayFee));
      const amountLimit = CalculateAmountLimitBN(
        byAmountIn ? expectedAmountOut : expectedAmountIn,
        byAmountIn,
        slippage
      );
      const packages = isBuilderRouterSwapParams(params) ? void 0 : params.routers.packages;
      const priceIDs = findPythPriceIDs(routerData);
      const priceInfoObjectIds = priceIDs.length > 0 ? yield this.updatePythPriceIDs(priceIDs, txb) : /* @__PURE__ */ new Map();
      if (byAmountIn) {
        const targetCoin2 = yield this.executeFlexibleInputSwap(
          txb,
          inputCoin,
          routerData,
          expectedAmountOut.toString(),
          amountLimit.toString(),
          priceInfoObjectIds,
          partner != null ? partner : this.partner,
          deepbookv3DeepFee,
          packages
        );
        return targetCoin2;
      }
      const targetCoin = yield this.expectOutputSwap(
        txb,
        inputCoin,
        routerData,
        partner != null ? partner : this.partner
      );
      return targetCoin;
    });
  }
  // auto build input coin
  // auto merge, transfer or destory target coin.
  fastRouterSwap(params) {
    return __async(this, null, function* () {
      const {
        routers,
        slippage,
        txb,
        partner,
        refreshAllCoins,
        payDeepFeeAmount
      } = params;
      const routerData = Array.isArray(routers) ? routers : routers.routes;
      const fromCoinType = routerData[0].path[0].from;
      let fromCoins = yield this.getCoins(fromCoinType, refreshAllCoins);
      const targetCoinType = routerData[0].path[routerData[0].path.length - 1].target;
      const amountIn = routerData.reduce(
        (acc, router) => acc.add(router.amountIn),
        new import_bn5.default(0)
      );
      const amountOut = routerData.reduce(
        (acc, router) => acc.add(router.amountOut),
        new import_bn5.default(0)
      );
      const byAmountIn = isBuilderFastRouterSwapParams(params) ? params.byAmountIn : params.routers.byAmountIn;
      let overlayFee = 0;
      if (this.overlayFeeRate > 0 && this.overlayFeeReceiver !== "0x0") {
        if (byAmountIn) {
          overlayFee = Number(amountOut.mul(new import_bn5.default(this.overlayFeeRate)).div(new import_bn5.default(1e6)).toString());
        } else {
          overlayFee = Number(amountIn.mul(new import_bn5.default(this.overlayFeeRate)).div(new import_bn5.default(1e6)).toString());
        }
      }
      const expectedAmountOut = byAmountIn ? amountOut.sub(new import_bn5.default(overlayFee)) : amountOut;
      const expectedAmountIn = byAmountIn ? amountIn : amountIn.add(new import_bn5.default(overlayFee));
      const amountLimit = CalculateAmountLimit(
        byAmountIn ? expectedAmountOut : expectedAmountIn,
        byAmountIn,
        slippage
      );
      const amount = byAmountIn ? expectedAmountIn : amountLimit;
      const buildFromCoinRes = buildInputCoin(
        txb,
        fromCoins,
        BigInt(amount.toString()),
        fromCoinType
      );
      let deepCoin;
      if (payDeepFeeAmount && payDeepFeeAmount > 0) {
        let deepCoins = yield this.getCoins(this.deepbookv3DeepFeeType());
        deepCoin = buildInputCoin(
          txb,
          deepCoins,
          BigInt(payDeepFeeAmount),
          this.deepbookv3DeepFeeType()
        ).targetCoin;
      }
      const routerSwapParams = isBuilderFastRouterSwapParams(params) ? {
        routers: routerData,
        inputCoin: buildFromCoinRes.targetCoin,
        slippage,
        byAmountIn,
        txb,
        partner: partner != null ? partner : this.partner,
        deepbookv3DeepFee: deepCoin
      } : {
        routers: params.routers,
        inputCoin: buildFromCoinRes.targetCoin,
        slippage,
        byAmountIn,
        txb,
        partner: partner != null ? partner : this.partner,
        deepbookv3DeepFee: deepCoin
      };
      const targetCoin = yield this.routerSwap(routerSwapParams);
      if (CoinUtils.isSuiCoin(targetCoinType)) {
        txb.mergeCoins(txb.gas, [targetCoin]);
      } else {
        let targetCoins = yield this.getCoins(targetCoinType, refreshAllCoins);
        const targetCoinRes = buildInputCoin(
          txb,
          targetCoins,
          BigInt(0),
          targetCoinType
        );
        const packages = isBuilderFastRouterSwapParams(params) ? void 0 : params.routers.packages;
        const aggregatorV2PublishedAt = getAggregatorV2PublishedAt(
          this.publishedAtV2(),
          packages
        );
        txb.mergeCoins(targetCoinRes.targetCoin, [targetCoin]);
        if (targetCoinRes.isMintZeroCoin) {
          this.transferOrDestoryCoin(
            txb,
            targetCoinRes.targetCoin,
            targetCoinType,
            aggregatorV2PublishedAt
          );
        }
      }
    });
  }
  // Include cetusdeepbookv2flowxv2 & v3kriyav2 & v3turbosaftermathhaedalafsuivolobluemove
  publishedAtV2() {
    if (this.env === 0) {
      return "0x3864c7c59a4889fec05d1aae4bc9dba5a0e0940594b424fbed44cb3f6ac4c032";
    } else {
      return "0x52eae33adeb44de55cfb3f281d4cc9e02d976181c0952f5323648b5717b33934";
    }
  }
  // Include deepbookv3, scallop, bluefin
  publishedAtV2Extend() {
    if (this.env === 0) {
      return "0x39402d188b7231036e52266ebafad14413b4bf3daea4ac17115989444e6cd516";
    } else {
      return "0xabb6a81c8a216828e317719e06125de5bb2cb0fe8f9916ff8c023ca5be224c78";
    }
  }
  deepbookv3DeepFeeType() {
    if (this.env === 0) {
      return "0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP";
    } else {
      return "0x36dbef866a1d62bf7328989a10fb2f07d769f4ee587c0de4a0a256e57e0a58a8::deep::DEEP";
    }
  }
  transferOrDestoryCoin(txb, coin, coinType, aggregatorV2PublishedAt) {
    txb.moveCall({
      target: `${aggregatorV2PublishedAt}::utils::transfer_or_destroy_coin`,
      typeArguments: [coinType],
      arguments: [coin]
    });
  }
  checkCoinThresholdAndMergeCoin(txb, coins, coinType, expectedAmountOut, threshold, aggregatorV2ExtendPublishedAt) {
    let targetCoin = coins[0];
    if (coins.length > 1) {
      let vec = txb.makeMoveVec({ elements: coins.slice(1) });
      txb.moveCall({
        target: `${SUI_FRAMEWORK_ADDRESS}::pay::join_vec`,
        typeArguments: [coinType],
        arguments: [coins[0], vec]
      });
      targetCoin = coins[0];
    }
    if (this.overlayFeeRate === 0 || this.overlayFeeReceiver === "0x0") {
      txb.moveCall({
        target: `${aggregatorV2ExtendPublishedAt}::utils::check_coin_threshold_v1`,
        typeArguments: [coinType],
        arguments: [
          targetCoin,
          txb.pure.u64(expectedAmountOut),
          txb.pure.u64(threshold)
        ]
      });
    } else {
      txb.moveCall({
        target: `${aggregatorV2ExtendPublishedAt}::utils::check_coin_threshold_v2`,
        typeArguments: [coinType],
        arguments: [
          targetCoin,
          txb.pure.u64(expectedAmountOut),
          txb.pure.u64(threshold),
          txb.pure.u64(this.overlayFeeRate),
          txb.pure.address(this.overlayFeeReceiver)
        ]
      });
    }
    return targetCoin;
  }
  newDex(provider, pythPriceIDs, partner) {
    switch (provider) {
      case CETUS:
        return new Cetus(this.env, partner);
      case DEEPBOOKV2:
        return new DeepbookV2(this.env);
      case DEEPBOOKV3:
        return new DeepbookV3(this.env);
      case KRIYA:
        return new KriyaV2(this.env);
      case KRIYAV3:
        return new KriyaV3(this.env);
      case FLOWXV2:
        return new FlowxV2(this.env);
      case FLOWXV3:
        return new FlowxV3(this.env);
      case TURBOS:
        return new Turbos(this.env);
      case AFTERMATH2:
        return new Aftermath(this.env);
      case HAEDAL2:
        return new Haedal(this.env);
      case AFSUI:
        return new Afsui(this.env);
      case VOLO2:
        return new Volo(this.env);
      case BLUEMOVE:
        return new Bluemove(this.env);
      case SCALLOP2:
        return new Scallop(this.env);
      case SUILEND:
        return new Suilend(this.env);
      case SPRINGSUI:
        return new Suilend(this.env);
      case BLUEFIN:
        return new Bluefin(this.env);
      case HAEDALPMM:
        return new HaedalPmm(this.env, pythPriceIDs);
      case ALPHAFI:
        return new Alphafi(this.env);
      case STEAMM:
        return new Steamm(this.env);
      case METASTABLE:
        return new Metastable(this.env, pythPriceIDs);
      case OBRIC:
        return new Obric(this.env, pythPriceIDs);
      case HAWAL:
        return new HaWAL(this.env);
      default:
        throw new Error(`Unsupported dex ${provider}`);
    }
  }
  signAndExecuteTransaction(txb, signer) {
    return __async(this, null, function* () {
      const res = yield this.client.signAndExecuteTransaction({
        transaction: txb,
        signer,
        options: {
          showEffects: true,
          showEvents: true,
          showInput: true,
          showBalanceChanges: true
        }
      });
      return res;
    });
  }
  devInspectTransactionBlock(txb) {
    return __async(this, null, function* () {
      const res = yield this.client.devInspectTransactionBlock({
        transactionBlock: txb,
        sender: this.signer
      });
      return res;
    });
  }
  sendTransaction(txb, signer) {
    return __async(this, null, function* () {
      const res = yield this.client.signAndExecuteTransaction({
        transaction: txb,
        signer
      });
      return res;
    });
  }
  getDeepbookV3Config() {
    return __async(this, null, function* () {
      const res = yield getDeepbookV3Config(this.endpoint);
      if (res) {
        return res.data;
      }
      return null;
    });
  }
  updatePythPriceIDs(priceIDs, txb) {
    return __async(this, null, function* () {
      let priceUpdateData = null;
      let lastError = null;
      for (const connection of this.pythConnections) {
        try {
          priceUpdateData = yield connection.getPriceFeedsUpdateData(priceIDs);
          break;
        } catch (e) {
          lastError = e;
          console.log("Error: ", e);
          continue;
        }
      }
      if (priceUpdateData == null) {
        throw new Error(
          `All Pyth price nodes are unavailable. Cannot fetch price data. Please switch to or add new available Pyth nodes. Detailed error: ${lastError == null ? void 0 : lastError.message}`
        );
      }
      let priceInfoObjectIds = [];
      try {
        priceInfoObjectIds = yield this.pythClient.updatePriceFeeds(
          txb,
          priceUpdateData,
          priceIDs
        );
      } catch (e) {
        throw new Error(`All Pyth price nodes are unavailable. Cannot fetch price data. Please switch to or add new available Pyth nodes in the pythUrls parameter when initializing AggregatorClient, for example: new AggregatorClient({ pythUrls: ["https://your-pyth-node-url"] }). Detailed error: ${e}`);
      }
      let priceInfoObjectIdsMap = /* @__PURE__ */ new Map();
      for (let i = 0; i < priceIDs.length; i++) {
        priceInfoObjectIdsMap.set(priceIDs[i], priceInfoObjectIds[i]);
      }
      return priceInfoObjectIdsMap;
    });
  }
};
_AggregatorClient.CONFIG = {
  [
    1
    /* Testnet */
  ]: {
    wormholeStateId: "0x31358d198147da50db32eda2562951d53973a0c0ad5ed738e9b17d88b213d790",
    pythStateId: "0x243759059f4c3111179da5878c12f68d612c21a8d54d85edc86164bb18be1c7c"
  },
  [
    0
    /* Mainnet */
  ]: {
    wormholeStateId: "0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c",
    pythStateId: "0x1f9310238ee9298fb703c3419030b35b22bb1cc37113e3bb5007c99aec79e5b8"
  }
};
var AggregatorClient23 = _AggregatorClient;
function findPythPriceIDs(routes) {
  const priceIDs = /* @__PURE__ */ new Set();
  for (const route of routes) {
    for (const path of route.path) {
      if (path.provider === HAEDALPMM) {
        if (path.extendedDetails && path.extendedDetails.haedalPmmBasePriceSeed && path.extendedDetails.haedalPmmQuotePriceSeed) {
          priceIDs.add(path.extendedDetails.haedalPmmBasePriceSeed);
          priceIDs.add(path.extendedDetails.haedalPmmQuotePriceSeed);
        }
      }
      if (path.provider === METASTABLE) {
        if (path.extendedDetails && path.extendedDetails.metastablePriceSeed) {
          priceIDs.add(path.extendedDetails.metastablePriceSeed);
        }
        if (path.extendedDetails && path.extendedDetails.metastableETHPriceSeed) {
          priceIDs.add(path.extendedDetails.metastableETHPriceSeed);
        }
      }
      if (path.provider === OBRIC) {
        if (path.extendedDetails && path.extendedDetails.obricCoinAPriceSeed) {
          priceIDs.add(path.extendedDetails.obricCoinAPriceSeed);
        }
        if (path.extendedDetails && path.extendedDetails.obricCoinBPriceSeed) {
          priceIDs.add(path.extendedDetails.obricCoinBPriceSeed);
        }
      }
    }
  }
  return Array.from(priceIDs);
}
function parseRouterResponse(data, byAmountIn) {
  let totalDeepFee = 0;
  for (const route of data.routes) {
    for (const path of route.path) {
      if (path.extended_details && path.extended_details.deepbookv3_deep_fee) {
        totalDeepFee += Number(path.extended_details.deepbookv3_deep_fee);
      }
    }
  }
  let packages = void 0;
  if (data.packages != null) {
    packages = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(data.packages)) {
      packages.set(key, value);
    }
  }
  let routerData = {
    amountIn: new import_bn5.default(data.amount_in.toString()),
    amountOut: new import_bn5.default(data.amount_out.toString()),
    byAmountIn,
    insufficientLiquidity: false,
    routes: data.routes.map((route) => {
      return {
        path: route.path.map((path) => {
          var _a7, _b3, _c, _d, _e3, _f, _g, _h, _i2, _j, _k, _l, _m, _n2, _o2, _p, _q, _r2, _s, _t, _u2, _v, _w, _x, _y;
          let version;
          if (path.provider === AFTERMATH2) {
            version = path.extended_details.aftermath_pool_flatness === 0 ? "v2" : "v3";
          }
          let extendedDetails;
          if (path.provider === TURBOS || path.provider === AFTERMATH2 || path.provider === CETUS || path.provider === DEEPBOOKV3 || path.provider === SCALLOP2 || path.provider === HAEDALPMM || path.provider === STEAMM || path.provider === METASTABLE || path.provider === OBRIC) {
            extendedDetails = {
              aftermathLpSupplyType: (_a7 = path.extended_details) == null ? void 0 : _a7.aftermath_lp_supply_type,
              turbosFeeType: (_b3 = path.extended_details) == null ? void 0 : _b3.turbos_fee_type,
              afterSqrtPrice: (_c = path.extended_details) == null ? void 0 : _c.after_sqrt_price,
              deepbookv3DeepFee: (_d = path.extended_details) == null ? void 0 : _d.deepbookv3_deep_fee,
              scallopScoinTreasury: (_e3 = path.extended_details) == null ? void 0 : _e3.scallop_scoin_treasury,
              haedalPmmBasePriceSeed: (_f = path.extended_details) == null ? void 0 : _f.haedal_pmm_base_price_seed,
              haedalPmmQuotePriceSeed: (_g = path.extended_details) == null ? void 0 : _g.haedal_pmm_quote_price_seed,
              steammBankA: (_h = path.extended_details) == null ? void 0 : _h.steamm_bank_a,
              steammBankB: (_i2 = path.extended_details) == null ? void 0 : _i2.steamm_bank_b,
              steammLendingMarket: (_j = path.extended_details) == null ? void 0 : _j.steamm_lending_market,
              steammLendingMarketType: (_k = path.extended_details) == null ? void 0 : _k.steamm_lending_market_type,
              steammBCoinAType: (_l = path.extended_details) == null ? void 0 : _l.steamm_btoken_a_type,
              steammBCoinBType: (_m = path.extended_details) == null ? void 0 : _m.steamm_btoken_b_type,
              steammLPToken: (_n2 = path.extended_details) == null ? void 0 : _n2.steamm_lp_token_type,
              metastablePriceSeed: (_o2 = path.extended_details) == null ? void 0 : _o2.metastable_price_seed,
              metastableETHPriceSeed: (_p = path.extended_details) == null ? void 0 : _p.metastable_eth_price_seed,
              metastableWhitelistedAppId: (_q = path.extended_details) == null ? void 0 : _q.metastable_whitelisted_app_id,
              metastableCreateCapPkgId: (_r2 = path.extended_details) == null ? void 0 : _r2.metastable_create_cap_pkg_id,
              metastableCreateCapModule: (_s = path.extended_details) == null ? void 0 : _s.metastable_create_cap_module,
              metastableCreateCapAllTypeParams: (_t = path.extended_details) == null ? void 0 : _t.metastable_create_cap_all_type_params,
              metastableRegistryId: (_u2 = path.extended_details) == null ? void 0 : _u2.metastable_registry_id,
              obricCoinAPriceSeed: (_v = path.extended_details) == null ? void 0 : _v.obric_coin_a_price_seed,
              obricCoinBPriceSeed: (_w = path.extended_details) == null ? void 0 : _w.obric_coin_b_price_seed,
              obricCoinAPriceId: (_x = path.extended_details) == null ? void 0 : _x.obric_coin_a_price_id,
              obricCoinBPriceId: (_y = path.extended_details) == null ? void 0 : _y.obric_coin_b_price_id
            };
          }
          return {
            id: path.id,
            direction: path.direction,
            provider: path.provider,
            from: path.from,
            target: path.target,
            feeRate: path.fee_rate,
            amountIn: path.amount_in,
            amountOut: path.amount_out,
            extendedDetails,
            version
          };
        }),
        amountIn: new import_bn5.default(route.amount_in.toString()),
        amountOut: new import_bn5.default(route.amount_out.toString()),
        initialPrice: new decimal_default2(route.initial_price.toString())
      };
    }),
    totalDeepFee,
    packages
  };
  return routerData;
}
var CLOCK_ADDRESS = SUI_CLOCK_OBJECT_ID;
var AGGREGATOR_V2 = "aggregator_v2";
var AGGREGATOR_V2_EXTEND = "aggregator_v2_extend";
function getAggregatorV2PublishedAt(aggregatorV2PublishedAt, packages) {
  var _a7;
  if (packages instanceof Map) {
    return (_a7 = packages.get(AGGREGATOR_V2)) != null ? _a7 : aggregatorV2PublishedAt;
  }
  return aggregatorV2PublishedAt;
}
function getAggregatorV2ExtendPublishedAt(aggregatorV2ExtendPublishedAt, packages) {
  var _a7;
  if (packages instanceof Map) {
    return (_a7 = packages.get(AGGREGATOR_V2_EXTEND)) != null ? _a7 : aggregatorV2ExtendPublishedAt;
  }
  return aggregatorV2ExtendPublishedAt;
}
var import_bn6 = __toESM3(require_bn2());
function processEndpoint(endpoint) {
  if (endpoint.endsWith("/find_routes")) {
    return endpoint.replace("/find_routes", "");
  }
  return endpoint;
}
var import_bn7 = __toESM3(require_bn2());
var SDK_VERSION = 1000600;
function getRouterResult(endpoint, apiKey, params, overlayFee, overlayFeeReceiver) {
  return __async(this, null, function* () {
    let response;
    if (params.liquidityChanges && params.liquidityChanges.length > 0) {
      response = yield postRouterWithLiquidityChanges(endpoint, params);
    } else {
      response = yield getRouter(endpoint, apiKey, params);
    }
    if (!response) {
      return null;
    }
    if (!response.ok) {
      let errorCode = 10001;
      if (response.status === 429) {
        errorCode = 10005;
      }
      return {
        amountIn: ZERO,
        amountOut: ZERO,
        routes: [],
        byAmountIn: params.byAmountIn,
        insufficientLiquidity: false,
        error: {
          code: errorCode,
          msg: getAggregatorServerErrorMessage(errorCode)
        }
      };
    }
    const data = yield response.json();
    const insufficientLiquidity = data.msg === "liquidity is not enough";
    if (data.msg && data.msg.indexOf("HoneyPot scam") > -1) {
      return {
        amountIn: ZERO,
        amountOut: ZERO,
        routes: [],
        byAmountIn: params.byAmountIn,
        insufficientLiquidity,
        error: {
          code: 10004,
          msg: getAggregatorServerErrorMessage(
            10004
            /* HoneyPot */
          )
        }
      };
    }
    if (data.data != null) {
      const res = parseRouterResponse(data.data, params.byAmountIn);
      if (overlayFee > 0 && overlayFeeReceiver !== "0x0") {
        if (params.byAmountIn) {
          const overlayFeeAmount = res.amountOut.mul(new import_bn7.default(overlayFee)).div(new import_bn7.default(1e6));
          res.overlayFee = Number(overlayFeeAmount.toString());
          res.amountOut = res.amountOut.sub(overlayFeeAmount);
        } else {
          const overlayFeeAmount = res.amountIn.mul(new import_bn7.default(overlayFee)).div(new import_bn7.default(1e6));
          res.overlayFee = Number(overlayFeeAmount.toString());
          res.amountIn = res.amountIn.add(overlayFeeAmount);
        }
      }
      return res;
    }
    return {
      amountIn: ZERO,
      amountOut: ZERO,
      routes: [],
      insufficientLiquidity,
      byAmountIn: params.byAmountIn,
      error: {
        code: 10003,
        msg: getAggregatorServerErrorMessage(
          10003
          /* InsufficientLiquidity */
        )
      }
    };
  });
}
function getRouter(endpoint, apiKey, params) {
  return __async(this, null, function* () {
    try {
      const {
        from,
        target,
        amount,
        byAmountIn,
        depth,
        splitAlgorithm,
        splitFactor,
        splitCount,
        providers
      } = params;
      const fromCoin = completionCoin(from);
      const targetCoin = completionCoin(target);
      let url = `${endpoint}/find_routes?from=${fromCoin}&target=${targetCoin}&amount=${amount.toString()}&by_amount_in=${byAmountIn}`;
      if (depth) {
        url += `&depth=${depth}`;
      }
      if (splitAlgorithm) {
        url += `&split_algorithm=${splitAlgorithm}`;
      }
      if (splitFactor) {
        url += `&split_factor=${splitFactor}`;
      }
      if (splitCount) {
        url += `&split_count=${splitCount}`;
      }
      if (providers) {
        if (providers.length > 0) {
          url += `&providers=${providers.join(",")}`;
        }
      }
      if (apiKey.length > 0) {
        url += `&apiKey=${apiKey}`;
      }
      url += `&v=${SDK_VERSION}`;
      const response = yield fetch(url);
      return response;
    } catch (error) {
      console.error(error);
      return null;
    }
  });
}
function postRouterWithLiquidityChanges(endpoint, params) {
  return __async(this, null, function* () {
    const {
      from,
      target,
      amount,
      byAmountIn,
      depth,
      splitAlgorithm,
      splitFactor,
      splitCount,
      providers,
      liquidityChanges
    } = params;
    const fromCoin = completionCoin(from);
    const targetCoin = completionCoin(target);
    const url = `${endpoint}/find_routes`;
    const providersStr = providers == null ? void 0 : providers.join(",");
    const requestData = {
      from: fromCoin,
      target: targetCoin,
      amount: Number(amount.toString()),
      by_amount_in: byAmountIn,
      depth,
      split_algorithm: splitAlgorithm,
      split_factor: splitFactor,
      split_count: splitCount,
      providers: providersStr,
      liquidity_changes: liquidityChanges.map((change) => ({
        pool: change.poolID,
        tick_lower: change.ticklower,
        tick_upper: change.tickUpper,
        delta_liquidity: change.deltaLiquidity
      })),
      v: SDK_VERSION
    };
    try {
      const response = yield fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData)
      });
      return response;
    } catch (error) {
      console.error("Error:", error);
      return null;
    }
  });
}
function getDeepbookV3Config(endpoint) {
  return __async(this, null, function* () {
    const url = `${endpoint}/deepbookv3_config`;
    try {
      const response = yield fetch(url);
      return response.json();
    } catch (error) {
      console.error("Error:", error);
      return null;
    }
  });
}
var Env = /* @__PURE__ */ ((Env2) => {
  Env2[Env2["Mainnet"] = 0] = "Mainnet";
  Env2[Env2["Testnet"] = 1] = "Testnet";
  return Env2;
})(Env || {});

// ../../node_modules/.pnpm/@cetusprotocol+vaults-sdk@0.0.0-experimental-20250414153224_@jest+transform@29.7.0_@jest+type_wkprgkljhryhol365ibhpttqvq/node_modules/@cetusprotocol/vaults-sdk/dist/index.mjs
var import_bn27 = __toESM(require_bn(), 1);
var import_bn28 = __toESM(require_bn(), 1);
var import_bn29 = __toESM(require_bn(), 1);
function Ce(o, e) {
  var t = { label: 0, sent: function() {
    if (r2[0] & 1) throw r2[1];
    return r2[1];
  }, trys: [], ops: [] }, n, i, r2, s;
  return s = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function c(a) {
    return function(l) {
      return u([a, l]);
    };
  }
  function u(a) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (n = 1, i && (r2 = a[0] & 2 ? i.return : a[0] ? i.throw || ((r2 = i.return) && r2.call(i), 0) : i.next) && !(r2 = r2.call(i, a[1])).done) return r2;
      switch (i = 0, r2 && (a = [a[0] & 2, r2.value]), a[0]) {
        case 0:
        case 1:
          r2 = a;
          break;
        case 4:
          return t.label++, { value: a[1], done: false };
        case 5:
          t.label++, i = a[1], a = [0];
          continue;
        case 7:
          a = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (r2 = t.trys, !(r2 = r2.length > 0 && r2[r2.length - 1]) && (a[0] === 6 || a[0] === 2)) {
            t = 0;
            continue;
          }
          if (a[0] === 3 && (!r2 || a[1] > r2[0] && a[1] < r2[3])) {
            t.label = a[1];
            break;
          }
          if (a[0] === 6 && t.label < r2[1]) {
            t.label = r2[1], r2 = a;
            break;
          }
          if (r2 && t.label < r2[2]) {
            t.label = r2[2], t.ops.push(a);
            break;
          }
          r2[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      a = e.call(o, t);
    } catch (l) {
      a = [6, l], i = 0;
    } finally {
      n = r2 = 0;
    }
    if (a[0] & 5) throw a[1];
    return { value: a[0] ? a[1] : void 0, done: true };
  }
}
var se2;
(function(o) {
  o[o.EQUAL = 0] = "EQUAL", o[o.GREATER = 1] = "GREATER", o[o.LESS = -1] = "LESS";
})(se2 || (se2 = {}));
var Kt = function() {
  function o(e) {
    this.compare = e || o.defaultCompareFunction;
  }
  return o.defaultCompareFunction = function(e, t) {
    return e === t ? se2.EQUAL : e < t ? se2.LESS : se2.GREATER;
  }, o.prototype.equal = function(e, t) {
    return this.compare(e, t) === se2.EQUAL;
  }, o.prototype.lessThan = function(e, t) {
    return this.compare(e, t) === se2.LESS;
  }, o.prototype.greaterThan = function(e, t) {
    return this.compare(e, t) === se2.GREATER;
  }, o.prototype.lessThanOrEqual = function(e, t) {
    return this.lessThan(e, t) || this.equal(e, t);
  }, o.prototype.greaterThanOrEqual = function(e, t) {
    return this.greaterThan(e, t) || this.equal(e, t);
  }, o.prototype.reverse = function() {
    var e = this.compare;
    this.compare = function(t, n) {
      return e(n, t);
    };
  }, o;
}();
var it = Kt;
var rt2 = /* @__PURE__ */ function() {
  function o(e) {
    this.value = e, this.next = null;
  }
  return o;
}();
var st2 = /* @__PURE__ */ function() {
  function o(e) {
    this.value = e, this.next = null, this.prev = null;
  }
  return o;
}();
var Ne = function(o, e) {
  return Ne = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) n.hasOwnProperty(i) && (t[i] = n[i]);
  }, Ne(o, e);
};
function de2(o, e) {
  Ne(o, e);
  function t() {
    this.constructor = o;
  }
  o.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function _e2(o, e) {
  var t = { label: 0, sent: function() {
    if (r2[0] & 1) throw r2[1];
    return r2[1];
  }, trys: [], ops: [] }, n, i, r2, s;
  return s = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function c(a) {
    return function(l) {
      return u([a, l]);
    };
  }
  function u(a) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (n = 1, i && (r2 = a[0] & 2 ? i.return : a[0] ? i.throw || ((r2 = i.return) && r2.call(i), 0) : i.next) && !(r2 = r2.call(i, a[1])).done) return r2;
      switch (i = 0, r2 && (a = [a[0] & 2, r2.value]), a[0]) {
        case 0:
        case 1:
          r2 = a;
          break;
        case 4:
          return t.label++, { value: a[1], done: false };
        case 5:
          t.label++, i = a[1], a = [0];
          continue;
        case 7:
          a = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (r2 = t.trys, !(r2 = r2.length > 0 && r2[r2.length - 1]) && (a[0] === 6 || a[0] === 2)) {
            t = 0;
            continue;
          }
          if (a[0] === 3 && (!r2 || a[1] > r2[0] && a[1] < r2[3])) {
            t.label = a[1];
            break;
          }
          if (a[0] === 6 && t.label < r2[1]) {
            t.label = r2[1], r2 = a;
            break;
          }
          if (r2 && t.label < r2[2]) {
            t.label = r2[2], t.ops.push(a);
            break;
          }
          r2[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      a = e.call(o, t);
    } catch (l) {
      a = [6, l], i = 0;
    } finally {
      n = r2 = 0;
    }
    if (a[0] & 5) throw a[1];
    return { value: a[0] ? a[1] : void 0, done: true };
  }
}
function Wt(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t) return o;
  var n = t.call(o), i, r2 = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) r2.push(i.value);
  } catch (c) {
    s = { error: c };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (s) throw s.error;
    }
  }
  return r2;
}
function Z() {
  for (var o = [], e = 0; e < arguments.length; e++) o = o.concat(Wt(arguments[e]));
  return o;
}
var Xt2 = "obfuse error occur";
function Te(o, e) {
  if (!o) throw new Error("[linked-list] " + (e || Xt2));
}
var Jt = -1;
var at2 = function() {
  function o() {
    for (var e = this, t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
    this._head = null, this._tail = null, this._length = 0, this.compare = new it(), t.length > 0 && t.forEach(function(i) {
      e.append(i);
    });
  }
  return Object.defineProperty(o.prototype, "head", { get: function() {
    return this._head ? this._head.value : void 0;
  }, enumerable: true, configurable: true }), Object.defineProperty(o.prototype, "tail", { get: function() {
    return this._tail ? this._tail.value : void 0;
  }, enumerable: true, configurable: true }), Object.defineProperty(o.prototype, "length", { get: function() {
    return this._length;
  }, enumerable: true, configurable: true }), Object.defineProperty(o.prototype, "loopLength", { get: function() {
    var e = false, t = 1;
    if (!this._head) return 0;
    for (var n = this._head, i = this._head; i.next && i.next.next; ) if (i = i.next.next, n = n.next, n === i) {
      e = true;
      break;
    }
    if (e) {
      for (i = i.next; n !== i; ) t++, i = i.next;
      return t;
    } else return 0;
  }, enumerable: true, configurable: true }), o.prototype.getNode = function(e) {
    var t = this._length;
    Te(t > 0 && e >= 0 && e < t, "[linked-list] index " + e + " out of scope of list, which length is " + t);
    for (var n = this._head, i = 0; i < e; ) n = n.next, i++;
    return n;
  }, o.prototype.get = function(e) {
    var t = this.getNode(e);
    return t ? t.value : null;
  }, o.prototype.find = function(e) {
    var t = e.value, n = e.callback;
    if (!this._head) return null;
    for (var i = this._head; i; ) {
      if (n && n(i.value) || t !== void 0 && this.compare.equal(i.value, t)) return i;
      i = i.next;
    }
    return null;
  }, o.prototype.indexOf = function(e) {
    if (!this._head) return Jt;
    for (var t = this._head, n = -1; t.next; ) {
      if (n++, this.compare.equal(t.value, e)) return n;
      t = t.next;
    }
    return t === this._tail && this.compare.equal(t.value, e) && (n += 1), n;
  }, o.prototype.first = function(e) {
    Te(e >= 0, "[linked-list] param 'num' (" + e + ") should not less than 0");
    for (var t = this.iterator(), n = [], i = Math.min(e, this.length), r2 = 0; r2 < i; r2++) {
      var s = t.next();
      n.push(s.value);
    }
    return n;
  }, o.prototype.toArray = function() {
    return Z(this);
  }, o.prototype.isEmpty = function() {
    return this._head === null;
  }, o.prototype.iterator = function() {
    var e;
    return _e2(this, function(t) {
      switch (t.label) {
        case 0:
          e = this._head, t.label = 1;
        case 1:
          return e ? [4, e.value] : [3, 3];
        case 2:
          return t.sent(), e = e.next, [3, 1];
        case 3:
          return [2];
      }
    });
  }, o.prototype[Symbol.iterator] = function() {
    return this.iterator();
  }, o;
}();
var ue = function(o) {
  de2(e, o);
  function e() {
    for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
    return o.apply(this, Z(t)) || this;
  }
  return e.prototype.append = function(t) {
    var n = new rt2(t);
    return this._tail ? (this._tail.next = n, this._tail = n) : this._head = this._tail = n, this._length++, true;
  }, e.prototype.prepend = function(t) {
    var n = new rt2(t);
    return this._head ? (n.next = this._head, this._head = n) : this._head = this._tail = n, this._length++, true;
  }, e.prototype.remove = function(t) {
    var n = this._head;
    if (n) {
      if (this.compare.equal(n.value, t)) return n.next ? (this._head = n.next, n.next = null) : this._head = this._tail = null, this._length--, t;
      for (var i = n; ; ) {
        if (this.compare.equal(n.value, t)) return n.next ? i.next = n.next : (this._tail = i, this._tail.next = null), n.next = null, this._length--, t;
        if (n.next) i = n, n = n.next;
        else return;
      }
    }
  }, e.prototype.removeHead = function() {
    var t = this._head;
    if (t) return this._head.next ? (this._head = t.next, t.next = null) : (this._head = null, this._tail = null), this._length--, t.value;
  }, e.prototype.removeTail = function() {
    var t = this._tail;
    if (t) {
      if (!this._head.next) this._head = null, this._tail = null;
      else {
        for (var n = this._head; n.next !== t; ) n = n.next;
        n.next = null, this._tail = n;
      }
      return this._length--, t.value;
    }
  }, e.prototype.reverse = function() {
    if (this._head) {
      var t = this._head, n = null, i;
      for (this._tail = this._head; t !== null; ) i = t.next, t.next = n, n = t, t = i;
      this._head = n;
    }
  }, e.prototype.clone = function() {
    var t = this.toArray();
    return new (e.bind.apply(e, Z([void 0], t)))();
  }, e;
}(at2);
var zt = function(o) {
  de2(e, o);
  function e() {
    for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
    var i = o.apply(this, Z(t)) || this;
    return i.cyclization(), i;
  }
  return e.prototype.iterator = function() {
    var t;
    return _e2(this, function(n) {
      switch (n.label) {
        case 0:
          t = this._head, n.label = 1;
        case 1:
          return t ? [4, t.value] : [3, 3];
        case 2:
          return n.sent(), t = t.next, t === this._head && (t = null), [3, 1];
        case 3:
          return [2];
      }
    });
  }, e.prototype.circleIterator = function() {
    var t;
    return _e2(this, function(n) {
      switch (n.label) {
        case 0:
          t = this._head, n.label = 1;
        case 1:
          return t ? [4, t.value] : [3, 3];
        case 2:
          return n.sent(), t = t.next, [3, 1];
        case 3:
          return [2];
      }
    });
  }, e.prototype[Symbol.iterator] = function() {
    return this.iterator();
  }, e.prototype.mapToNormalListFn = function(t) {
    for (var n = [], i = 1; i < arguments.length; i++) n[i - 1] = arguments[i];
    this.breakCircle();
    var r2 = o.prototype[t].apply(this, n);
    return this.cyclization(), r2;
  }, e.prototype.getNode = function(t) {
    return this.mapToNormalListFn("getNode", t);
  }, e.prototype.append = function(t) {
    return this.mapToNormalListFn("append", t);
  }, e.prototype.prepend = function(t) {
    return this.mapToNormalListFn("prepend", t);
  }, e.prototype.find = function(t) {
    return this.mapToNormalListFn("find", t);
  }, e.prototype.indexOf = function(t) {
    return this.mapToNormalListFn("indexOf", t);
  }, e.prototype.remove = function(t) {
    return this.mapToNormalListFn("remove", t);
  }, e.prototype.removeHead = function() {
    return this.mapToNormalListFn("removeHead");
  }, e.prototype.removeTail = function() {
    return this.mapToNormalListFn("removeTail");
  }, e.prototype.first = function(t) {
    Te(t >= 0, "[linked-list] param 'num' (" + t + ") should not less than 0");
    for (var n = this.circleIterator(), i = [], r2 = 0; r2 < t; r2++) {
      var s = n.next();
      i.push(s.value);
    }
    return i;
  }, e.prototype.toArray = function() {
    return this.mapToNormalListFn("toArray");
  }, e.prototype.reverse = function() {
    return this.mapToNormalListFn("reverse");
  }, e;
}(ue);
var io = function(o) {
  de2(e, o);
  function e() {
    for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
    var i = o.apply(this, Z(t)) || this;
    return i.cyclization(), i;
  }
  return e.prototype.breakCircle = function() {
    this._tail && this._tail.next === this._head && (this._tail.next = null);
  }, e.prototype.cyclization = function() {
    this._tail && this._tail.next === null && (this._tail.next = this._head);
  }, e.prototype.clone = function() {
    var t = this.toArray();
    return new (e.bind.apply(e, Z([void 0], t)))();
  }, e;
}(zt);
var Ht2 = function(o) {
  de2(e, o);
  function e() {
    for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
    return o.apply(this, Z(t)) || this;
  }
  return e.prototype.append = function(t) {
    var n = new st2(t);
    return this._tail ? (this._tail.next = n, n.prev = this._tail, this._tail = n) : this._head = this._tail = n, this._length++, true;
  }, e.prototype.prepend = function(t) {
    var n = new st2(t);
    return this._head ? (n.next = this._head, this._head.prev = n, this._head = n) : this._head = this._tail = n, this._length++, true;
  }, e.prototype.remove = function(t) {
    var n = this._head;
    if (n) {
      if (this.compare.equal(n.value, t)) return n.next ? (this._head = n.next, this._head.prev = null, n.next = n.prev = null) : this._head = this._tail = null, this._length--, t;
      for (; ; ) {
        if (this.compare.equal(n.value, t)) return n.next ? (n.prev.next = n.next, n.next.prev = n.prev, n.next = n.prev = null) : (n.prev.next = null, this._tail = n.prev, n.next = n.prev = null), this._length--, n.value;
        if (n.next) n = n.next;
        else return;
      }
    }
  }, e.prototype.removeHead = function() {
    var t = this._head;
    if (t) return this._head.next ? (t.next.prev = null, this._head = t.next, t.next = null) : (this._head = null, this._tail = null), this._length--, t.value;
  }, e.prototype.removeTail = function() {
    var t = this._tail;
    if (t) return this._head.next ? (t.prev.next = null, this._tail = t.prev, t.next = t.prev = null) : (this._head = null, this._tail = null), this._length--, t.value;
  }, e.prototype.reverse = function() {
    if (this._head) {
      var t = this._head, n = null, i;
      for (this._tail = this._head; t !== null; ) i = t.next, t.next = n, t.prev = i, n = t, t = i;
      this._head = n;
    }
  }, e.prototype.clone = function() {
    var t = this.toArray();
    return new (e.bind.apply(e, Z([void 0], t)))();
  }, e;
}(at2);
var Zt2 = function(o) {
  de2(e, o);
  function e() {
    for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
    var i = o.apply(this, Z(t)) || this;
    return i.cyclization(), i;
  }
  return e.prototype.iterator = function() {
    var t;
    return _e2(this, function(n) {
      switch (n.label) {
        case 0:
          t = this._head, n.label = 1;
        case 1:
          return t ? [4, t.value] : [3, 3];
        case 2:
          return n.sent(), t = t.next, t === this._head && (t = null), [3, 1];
        case 3:
          return [2];
      }
    });
  }, e.prototype.circleIterator = function() {
    var t;
    return _e2(this, function(n) {
      switch (n.label) {
        case 0:
          t = this._head, n.label = 1;
        case 1:
          return t ? [4, t.value] : [3, 3];
        case 2:
          return n.sent(), t = t.next, [3, 1];
        case 3:
          return [2];
      }
    });
  }, e.prototype[Symbol.iterator] = function() {
    return this.iterator();
  }, e.prototype.mapToNormalListFn = function(t) {
    for (var n = [], i = 1; i < arguments.length; i++) n[i - 1] = arguments[i];
    this.breakCircle();
    var r2 = o.prototype[t].apply(this, n);
    return this.cyclization(), r2;
  }, e.prototype.getNode = function(t) {
    return this.mapToNormalListFn("getNode", t);
  }, e.prototype.append = function(t) {
    return this.mapToNormalListFn("append", t);
  }, e.prototype.prepend = function(t) {
    return this.mapToNormalListFn("prepend", t);
  }, e.prototype.find = function(t) {
    return this.mapToNormalListFn("find", t);
  }, e.prototype.indexOf = function(t) {
    return this.mapToNormalListFn("indexOf", t);
  }, e.prototype.remove = function(t) {
    return this.mapToNormalListFn("remove", t);
  }, e.prototype.removeHead = function() {
    return this.mapToNormalListFn("removeHead");
  }, e.prototype.removeTail = function() {
    return this.mapToNormalListFn("removeTail");
  }, e.prototype.first = function(t) {
    Te(t >= 0, "[linked-list] param 'num' (" + t + ") should not less than 0");
    for (var n = this.circleIterator(), i = [], r2 = 0; r2 < t; r2++) {
      var s = n.next();
      i.push(s.value);
    }
    return i;
  }, e.prototype.toArray = function() {
    return this.mapToNormalListFn("toArray");
  }, e.prototype.reverse = function() {
    return this.mapToNormalListFn("reverse");
  }, e;
}(Ht2);
var ro = function(o) {
  de2(e, o);
  function e() {
    for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
    var i = o.apply(this, Z(t)) || this;
    return i.cyclization(), i;
  }
  return e.prototype.breakCircle = function() {
    this._tail && this._head && this._tail.next === this._head && (this._tail.next = null, this._head.prev = null);
  }, e.prototype.cyclization = function() {
    this._head && this._tail && this._tail.next === null && (this._tail.next = this._head, this._head.prev = this._tail);
  }, e.prototype.clone = function() {
    var t = this.toArray();
    return new (e.bind.apply(e, Z([void 0], t)))();
  }, e;
}(Zt2);
function Qt2(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t) return o;
  var n = t.call(o), i, r2 = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) r2.push(i.value);
  } catch (c) {
    s = { error: c };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (s) throw s.error;
    }
  }
  return r2;
}
function Yt2() {
  for (var o = [], e = 0; e < arguments.length; e++) o = o.concat(Qt2(arguments[e]));
  return o;
}
var en2 = function() {
  function o() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    this.queue = new (ue.bind.apply(ue, Yt2([void 0], e)))();
  }
  return Object.defineProperty(o.prototype, "length", { get: function() {
    return this.queue.length;
  }, enumerable: true, configurable: true }), Object.defineProperty(o.prototype, "peek", { get: function() {
    return this.queue.head;
  }, enumerable: true, configurable: true }), o.prototype.isEmpty = function() {
    return this.queue.isEmpty();
  }, o.prototype.enqueue = function(e) {
    return this.queue.append(e);
  }, o.prototype.dequeue = function() {
    var e = this.queue.removeHead();
    return typeof e < "u" ? e : void 0;
  }, o.prototype.toArray = function() {
    return this.queue.toArray();
  }, o;
}();
var ct = en2;
function tn2(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t) return o;
  var n = t.call(o), i, r2 = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) r2.push(i.value);
  } catch (c) {
    s = { error: c };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (s) throw s.error;
    }
  }
  return r2;
}
function nn2() {
  for (var o = [], e = 0; e < arguments.length; e++) o = o.concat(tn2(arguments[e]));
  return o;
}
var on2 = function() {
  function o() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    this.stack = new (ue.bind.apply(ue, nn2([void 0], e)))();
  }
  return Object.defineProperty(o.prototype, "length", { get: function() {
    return this.stack.length;
  }, enumerable: true, configurable: true }), Object.defineProperty(o.prototype, "peek", { get: function() {
    return this.stack.tail;
  }, enumerable: true, configurable: true }), o.prototype.isEmpty = function() {
    return this.stack.isEmpty();
  }, o.prototype.push = function(e) {
    return this.stack.append(e);
  }, o.prototype.pop = function() {
    var e = this.stack.removeTail();
    return typeof e < "u" ? e : void 0;
  }, o.prototype.popBottom = function() {
    var e = this.stack.removeHead();
    return typeof e < "u" ? e : void 0;
  }, o.prototype.toArray = function() {
    return this.stack.toArray();
  }, o;
}();
var ke = on2;
var rn2 = function() {
  function o(e, t, n) {
    n === void 0 && (n = 0), this.startVertex = e, this.endVertex = t, this.weight = n;
  }
  return o.prototype.getKey = function() {
    var e = this.startVertex.getKey(), t = this.endVertex.getKey();
    return e + "_" + t;
  }, o.prototype.reverse = function() {
    var e = this.startVertex;
    return this.startVertex = this.endVertex, this.endVertex = e, this;
  }, o.prototype.clone = function() {
    return new o(this.startVertex, this.endVertex, this.weight);
  }, o.prototype.toString = function() {
    return this.getKey();
  }, o;
}();
function Le(o, e, t) {
  if (t === void 0 && (t = "cc-graph"), !o) throw new Error((t ? "[" + t + "]" : "") + " Invariant failed: " + e);
}
function sn2(o, e) {
  e === void 0 && (e = true);
  var t = typeof o < "u" && o !== null;
  return e ? t && o !== "undefined" && o !== "null" : t;
}
var an2 = function() {
  function o(e) {
    Le(sn2(e), "Graph vertex must have a value"), this.value = e, this.edges = /* @__PURE__ */ new Map();
  }
  return o.prototype.addEdge = function(e) {
    return this.edges.set(e.getKey(), e), this;
  }, o.prototype.deleteEdge = function(e) {
    this.edges.delete(e.getKey());
  }, o.prototype.getNeighbors = function() {
    var e = this, t = this.getEdges(), n = function(i) {
      return i.startVertex === e ? i.endVertex : i.startVertex;
    };
    return t.map(n);
  }, o.prototype.getEdges = function() {
    return Array.from(this.edges.values());
  }, o.prototype.getDegree = function() {
    return this.getEdges().length;
  }, o.prototype.hasEdge = function(e) {
    var t = this.getEdges().find(function(n) {
      return n === e;
    });
    return !!t;
  }, o.prototype.hasNeighbor = function(e) {
    var t = this.getEdges().find(function(n) {
      return n.startVertex === e || n.endVertex === e;
    });
    return !!t;
  }, o.prototype.findEdge = function(e) {
    var t = function(i) {
      return i.startVertex === e || i.endVertex === e;
    }, n = this.getEdges().find(t);
    return n || null;
  }, o.prototype.getKey = function() {
    return this.value;
  }, o.prototype.deleteAllEdges = function() {
    var e = this;
    return this.getEdges().forEach(function(t) {
      return e.deleteEdge(t);
    }), this;
  }, o.prototype.toString = function(e) {
    return e ? e(this.value) : "" + this.value;
  }, o;
}();
function ut2(o, e, t, n) {
  if (o) {
    e.push(o), n.set(o.getKey(), true);
    var i = o.getNeighbors().filter(function(r2) {
      return !n.get(r2.getKey());
    });
    t.push(i);
  }
}
function lt(o, e, t) {
  var n = o.pop();
  n && t.set(n.getKey(), false), e.pop();
}
var cn3 = function() {
  function o(e) {
    e === void 0 && (e = false), this.vertices = {}, this.edges = {}, this.isDirected = e;
  }
  return o.prototype.addVertex = function(e) {
    return this.vertices[e.getKey()] = e, this;
  }, o.prototype.getVertexByKey = function(e) {
    return this.vertices[e];
  }, o.prototype.getNeighbors = function(e) {
    return e.getNeighbors();
  }, o.prototype.getAllVertices = function() {
    return Object.values(this.vertices);
  }, o.prototype.getAllEdges = function() {
    return Object.values(this.edges);
  }, o.prototype.addEdge = function(e, t) {
    if (t === void 0 && (t = false), this.edges[e.getKey()]) {
      if (t) return this;
      Le(false, "Edge has already been added before");
    }
    var n = this.getVertexByKey(e.startVertex.getKey()), i = this.getVertexByKey(e.endVertex.getKey());
    if (n || (this.addVertex(e.startVertex), n = this.getVertexByKey(e.startVertex.getKey())), i || (this.addVertex(e.endVertex), i = this.getVertexByKey(e.endVertex.getKey())), this.edges[e.getKey()] = e, this.isDirected) n.addEdge(e);
    else {
      n.addEdge(e);
      var r2 = e.clone();
      i.addEdge(r2.reverse());
    }
    return this;
  }, o.prototype.deleteEdge = function(e, t) {
    if (t === void 0 && (t = false), !this.edges[e.getKey()]) {
      if (t) return this;
      Le(false, "Edge not found in graph");
    }
    delete this.edges[e.getKey()];
    var n = this.getVertexByKey(e.startVertex.getKey()), i = this.getVertexByKey(e.endVertex.getKey());
    return n.deleteEdge(e), i.deleteEdge(e), this;
  }, o.prototype.findEdge = function(e, t) {
    var n = this.getVertexByKey(e.getKey());
    return n ? n.findEdge(t) : null;
  }, o.prototype.getWeight = function() {
    return this.getAllEdges().reduce(function(e, t) {
      return e + t.weight;
    }, 0);
  }, o.prototype.reverse = function() {
    var e = this;
    return this.getAllEdges().forEach(function(t) {
      e.deleteEdge(t), t.reverse(), e.addEdge(t);
    }), this;
  }, o.prototype.getVerticesIndices = function() {
    var e = {};
    return this.getAllVertices().forEach(function(t, n) {
      e[t.getKey()] = n;
    }), e;
  }, o.prototype.getAdjacencyMatrix = function() {
    var e = this, t = this.getAllVertices(), n = this.getVerticesIndices(), i = Array(t.length).fill(null).map(function() {
      return Array(t.length).fill(1 / 0);
    });
    return t.forEach(function(r2, s) {
      r2.getNeighbors().forEach(function(c) {
        var u = n[c.getKey()], a = e.findEdge(r2, c);
        a && (i[s][u] = a.weight);
      });
    }), i;
  }, o.prototype.toString = function() {
    return Object.keys(this.vertices).toString();
  }, o.prototype.bfs = function(e) {
    var t, n, i;
    return Ce(this, function(r2) {
      switch (r2.label) {
        case 0:
          t = /* @__PURE__ */ new Map(), n = new ct(), n.enqueue(e), r2.label = 1;
        case 1:
          return n.isEmpty() ? [3, 4] : (i = n.dequeue(), i && !t.has(i.getKey()) ? [4, i] : [3, 3]);
        case 2:
          r2.sent(), t.set(i.getKey(), i), i.getNeighbors().forEach(function(s) {
            return n.enqueue(s);
          }), r2.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [2];
      }
    });
  }, o.prototype.dfs = function(e) {
    var t, n, i;
    return Ce(this, function(r2) {
      switch (r2.label) {
        case 0:
          t = /* @__PURE__ */ new Map(), n = new ke(), n.push(e), r2.label = 1;
        case 1:
          return n.isEmpty() ? [3, 4] : (i = n.pop(), i && !t.has(i.getKey()) ? [4, i] : [3, 3]);
        case 2:
          r2.sent(), t.set(i.getKey(), i), i.getNeighbors().forEach(function(s) {
            return n.push(s);
          }), r2.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [2];
      }
    });
  }, o.prototype.findAllPath = function(e, t) {
    var n, i, r2, s, c, u, a;
    return Ce(this, function(l) {
      switch (l.label) {
        case 0:
          return n = [], e !== t ? [3, 2] : (n.push(e), [4, n]);
        case 1:
          return l.sent(), [2];
        case 2:
          i = /* @__PURE__ */ new Map(), r2 = new ke(), s = new ke(), ut2(e, r2, s, i), l.label = 3;
        case 3:
          if (r2.isEmpty()) return [3, 6];
          if (c = s.pop(), c && c.length) u = c.shift(), s.push(c), u && ut2(u, r2, s, i);
          else return s.push(c), lt(r2, s, i), [3, 3];
          return a = r2.peek, a !== t ? [3, 5] : [4, r2.toArray()];
        case 4:
          l.sent(), lt(r2, s, i), l.label = 5;
        case 5:
          return [3, 3];
        case 6:
          return [2];
      }
    });
  }, o;
}();
var un2 = Object.defineProperty;
var ln4 = (o, e, t) => e in o ? un2(o, e, { enumerable: true, configurable: true, writable: true, value: t }) : o[e] = t;
var dn2 = (o, e, t) => (ln4(o, typeof e != "symbol" ? e + "" : e, t), t);
var At2 = 5 * 60 * 1e3;
var te = 24 * 60 * 60 * 1e3;
function ie2(o) {
  return Date.parse((/* @__PURE__ */ new Date()).toString()) + o;
}
var me = class {
  constructor(o, e = 0) {
    __publicField(this, "overdueTime");
    __publicField(this, "value");
    this.overdueTime = e, this.value = o;
  }
  isValid() {
    return this.value === null ? false : this.overdueTime === 0 ? true : !(Date.parse((/* @__PURE__ */ new Date()).toString()) > this.overdueTime);
  }
};
decimal_default.config({ precision: 64, rounding: decimal_default.ROUND_DOWN, toExpNeg: -64, toExpPos: 64 });
var W2 = decimal_default;
var q2 = class extends Error {
  constructor(o, e) {
    super(o);
    __publicField(this, "message");
    __publicField(this, "errorCode");
    this.message = o, this.errorCode = e;
  }
  static isClmmpoolsErrorCode(o, e) {
    return o instanceof q2 && o.errorCode === e;
  }
};
var E = new import_bn10.default(0);
var he = new import_bn10.default(1);
var xe2 = new import_bn10.default(2);
var Ro = xe2.pow(new import_bn10.default(128));
var Ge = xe2.pow(new import_bn10.default(64)).sub(he);
var pn2 = xe2.pow(new import_bn10.default(128)).sub(he);
var ee = class {
  static toX64_BN(o) {
    return o.mul(new import_bn10.default(2).pow(new import_bn10.default(64)));
  }
  static toX64_Decimal(o) {
    return o.mul(W2.pow(2, 64));
  }
  static toX64(o) {
    return new import_bn10.default(o.mul(W2.pow(2, 64)).floor().toFixed());
  }
  static fromX64(o) {
    return new W2(o.toString()).mul(W2.pow(2, -64));
  }
  static fromX64_Decimal(o) {
    return o.mul(W2.pow(2, -64));
  }
  static fromX64_BN(o) {
    return o.div(new import_bn10.default(2).pow(new import_bn10.default(64)));
  }
  static shiftRightRoundUp(o) {
    let e = o.shrn(64);
    return o.mod(Ge).gt(E) && (e = e.add(he)), e;
  }
  static divRoundUp(o, e) {
    return o.mod(e).eq(E) ? o.div(e) : o.div(e).add(new import_bn10.default(1));
  }
  static subUnderflowU128(o, e) {
    return o.lt(e) ? o.sub(e).add(pn2) : o.sub(e);
  }
  static checkUnsignedSub(o, e) {
    let t = o.sub(e);
    if (t.isNeg()) throw new q2("Unsigned integer sub overflow", "UnsignedIntegerOverflow");
    return t;
  }
  static checkMul(o, e, t) {
    let n = o.mul(e);
    if (this.isOverflow(n, t)) throw new q2("Multiplication overflow", "MultiplicationOverflow");
    return n;
  }
  static checkMulDivFloor(o, e, t, n) {
    if (t.eq(E)) throw new q2("Devide by zero", "DivideByZero");
    let i = o.mul(e).div(t);
    if (this.isOverflow(i, n)) throw new q2("Multiplication div overflow", "MulDivOverflow");
    return i;
  }
  static checkMulDivCeil(o, e, t, n) {
    if (t.eq(E)) throw new q2("Devide by zero", "DivideByZero");
    let i = o.mul(e).add(t.sub(he)).div(t);
    if (this.isOverflow(i, n)) throw new q2("Multiplication div overflow", "MulDivOverflow");
    return i;
  }
  static checkMulDivRound(o, e, t, n) {
    if (t.eq(E)) throw new q2("Devide by zero", "DivideByZero");
    let i = o.mul(e.add(t.shrn(1))).div(t);
    if (this.isOverflow(i, n)) throw new q2("Multiplication div overflow", "MulDivOverflow");
    return i;
  }
  static checkMulShiftRight(o, e, t, n) {
    let i = o.mul(e).div(new import_bn10.default(2).pow(new import_bn10.default(t)));
    if (this.isOverflow(i, n)) throw new q2("Multiplication shift right overflow", "MulShiftRightOverflow");
    return i;
  }
  static checkMulShiftRight64RoundUpIf(o, e, t, n) {
    let i = o.mul(e), s = n && i.and(Ge).gt(E) ? i.shrn(64).add(he) : i.shrn(64);
    if (this.isOverflow(s, t)) throw new q2("Multiplication shift right overflow", "MulShiftRightOverflow");
    return s;
  }
  static checkMulShiftLeft(o, e, t, n) {
    let i = o.mul(e).shln(t);
    if (this.isOverflow(i, n)) throw new q2("Multiplication shift left overflow", "MulShiftLeftOverflow");
    return i;
  }
  static checkDivRoundUpIf(o, e, t) {
    if (e.eq(E)) throw new q2("Devide by zero", "DivideByZero");
    return t ? this.divRoundUp(o, e) : o.div(e);
  }
  static isOverflow(o, e) {
    return o.gte(xe2.pow(new import_bn10.default(e)));
  }
  static sign(o) {
    return o.testn(127) ? 1 : 0;
  }
  static is_neg(o) {
    return this.sign(o) === 1;
  }
  static abs_u128(o) {
    return o.gt(E) ? o : this.u128_neg(o.subn(1));
  }
  static u128_neg(o) {
    return o.uxor(new import_bn10.default("ffffffffffffffffffffffffffffffff", 16));
  }
  static neg(o) {
    return this.is_neg(o) ? o.abs() : this.neg_from(o);
  }
  static abs(o) {
    return this.sign(o) === 0 ? o : this.u128_neg(o.sub(new import_bn10.default(1)));
  }
  static neg_from(o) {
    return o.eq(E) ? o : this.u128_neg(o).add(new import_bn10.default(1)).or(new import_bn10.default(1).shln(127));
  }
};
var vt2 = "79226673515401279992447579055";
var Ct = "4295048016";
var dt = new import_bn11.default(1e6);
var J2 = "0x0000000000000000000000000000000000000000000000000000000000000006";
var ft = "pool_script_v2";
var Se = "router";
var Me = "router_with_partner";
var pt2 = "utils";
var $e2 = "custodian_v2";
var _n = "clob_v2";
var hn2 = "endpoints_v2";
function F2(o) {
  if (o.config === void 0) throw new q2(`package: ${o.package_id}  not config in sdk SdkOptions`, "InvalidConfig");
  return o.config;
}
var gn2 = 14;
var bn2 = "59543866431248";
var wn2 = "184467440737095516";
var yn2 = "15793534762490258745";
function An(o, e, t) {
  let n = o.toTwos(t).shln(e);
  return n.imaskn(t + 1), n.fromTwos(t);
}
function S(o, e, t) {
  let n = o.toTwos(t).shrn(e);
  return n.imaskn(t - e + 1), n.fromTwos(t - e);
}
function vn2(o) {
  let e;
  return o & 1 ? e = new import_bn13.default("79232123823359799118286999567") : e = new import_bn13.default("79228162514264337593543950336"), o & 2 && (e = S(e.mul(new import_bn13.default("79236085330515764027303304731")), 96, 256)), o & 4 && (e = S(e.mul(new import_bn13.default("79244008939048815603706035061")), 96, 256)), o & 8 && (e = S(e.mul(new import_bn13.default("79259858533276714757314932305")), 96, 256)), o & 16 && (e = S(e.mul(new import_bn13.default("79291567232598584799939703904")), 96, 256)), o & 32 && (e = S(e.mul(new import_bn13.default("79355022692464371645785046466")), 96, 256)), o & 64 && (e = S(e.mul(new import_bn13.default("79482085999252804386437311141")), 96, 256)), o & 128 && (e = S(e.mul(new import_bn13.default("79736823300114093921829183326")), 96, 256)), o & 256 && (e = S(e.mul(new import_bn13.default("80248749790819932309965073892")), 96, 256)), o & 512 && (e = S(e.mul(new import_bn13.default("81282483887344747381513967011")), 96, 256)), o & 1024 && (e = S(e.mul(new import_bn13.default("83390072131320151908154831281")), 96, 256)), o & 2048 && (e = S(e.mul(new import_bn13.default("87770609709833776024991924138")), 96, 256)), o & 4096 && (e = S(e.mul(new import_bn13.default("97234110755111693312479820773")), 96, 256)), o & 8192 && (e = S(e.mul(new import_bn13.default("119332217159966728226237229890")), 96, 256)), o & 16384 && (e = S(e.mul(new import_bn13.default("179736315981702064433883588727")), 96, 256)), o & 32768 && (e = S(e.mul(new import_bn13.default("407748233172238350107850275304")), 96, 256)), o & 65536 && (e = S(e.mul(new import_bn13.default("2098478828474011932436660412517")), 96, 256)), o & 131072 && (e = S(e.mul(new import_bn13.default("55581415166113811149459800483533")), 96, 256)), o & 262144 && (e = S(e.mul(new import_bn13.default("38992368544603139932233054999993551")), 96, 256)), S(e, 32, 256);
}
function Cn2(o) {
  let e = Math.abs(o), t;
  return e & 1 ? t = new import_bn13.default("18445821805675392311") : t = new import_bn13.default("18446744073709551616"), e & 2 && (t = S(t.mul(new import_bn13.default("18444899583751176498")), 64, 256)), e & 4 && (t = S(t.mul(new import_bn13.default("18443055278223354162")), 64, 256)), e & 8 && (t = S(t.mul(new import_bn13.default("18439367220385604838")), 64, 256)), e & 16 && (t = S(t.mul(new import_bn13.default("18431993317065449817")), 64, 256)), e & 32 && (t = S(t.mul(new import_bn13.default("18417254355718160513")), 64, 256)), e & 64 && (t = S(t.mul(new import_bn13.default("18387811781193591352")), 64, 256)), e & 128 && (t = S(t.mul(new import_bn13.default("18329067761203520168")), 64, 256)), e & 256 && (t = S(t.mul(new import_bn13.default("18212142134806087854")), 64, 256)), e & 512 && (t = S(t.mul(new import_bn13.default("17980523815641551639")), 64, 256)), e & 1024 && (t = S(t.mul(new import_bn13.default("17526086738831147013")), 64, 256)), e & 2048 && (t = S(t.mul(new import_bn13.default("16651378430235024244")), 64, 256)), e & 4096 && (t = S(t.mul(new import_bn13.default("15030750278693429944")), 64, 256)), e & 8192 && (t = S(t.mul(new import_bn13.default("12247334978882834399")), 64, 256)), e & 16384 && (t = S(t.mul(new import_bn13.default("8131365268884726200")), 64, 256)), e & 32768 && (t = S(t.mul(new import_bn13.default("3584323654723342297")), 64, 256)), e & 65536 && (t = S(t.mul(new import_bn13.default("696457651847595233")), 64, 256)), e & 131072 && (t = S(t.mul(new import_bn13.default("26294789957452057")), 64, 256)), e & 262144 && (t = S(t.mul(new import_bn13.default("37481735321082")), 64, 256)), t;
}
var O = class {
  static priceToSqrtPriceX64(o, e, t) {
    return ee.toX64(o.mul(W2.pow(10, t - e)).sqrt());
  }
  static sqrtPriceX64ToPrice(o, e, t) {
    return ee.fromX64(o).pow(2).mul(W2.pow(10, e - t));
  }
  static tickIndexToSqrtPriceX64(o) {
    return o > 0 ? new import_bn13.default(vn2(o)) : new import_bn13.default(Cn2(o));
  }
  static sqrtPriceX64ToTickIndex(o) {
    if (o.gt(new import_bn13.default(vt2)) || o.lt(new import_bn13.default(Ct))) throw new q2("Provided sqrtPrice is not within the supported sqrtPrice range.", "InvalidSqrtPrice");
    let e = o.bitLength() - 1, t = new import_bn13.default(e - 64), n = An(t, 32, 128), i = new import_bn13.default("8000000000000000", "hex"), r2 = 0, s = new import_bn13.default(0), c = e >= 64 ? o.shrn(e - 63) : o.shln(63 - e);
    for (; i.gt(new import_bn13.default(0)) && r2 < gn2; ) {
      c = c.mul(c);
      let h = c.shrn(127);
      c = c.shrn(63 + h.toNumber()), s = s.add(i.mul(h)), i = i.shrn(1), r2 += 1;
    }
    let u = s.shrn(32), l = n.add(u).mul(new import_bn13.default(bn2)), d = S(l.sub(new import_bn13.default(wn2)), 64, 128).toNumber(), f = S(l.add(new import_bn13.default(yn2)), 64, 128).toNumber();
    return d === f ? d : O.tickIndexToSqrtPriceX64(f).lte(o) ? f : d;
  }
  static tickIndexToPrice(o, e, t) {
    return O.sqrtPriceX64ToPrice(O.tickIndexToSqrtPriceX64(o), e, t);
  }
  static priceToTickIndex(o, e, t) {
    return O.sqrtPriceX64ToTickIndex(O.priceToSqrtPriceX64(o, e, t));
  }
  static priceToInitializableTickIndex(o, e, t, n) {
    return O.getInitializableTickIndex(O.priceToTickIndex(o, e, t), n);
  }
  static getInitializableTickIndex(o, e) {
    return o - o % e;
  }
  static getNextInitializableTickIndex(o, e) {
    return O.getInitializableTickIndex(o, e) + e;
  }
  static getPrevInitializableTickIndex(o, e) {
    return O.getInitializableTickIndex(o, e) - e;
  }
};
var No2 = new import_bn12.default(365);
var Lo = new import_bn12.default(24);
var Mo2 = new import_bn12.default(3600);
var $o2 = new import_bn12.default(0.5);
var ne2 = class {
  static getDefaultSqrtPriceLimit(o) {
    return new import_bn15.default(o ? Ct : vt2);
  }
  static getDefaultOtherAmountThreshold(o) {
    return o ? E : Ge;
  }
};
function Pe2(o, e, t) {
  let n = import_bn14.default.min(o, e), i = import_bn14.default.max(o, e), r2 = ee.fromX64_BN(t.mul(i).mul(n)), s = i.sub(n);
  return !r2.isZero() && !s.isZero() ? r2.div(s) : new import_bn14.default(0);
}
function Ie2(o, e, t) {
  let n = import_bn14.default.min(o, e), r2 = import_bn14.default.max(o, e).sub(n);
  return r2.isZero() ? new import_bn14.default(0) : t.shln(64).div(r2);
}
var V = class {
  static updateFeeRate(o, e, t, n, i) {
    let r2 = ee.checkMulDivCeil(e, new import_bn14.default(n), dt, 64), s = t === 0 ? E : ee.checkMulDivFloor(e, new import_bn14.default(t), dt, 64), c = e.mul(r2).mul(s);
    if (i ? o.feeProtocolCoinA = o.feeProtocolCoinA.add(r2) : o.feeProtocolCoinB = o.feeProtocolCoinB.add(r2), c.eq(E) || o.liquidity.eq(E)) return { refFee: s, clmm: o };
    let u = c.shln(64).div(o.liquidity);
    return i ? o.feeGrowthGlobalA = o.feeGrowthGlobalA.add(u) : o.feeGrowthGlobalB = o.feeGrowthGlobalB.add(u), { refFee: s, clmm: o };
  }
  static getCoinAmountFromLiquidity(o, e, t, n, i) {
    let r2 = new W2(o.toString()), s = new W2(e.toString()), c = new W2(t.toString()), u = new W2(n.toString()), a, l;
    return e.lt(t) ? (a = ee.toX64_Decimal(r2).mul(u.sub(c)).div(c.mul(u)), l = new W2(0)) : e.lt(n) ? (a = ee.toX64_Decimal(r2).mul(u.sub(s)).div(s.mul(u)), l = ee.fromX64_Decimal(r2.mul(s.sub(c)))) : (a = new W2(0), l = ee.fromX64_Decimal(r2.mul(u.sub(c)))), i ? { coinA: new import_bn14.default(a.ceil().toString()), coinB: new import_bn14.default(l.ceil().toString()) } : { coinA: new import_bn14.default(a.floor().toString()), coinB: new import_bn14.default(l.floor().toString()) };
  }
  static estLiquidityAndcoinAmountFromOneAmounts(o, e, t, n, i, r2, s) {
    let c = O.sqrtPriceX64ToTickIndex(s), u = O.tickIndexToSqrtPriceX64(o), a = O.tickIndexToSqrtPriceX64(e), l;
    if (c < o) {
      if (!n) throw new q2("lower tick cannot calculate liquidity by coinB", "NotSupportedThisCoin");
      l = Pe2(u, a, t);
    } else if (c > e) {
      if (n) throw new q2("upper tick cannot calculate liquidity by coinA", "NotSupportedThisCoin");
      l = Ie2(a, u, t);
    } else n ? l = Pe2(s, a, t) : l = Ie2(s, u, t);
    let d = V.getCoinAmountFromLiquidity(l, s, u, a, i), f = i ? b(d.coinA.toString()).mul(1 + r2).toString() : b(d.coinA.toString()).mul(1 - r2).toString(), _ = i ? b(d.coinB.toString()).mul(1 + r2).toString() : b(d.coinB.toString()).mul(1 - r2).toString();
    return { coinAmountA: d.coinA, coinAmountB: d.coinB, tokenMaxA: i ? new import_bn14.default(W2.ceil(f).toString()) : new import_bn14.default(W2.floor(f).toString()), tokenMaxB: i ? new import_bn14.default(W2.ceil(_).toString()) : new import_bn14.default(W2.floor(_).toString()), liquidityAmount: l, fix_amount_a: n };
  }
  static estimateLiquidityFromcoinAmounts(o, e, t, n) {
    if (e > t) throw new q2("lower tick cannot be greater than lower tick", "InvalidTwoTickIndex");
    let i = O.sqrtPriceX64ToTickIndex(o), r2 = O.tickIndexToSqrtPriceX64(e), s = O.tickIndexToSqrtPriceX64(t);
    if (i < e) return Pe2(r2, s, n.coinA);
    if (i >= t) return Ie2(s, r2, n.coinB);
    let c = Pe2(o, s, n.coinA), u = Ie2(o, r2, n.coinB);
    return import_bn14.default.min(c, u);
  }
  static estCoinAmountsFromTotalAmount(o, e, t, n, i, r2) {
    let { ratioA: s, ratioB: c } = V.calculateDepositRatioFixTokenA(o, e, t), u = b(n).mul(s).div(i), a = b(n).mul(c).div(r2);
    return { amountA: u, amountB: a };
  }
  static calculateDepositRatioFixTokenA(o, e, t) {
    let n = new import_bn14.default(1e8), { coinAmountB: i } = V.estLiquidityAndcoinAmountFromOneAmounts(o, e, n, true, true, 0, t), r2 = O.sqrtPriceX64ToPrice(t, 0, 0), s = b(n.toString()).mul(r2), c = s.add(i.toString()), u = s.div(c), a = b(i.toString()).div(c);
    return { ratioA: u, ratioB: a };
  }
};
function mt(o, ...e) {
  let t = Array.isArray(e[e.length - 1]) ? e.pop() : [], i = [o, ...e].filter(Boolean).join("::");
  return t && t.length && (i += `<${t.join(", ")}>`), i;
}
function P3(o) {
  var _a7, _b3;
  try {
    let e = o.replace(/\s/g, ""), n = (_b3 = (_a7 = e.match(/(<.+>)$/)) == null ? void 0 : _a7[0]) == null ? void 0 : _b3.match(/(\w+::\w+::\w+)(?:<.*?>(?!>))?/g);
    if (n) {
      e = e.slice(0, e.indexOf("<"));
      let u = __spreadProps(__spreadValues({}, P3(e)), { type_arguments: n.map((a) => P3(a).source_address) });
      return u.type_arguments = u.type_arguments.map((a) => I.isSuiCoin(a) ? a : P3(a).source_address), u.source_address = mt(u.full_address, u.type_arguments), u;
    }
    let i = e.split("::"), s = { full_address: e, address: e === be2 || e === In ? "0x2" : normalizeSuiObjectId(i[0]), module: i[1], name: i[2], type_arguments: [], source_address: "" };
    return s.full_address = `${s.address}::${s.module}::${s.name}`, s.source_address = mt(s.full_address, s.type_arguments), s;
  } catch (e) {
    return { full_address: o, address: "", module: "", name: "", type_arguments: [], source_address: o };
  }
}
function ge2(o) {
  return P3(o).source_address;
}
function kn(o) {
  return o.toLowerCase().startsWith("0x") ? normalizeSuiObjectId(o) : o;
}
function Ke(o) {
  for (let e in o) {
    let t = typeof o[e];
    if (t === "object") Ke(o[e]);
    else if (t === "string") {
      let n = o[e];
      n && !n.includes("::") && (o[e] = kn(n));
    }
  }
}
var Sn2 = "0x2::coin::Coin";
var Pn2 = /^0x2::coin::Coin<(.+)>$/;
var be2 = "0x2::sui::SUI";
var In = "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI";
var I = class {
  static getCoinTypeArg(o) {
    let e = o.type.match(Pn2);
    return e ? e[1] : null;
  }
  static isSUI(o) {
    let e = I.getCoinTypeArg(o);
    return e ? I.getCoinSymbol(e) === "SUI" : false;
  }
  static getCoinSymbol(o) {
    return o.substring(o.lastIndexOf(":") + 1);
  }
  static getBalance(o) {
    return BigInt(o.fields.balance);
  }
  static totalBalance(o, e) {
    let t = BigInt(0);
    return o.forEach((n) => {
      e === n.coinAddress && (t += BigInt(n.balance));
    }), t;
  }
  static getID(o) {
    return o.fields.id.id;
  }
  static getCoinTypeFromArg(o) {
    return `${Sn2}<${o}>`;
  }
  static getFaucetCoins(o) {
    let { events: e } = o, t = [];
    return e == null ? void 0 : e.forEach((n) => {
      let { type: i } = n;
      if (P3(i).name === "InitEvent") {
        let r2 = n.parsedJson;
        t.push({ transactionModule: n.transactionModule, suplyID: r2.suplyID, decimals: r2.decimals });
      }
    }), t;
  }
  static getCoinAssets(o, e) {
    let t = [];
    return e.forEach((n) => {
      ge2(n.coinAddress) === ge2(o) && t.push(n);
    }), t;
  }
  static isSuiCoin(o) {
    return P3(o).full_address === be2;
  }
  static selectCoinObjectIdGreaterThanOrEqual(o, e, t = []) {
    let n = I.selectCoinAssetGreaterThanOrEqual(o, e, t), i = n.selectedCoins.map((c) => c.coinObjectId), r2 = n.remainingCoins, s = n.selectedCoins.map((c) => c.balance.toString());
    return { objectArray: i, remainCoins: r2, amountArray: s };
  }
  static selectCoinAssetGreaterThanOrEqual(o, e, t = []) {
    let n = I.sortByBalance(o.filter((u) => !t.includes(u.coinObjectId))), i = I.calculateTotalBalance(n);
    if (i < e) return { selectedCoins: [], remainingCoins: n };
    if (i === e) return { selectedCoins: n, remainingCoins: [] };
    let r2 = BigInt(0), s = [], c = [...n];
    for (; r2 < i; ) {
      let u = e - r2, a = c.findIndex((d) => d.balance >= u);
      if (a !== -1) {
        s.push(c[a]), c.splice(a, 1);
        break;
      }
      let l = c.pop();
      l.balance > 0 && (s.push(l), r2 += l.balance);
    }
    return { selectedCoins: I.sortByBalance(s), remainingCoins: I.sortByBalance(c) };
  }
  static sortByBalance(o) {
    return o.sort((e, t) => e.balance < t.balance ? -1 : e.balance > t.balance ? 1 : 0);
  }
  static sortByBalanceDes(o) {
    return o.sort((e, t) => e.balance > t.balance ? -1 : e.balance < t.balance ? 0 : 1);
  }
  static calculateTotalBalance(o) {
    return o.reduce((e, t) => e + t.balance, BigInt(0));
  }
};
function On(o, { numerator: e, denominator: t }, n) {
  return n ? o.mul(t.add(e)).div(t) : o.mul(t).div(t.add(e));
}
function b(o) {
  return decimal_default.isDecimal(o) ? o : new decimal_default(o === void 0 ? 0 : o);
}
function kt2(o) {
  return o.data;
}
function xn(o) {
  if (o.error && "object_id" in o.error && "version" in o.error && "digest" in o.error) {
    let { error: e } = o;
    return { objectId: e.object_id, version: e.version, digest: e.digest };
  }
}
function Bn(o) {
  if (o.error && "object_id" in o.error && !("version" in o.error) && !("digest" in o.error)) return o.error.object_id;
}
function Rn(o) {
  if ("reference" in o) return o.reference;
  let e = kt2(o);
  return e ? { objectId: e.objectId, version: e.version, digest: e.digest } : xn(o);
}
function ht(o) {
  var _a7, _b3;
  return "objectId" in o ? o.objectId : (_b3 = (_a7 = Rn(o)) == null ? void 0 : _a7.objectId) != null ? _b3 : Bn(o);
}
function jn(o) {
  return o.data !== void 0;
}
function qn(o) {
  return o.content !== void 0;
}
function St2(o) {
  let e = "data" in o ? kt2(o) : o;
  if (!(!e || !qn(e) || e.content.dataType !== "moveObject")) return e.content;
}
function Pt(o) {
  var _a7;
  return (_a7 = St2(o)) == null ? void 0 : _a7.type;
}
function It(o) {
  var _a7;
  let e = jn(o) ? o.data : o;
  return !(e == null ? void 0 : e.type) && "data" in o ? ((_a7 = e == null ? void 0 : e.content) == null ? void 0 : _a7.dataType) === "package" ? "package" : Pt(o) : e == null ? void 0 : e.type;
}
function ae2(o) {
  var _a7;
  let e = (_a7 = St2(o)) == null ? void 0 : _a7.fields;
  if (e) return "fields" in e ? e.fields : e;
}
function gt(o, e = 32) {
  return BigInt.asUintN(e, BigInt(o)).toString();
}
function re2(o, e = 32) {
  return Number(BigInt.asIntN(e, BigInt(o)));
}
function Dn2(o, e, t) {
  let n = P3(o).name, i = P3(e).name;
  return `${n}-${i}[${t}]`;
}
function We2(o) {
  let e = Pt(o), t = P3(e), n = ae2(o);
  if (n == null) throw new q2(`Pool id ${ht(o)} not exists.`, "InvalidPoolObject");
  let i = [];
  n.rewarder_manager.fields.rewarders.forEach((s) => {
    let { emissions_per_second: c } = s.fields, u = ee.fromX64(new import_bn8.default(c)), a = Math.floor(u.toNumber() * 60 * 60 * 24);
    i.push({ emissions_per_second: c, coinAddress: P3(s.fields.reward_coin.fields.name).source_address, growth_global: s.fields.growth_global, emissionsEveryDay: a });
  });
  let r2 = { poolAddress: ht(o), poolType: e, coinTypeA: t.type_arguments[0], coinTypeB: t.type_arguments[1], coinAmountA: n.coin_a, coinAmountB: n.coin_b, current_sqrt_price: n.current_sqrt_price, current_tick_index: re2(BigInt(n.current_tick_index.fields.bits)), fee_growth_global_a: n.fee_growth_global_a, fee_growth_global_b: n.fee_growth_global_b, fee_protocol_coin_a: n.fee_protocol_coin_a, fee_protocol_coin_b: n.fee_protocol_coin_b, fee_rate: n.fee_rate, is_pause: n.is_pause, liquidity: n.liquidity, position_manager: { positions_handle: n.position_manager.fields.positions.fields.id.id, size: n.position_manager.fields.positions.fields.size }, rewarder_infos: i, rewarder_last_updated_time: n.rewarder_manager.fields.last_updated_time, tickSpacing: n.tick_spacing, ticks_handle: n.tick_manager.fields.ticks.fields.id.id, uri: n.url, index: Number(n.index), name: "" };
  return r2.name = Dn2(r2.coinTypeA, r2.coinTypeB, r2.tickSpacing), r2;
}
function En2(o) {
  let e = I.isSuiCoin(o.coinTypeA), t = I.isSuiCoin(o.coinTypeB);
  return { isAdjustCoinA: e, isAdjustCoinB: t };
}
function Nn2(o, e) {
  return decimal_default.ceil(b(o).div(1 + e)).toString();
}
var T = class {
  static createCollectRewarderAndFeeParams(o, e, t, n, i, r2) {
    i === void 0 && (i = [...n]), r2 === void 0 && (r2 = [...n]);
    let s = ge2(t.coinTypeA), c = ge2(t.coinTypeB);
    if (t.collect_fee) {
      let a = T.buildCoinForAmount(e, i, BigInt(0), s, false);
      i = a.remainCoins;
      let l = T.buildCoinForAmount(e, r2, BigInt(0), c, false);
      r2 = l.remainCoins, e = o.Position.createCollectFeePaylod({ pool_id: t.pool_id, pos_id: t.pos_id, coinTypeA: t.coinTypeA, coinTypeB: t.coinTypeB }, e, a.targetCoin, l.targetCoin);
    }
    let u = [];
    return t.rewarder_coin_types.forEach((a) => {
      switch (ge2(a)) {
        case s:
          u.push(T.buildCoinForAmount(e, i, BigInt(0), a, false).targetCoin);
          break;
        case c:
          u.push(T.buildCoinForAmount(e, r2, BigInt(0), a, false).targetCoin);
          break;
        default:
          u.push(T.buildCoinForAmount(e, n, BigInt(0), a, false).targetCoin);
          break;
      }
    }), e = o.Rewarder.createCollectRewarderPaylod(t, e, u), e;
  }
  static async adjustTransactionForGas(o, e, t, n) {
    n.setSender(o.senderAddress);
    let i = I.selectCoinAssetGreaterThanOrEqual(e, t).selectedCoins;
    if (i.length === 0) throw new q2("Insufficient balance", "InsufficientBalance");
    let r2 = I.calculateTotalBalance(e);
    if (r2 - t > 1e9) return { fixAmount: t };
    let s = await o.fullClient.calculationTxGas(n);
    if (I.selectCoinAssetGreaterThanOrEqual(e, BigInt(s), i.map((u) => u.coinObjectId)).selectedCoins.length === 0) {
      let u = BigInt(s) + BigInt(500);
      if (r2 - t < u) {
        if (t -= u, t < 0) throw new q2("gas Insufficient balance", "InsufficientBalance");
        let a = new Transaction();
        return { fixAmount: t, newTx: a };
      }
    }
    return { fixAmount: t };
  }
  static async buildAddLiquidityFixTokenForGas(o, e, t, n, i, r2, s) {
    i = await T.buildAddLiquidityFixToken(o, e, t, i, r2, s);
    let { isAdjustCoinA: c } = En2(t), u = c ? t.amount_a : t.amount_b, a = await T.adjustTransactionForGas(o, I.getCoinAssets(c ? t.coinTypeA : t.coinTypeB, e), BigInt(u), i), { fixAmount: l } = a, { newTx: d } = a;
    if (d != null) {
      let f, _;
      if (c) t.amount_a = Number(l), f = T.buildAddLiquidityFixTokenCoinInput(d, !t.fix_amount_a, l.toString(), t.slippage, t.coinTypeA, e, false, true), _ = T.buildAddLiquidityFixTokenCoinInput(d, t.fix_amount_a, t.amount_b, t.slippage, t.coinTypeB, e, false, true);
      else return t.amount_b = Number(l), f = T.buildAddLiquidityFixTokenCoinInput(d, !t.fix_amount_a, t.amount_a, t.slippage, t.coinTypeA, e, false, true), _ = T.buildAddLiquidityFixTokenCoinInput(d, t.fix_amount_a, l.toString(), t.slippage, t.coinTypeB, e, false, true), t = T.fixAddLiquidityFixTokenParams(t, n.slippage, n.curSqrtPrice), i = await T.buildAddLiquidityFixTokenArgs(d, o, e, t, f, _), i;
    }
    return i;
  }
  static async buildAddLiquidityFixToken(o, e, t, n, i, r2) {
    if (o.senderAddress.length === 0) throw Error("this config sdk senderAddress is empty");
    n = n || new Transaction();
    let s, c;
    return i == null || r2 == null ? (s = T.buildAddLiquidityFixTokenCoinInput(n, !t.fix_amount_a, t.amount_a, t.slippage, t.coinTypeA, e, false, true), c = T.buildAddLiquidityFixTokenCoinInput(n, t.fix_amount_a, t.amount_b, t.slippage, t.coinTypeB, e, false, true)) : (s = { targetCoin: i, remainCoins: [], isMintZeroCoin: false, tragetCoinAmount: "0" }, c = { targetCoin: r2, remainCoins: [], isMintZeroCoin: false, tragetCoinAmount: "0" }), n = T.buildAddLiquidityFixTokenArgs(n, o, e, t, s, c), n;
  }
  static buildAddLiquidityFixTokenCoinInput(o, e, t, n, i, r2, s = true, c = true) {
    return e ? T.buildCoinForAmountInterval(o, r2, { amountSecond: BigInt(Nn2(t, n)), amountFirst: BigInt(t) }, i, s, c) : T.buildCoinForAmount(o, r2, BigInt(t), i, s, c);
  }
  static fixAddLiquidityFixTokenParams(o, e, t) {
    let n = o.fix_amount_a ? o.amount_a : o.amount_b, i = V.estLiquidityAndcoinAmountFromOneAmounts(Number(o.tick_lower), Number(o.tick_upper), new import_bn20.default(n), o.fix_amount_a, true, e, t);
    return o.amount_a = o.fix_amount_a ? o.amount_a : i.tokenMaxA.toNumber(), o.amount_b = o.fix_amount_a ? i.tokenMaxB.toNumber() : o.amount_b, o;
  }
  static buildAddLiquidityFixTokenArgs(o, e, t, n, i, r2) {
    let s = [n.coinTypeA, n.coinTypeB], c = n.is_open ? "open_position_with_liquidity_by_fix_coin" : "add_liquidity_by_fix_coin", { clmm_pool: u, integrate: a } = e.sdkOptions;
    n.is_open || (o = T.createCollectRewarderAndFeeParams(e, o, n, t, i.remainCoins, r2.remainCoins));
    let l = F2(u), d = n.is_open ? [o.object(l.global_config_id), o.object(n.pool_id), o.pure.u32(Number(gt(BigInt(n.tick_lower)).toString())), o.pure.u32(Number(gt(BigInt(n.tick_upper)).toString())), i.targetCoin, r2.targetCoin, o.pure.u64(n.amount_a), o.pure.u64(n.amount_b), o.pure.bool(n.fix_amount_a), o.object(J2)] : [o.object(l.global_config_id), o.object(n.pool_id), o.object(n.pos_id), i.targetCoin, r2.targetCoin, o.pure.u64(n.amount_a), o.pure.u64(n.amount_b), o.pure.bool(n.fix_amount_a), o.object(J2)];
    return o.moveCall({ target: `${a.published_at}::${ft}::${c}`, typeArguments: s, arguments: d }), o;
  }
  static async buildSwapTransactionForGas(o, e, t, n) {
    let i = T.buildSwapTransaction(o, e, t);
    i.setSender(o.senderAddress);
    let r2 = await T.adjustTransactionForGas(o, I.getCoinAssets(e.a2b ? e.coinTypeA : e.coinTypeB, t), BigInt(e.by_amount_in ? e.amount : e.amount_limit), i), { fixAmount: s, newTx: c } = r2;
    if (c !== void 0) {
      c.setSender(o.senderAddress), e.by_amount_in ? e.amount = s.toString() : e.amount_limit = s.toString(), e = await T.fixSwapParams(o, e, n);
      let u = T.buildCoinForAmount(i, t, e.a2b ? BigInt(e.by_amount_in ? e.amount : e.amount_limit) : BigInt(0), e.coinTypeA), a = T.buildCoinForAmount(i, t, e.a2b ? BigInt(0) : BigInt(e.by_amount_in ? e.amount : e.amount_limit), e.coinTypeB);
      i = T.buildSwapTransactionArgs(c, e, o.sdkOptions, u, a);
    }
    return i;
  }
  static buildSwapTransaction(o, e, t) {
    let n = new Transaction();
    n.setSender(o.senderAddress);
    let i = T.buildCoinForAmount(n, t, e.a2b ? BigInt(e.by_amount_in ? e.amount : e.amount_limit) : BigInt(0), e.coinTypeA, false), r2 = T.buildCoinForAmount(n, t, e.a2b ? BigInt(0) : BigInt(e.by_amount_in ? e.amount : e.amount_limit), e.coinTypeB, false);
    return n = T.buildSwapTransactionArgs(n, e, o.sdkOptions, i, r2), n;
  }
  static buildSwapTransactionArgs(o, e, t, n, i) {
    let { clmm_pool: r2, integrate: s } = t, c = ne2.getDefaultSqrtPriceLimit(e.a2b), u = [e.coinTypeA, e.coinTypeB], { global_config_id: a } = F2(r2);
    if (a === void 0) throw Error("clmm.config.global_config_id is undefined");
    let l = e.swap_partner !== void 0, d = l ? e.a2b ? "swap_a2b_with_partner" : "swap_b2a_with_partner" : e.a2b ? "swap_a2b" : "swap_b2a", f = l ? [o.object(a), o.object(e.pool_id), o.object(e.swap_partner), n.targetCoin, i.targetCoin, o.pure.bool(e.by_amount_in), o.pure.u64(e.amount), o.pure.u64(e.amount_limit), o.pure.u128(c.toString()), o.object(J2)] : [o.object(a), o.object(e.pool_id), n.targetCoin, i.targetCoin, o.pure.bool(e.by_amount_in), o.pure.u64(e.amount), o.pure.u64(e.amount_limit), o.pure.u128(c.toString()), o.object(J2)];
    return o.moveCall({ target: `${s.published_at}::${ft}::${d}`, typeArguments: u, arguments: f }), o;
  }
  static async buildSwapTransactionWithoutTransferCoinsForGas(o, e, t, n) {
    let { tx: i, coinABs: r2 } = T.buildSwapTransactionWithoutTransferCoins(o, e, t);
    i.setSender(o.senderAddress);
    let s = await T.adjustTransactionForGas(o, I.getCoinAssets(e.a2b ? e.coinTypeA : e.coinTypeB, t), BigInt(e.by_amount_in ? e.amount : e.amount_limit), i), { fixAmount: c, newTx: u } = s;
    if (u !== void 0) {
      u.setSender(o.senderAddress), e.by_amount_in ? e.amount = c.toString() : e.amount_limit = c.toString(), e = await T.fixSwapParams(o, e, n);
      let a = T.buildCoinForAmount(i, t, e.a2b ? BigInt(e.by_amount_in ? e.amount : e.amount_limit) : BigInt(0), e.coinTypeA, false, true), l = T.buildCoinForAmount(i, t, e.a2b ? BigInt(0) : BigInt(e.by_amount_in ? e.amount : e.amount_limit), e.coinTypeB, false, true), d = T.buildSwapTransactionWithoutTransferCoinArgs(o, u, e, o.sdkOptions, a, l);
      i = d.tx, r2 = d.txRes;
    }
    return { tx: i, coinABs: r2 };
  }
  static buildSwapTransactionWithoutTransferCoins(o, e, t) {
    let n = new Transaction();
    n.setSender(o.senderAddress);
    let i = T.buildCoinForAmount(n, t, e.a2b ? BigInt(e.by_amount_in ? e.amount : e.amount_limit) : BigInt(0), e.coinTypeA, false, true), r2 = T.buildCoinForAmount(n, t, e.a2b ? BigInt(0) : BigInt(e.by_amount_in ? e.amount : e.amount_limit), e.coinTypeB, false, true), s = T.buildSwapTransactionWithoutTransferCoinArgs(o, n, e, o.sdkOptions, i, r2);
    return { tx: s.tx, coinABs: s.txRes };
  }
  static buildSwapTransactionWithoutTransferCoinArgs(o, e, t, n, i, r2) {
    let { clmm_pool: s, integrate: c } = n, u = ne2.getDefaultSqrtPriceLimit(t.a2b), { global_config_id: a } = F2(s);
    if (a === void 0) throw Error("clmm.config.global_config_id is undefined");
    let l = t.swap_partner !== void 0, d = l ? "swap_with_partner" : "swap", f = l ? Me : Se, _ = l ? [e.object(a), e.object(t.pool_id), e.object(t.swap_partner), i.targetCoin, r2.targetCoin, e.pure.bool(t.a2b), e.pure.bool(t.by_amount_in), e.pure.u64(t.amount), e.pure.u128(u.toString()), e.pure.bool(false), e.object(J2)] : [e.object(a), e.object(t.pool_id), i.targetCoin, r2.targetCoin, e.pure.bool(t.a2b), e.pure.bool(t.by_amount_in), e.pure.u64(t.amount), e.pure.u128(u.toString()), e.pure.bool(false), e.object(J2)], h = [t.coinTypeA, t.coinTypeB], m = e.moveCall({ target: `${c.published_at}::${f}::${d}`, typeArguments: h, arguments: _ });
    if (t.by_amount_in) {
      let g = t.a2b ? t.coinTypeB : t.coinTypeA, w2 = t.a2b ? m[1] : m[0], y = Number(t.amount_limit);
      this.checkCoinThreshold(o, t.by_amount_in, e, w2, y, g);
    }
    return { tx: e, txRes: m };
  }
  static async fixSwapParams(o, e, t) {
    let { currentPool: n } = t;
    try {
      let i = await o.Swap.preswap({ decimalsA: t.decimalsA, decimalsB: t.decimalsB, a2b: e.a2b, byAmountIn: e.by_amount_in, amount: e.amount, pool: n, currentSqrtPrice: n.current_sqrt_price, coinTypeA: n.coinTypeA, coinTypeB: n.coinTypeB }), r2 = t.byAmountIn ? i.estimatedAmountOut : i.estimatedAmountIn, s = On(r2, t.slippage, !t.byAmountIn);
      e.amount_limit = s.toString();
    } catch (i) {
      console.log("fixSwapParams", i);
    }
    return e;
  }
  static async syncBuildCoinInputForAmount(o, e, t, n, i = true, r2 = true) {
    if (o.senderAddress.length === 0) throw Error("this config sdk senderAddress is empty");
    let s = await o.getOwnerCoinAssets(o.senderAddress, n);
    return T.buildCoinForAmount(e, s, t, n, i, r2).targetCoin;
  }
  static buildCoinForAmount(o, e, t, n, i = true, r2 = true) {
    let s = I.getCoinAssets(n, e);
    if (t === BigInt(0)) return T.buildZeroValueCoin(e, o, n, i);
    let c = I.calculateTotalBalance(s);
    if (c < t) throw new q2(`The amount(${c}) is Insufficient balance for ${n} , expect ${t} `, "InsufficientBalance");
    return T.buildCoin(o, e, s, t, n, i, r2);
  }
  static buildVectorCoin(o, e, t, n, i, r2 = true) {
    if (I.isSuiCoin(i)) {
      let d = o.splitCoins(o.gas, [o.pure.u64(n)]);
      return { targetCoin: o.makeMoveVec({ elements: [d] }), remainCoins: e, tragetCoinAmount: n.toString(), isMintZeroCoin: false, originalSplitedCoin: o.gas };
    }
    let { targetCoin: s, originalSplitedCoin: c, tragetCoinAmount: u, selectedCoinsResult: a, coinObjectIds: l } = this.buildSpitTargeCoin(o, n, t, r2);
    return r2 ? { targetCoin: o.makeMoveVec({ elements: [s] }), remainCoins: a.remainCoins, originalSplitedCoin: c, tragetCoinAmount: u, isMintZeroCoin: false } : { targetCoin: o.makeMoveVec({ elements: l.map((d) => o.object(d)) }), remainCoins: a.remainCoins, tragetCoinAmount: a.amountArray.reduce((d, f) => Number(d) + Number(f), 0).toString(), isMintZeroCoin: false };
  }
  static buildOneCoin(o, e, t, n, i = true) {
    if (I.isSuiCoin(n)) {
      if (t === /* @__PURE__ */ BigInt("0") && e.length > 1) {
        let d = I.selectCoinObjectIdGreaterThanOrEqual(e, t);
        return { targetCoin: o.object(d.objectArray[0]), remainCoins: d.remainCoins, tragetCoinAmount: d.amountArray[0], isMintZeroCoin: false };
      }
      let a = I.selectCoinObjectIdGreaterThanOrEqual(e, t);
      return { targetCoin: o.splitCoins(o.gas, [o.pure.u64(t)]), remainCoins: a.remainCoins, tragetCoinAmount: t.toString(), isMintZeroCoin: false, originalSplitedCoin: o.gas };
    }
    let { targetCoin: r2, originalSplitedCoin: s, tragetCoinAmount: c, selectedCoinsResult: u } = this.buildSpitTargeCoin(o, t, e, i);
    return { targetCoin: r2, remainCoins: u.remainCoins, originalSplitedCoin: s, tragetCoinAmount: c, isMintZeroCoin: false };
  }
  static buildSpitTargeCoin(o, e, t, n) {
    let i = I.selectCoinObjectIdGreaterThanOrEqual(t, e), r2 = i.amountArray.reduce((_, h) => Number(_) + Number(h), 0).toString(), s = i.objectArray, [c, ...u] = s, a = o.object(c), l = a, d = i.amountArray.reduce((_, h) => Number(_) + Number(h), 0).toString(), f;
    return u.length > 0 && o.mergeCoins(a, u.map((_) => o.object(_))), n && Number(r2) > Number(e) && (l = o.splitCoins(a, [o.pure.u64(e)]), f = a), { originalSplitedCoin: f, targetCoin: l, tragetCoinAmount: d, selectedCoinsResult: i, coinObjectIds: s };
  }
  static buildCoin(o, e, t, n, i, r2 = true, s = true) {
    return r2 ? this.buildVectorCoin(o, e, t, n, i, s) : this.buildOneCoin(o, t, n, i, s);
  }
  static buildZeroValueCoin(o, e, t, n = true) {
    let i = T.callMintZeroValueCoin(e, t), r2;
    return n ? r2 = e.makeMoveVec({ elements: [i] }) : r2 = i, { targetCoin: r2, remainCoins: o, isMintZeroCoin: true, tragetCoinAmount: "0" };
  }
  static buildCoinForAmountInterval(o, e, t, n, i = true, r2 = true) {
    let s = I.getCoinAssets(n, e);
    if (t.amountFirst === BigInt(0)) return s.length > 0 ? T.buildCoin(o, [...e], [...s], t.amountFirst, n, i, r2) : T.buildZeroValueCoin(e, o, n, i);
    let c = I.calculateTotalBalance(s);
    if (c >= t.amountFirst) return T.buildCoin(o, [...e], [...s], t.amountFirst, n, i, r2);
    if (c < t.amountSecond) throw new q2(`The amount(${c}) is Insufficient balance for ${n} , expect ${t.amountSecond} `, "InsufficientBalance");
    return T.buildCoin(o, [...e], [...s], t.amountSecond, n, i, r2);
  }
  static async buildRouterSwapTransaction(o, e, t, n, i) {
    let r2 = new Transaction();
    return e.paths.length > 1 && (e.partner = ""), r2 = await this.buildRouterBasePathTx(o, e, t, n, r2, i), r2;
  }
  static async buildRouterBasePathTx(o, e, t, n, i, r2) {
    let s = e.paths.filter((p) => p && p.poolAddress), c = Number(s.reduce((p, A) => p.add(A.amountIn), E).toString()), u = Number(s.reduce((p, A) => p.add(A.amountOut), E).toString()), a = Math.round(t ? Number(u.toString()) * (1 - e.priceSlippagePoint) : Number(c.toString()) * (1 + e.priceSlippagePoint)), l = e.paths[0].coinType[0], d = e.paths[0].coinType[e.paths[0].coinType.length - 1], f = T.buildCoinForAmount(i, n, BigInt(t ? c : a), l, false, true), _ = f.originalSplitedCoin !== void 0, h = T.buildCoinForAmount(i, n, /* @__PURE__ */ BigInt("0"), d, false), m = await this.buildRouterBasePathReturnCoins(o, e, t, f, h, i), g = [], { toCoin: w2, fromCoin: y } = m;
    if (i = m.tx, h.isMintZeroCoin ? g.push({ coinType: d, coin: w2 }) : h.originalSplitedCoin !== void 0 ? i.mergeCoins(h.originalSplitedCoin, [w2]) : i.mergeCoins(h.targetCoin, [w2]), _) {
      let p = f == null ? void 0 : f.originalSplitedCoin;
      i.mergeCoins(p, [y]);
    } else g.push({ coinType: l, coin: y });
    for (let p = 0; p < g.length; p++) this.buildTransferCoin(o, i, g[p].coin, g[p].coinType, r2);
    return i;
  }
  static async buildRouterBasePathReturnCoins(o, e, t, n, i, r2) {
    let { clmm_pool: s, integrate: c } = o.sdkOptions, u = F2(s).global_config_id, a = e.paths.filter((p) => p && p.poolAddress), l = Number(a.reduce((p, A) => p.add(A.amountIn), E).toString()), d = Number(a.reduce((p, A) => p.add(A.amountOut), E).toString()), f = Math.round(t ? Number(d.toString()) * (1 - e.priceSlippagePoint) : Number(l.toString()) * (1 + e.priceSlippagePoint)), _ = e.paths[0].coinType[0], h = e.paths[0].coinType[e.paths[0].coinType.length - 1], m = n.targetCoin, g;
    i.isMintZeroCoin || i.originalSplitedCoin !== void 0 ? g = i.targetCoin : g = T.callMintZeroValueCoin(r2, h);
    let w2 = e.partner === "", y = w2 ? Se : Me;
    for (let p of a) if (p.poolAddress.length === 1) {
      let A = p.a2b[0], C2 = { amount: Number(p.amountIn.toString()), amountLimit: f, poolCoinA: p.a2b[0] ? _ : h, poolCoinB: p.a2b[0] ? h : _ }, v = w2 ? "swap" : "swap_with_partner", B2 = A ? m : g, j2 = A ? g : m, D = t ? p.amountIn.toString() : p.amountOut.toString(), G = ne2.getDefaultSqrtPriceLimit(A).toString(), L = w2 ? [r2.object(u), r2.object(p.poolAddress[0]), B2, j2, r2.pure.bool(A), r2.pure.bool(t), r2.pure.u64(D), r2.pure.u128(G), r2.pure.bool(false), r2.object(J2)] : [r2.object(u), r2.object(p.poolAddress[0]), r2.object(e.partner), B2, j2, r2.pure.bool(A), r2.pure.bool(t), r2.pure.u64(D), r2.pure.u128(G), r2.pure.bool(false), r2.object(J2)], z = [C2.poolCoinA, C2.poolCoinB], N = r2.moveCall({ target: `${o.sdkOptions.integrate.published_at}::${y}::${v}`, typeArguments: z, arguments: L });
      m = A ? N[0] : N[1], g = A ? N[1] : N[0];
    } else {
      let A = t ? p.amountIn : p.rawAmountLimit[0], C2 = t ? 0 : p.amountOut, v = "";
      p.a2b[0] ? p.a2b[1] ? v = "swap_ab_bc" : v = "swap_ab_cb" : p.a2b[1] ? v = "swap_ba_bc" : v = "swap_ba_cb", w2 || (v = `${v}_with_partner`);
      let B2 = ne2.getDefaultSqrtPriceLimit(p.a2b[0]), j2 = ne2.getDefaultSqrtPriceLimit(p.a2b[1]), D = w2 ? [r2.object(u), r2.object(p.poolAddress[0]), r2.object(p.poolAddress[1]), m, g, r2.pure.bool(t), r2.pure.u64(A.toString()), r2.pure.u64(C2.toString()), r2.pure.u128(B2.toString()), r2.pure.u128(j2.toString()), r2.object(J2)] : [r2.object(u), r2.object(p.poolAddress[0]), r2.object(p.poolAddress[1]), r2.object(e.partner), m, g, r2.pure.bool(t), r2.pure.u64(A.toString()), r2.pure.u64(C2.toString()), r2.pure.u128(B2.toString()), r2.pure.u128(j2.toString()), r2.object(J2)], G = [p.coinType[0], p.coinType[1], p.coinType[2]], L = r2.moveCall({ target: `${c.published_at}::${y}::${v}`, typeArguments: G, arguments: D });
      m = L[0], g = L[1];
    }
    return this.checkCoinThreshold(o, t, r2, g, f, h), { fromCoin: m, toCoin: g, tx: r2 };
  }
  static async buildAggregatorSwapReturnCoins(o, e, t, n, i, r2, s, c) {
    if (c == null) {
      if (o.senderAddress.length === 0) throw Error("recipient and this config sdk senderAddress all not set");
      c = o.senderAddress;
    }
    e.splitPaths.length > 1 && (i = "");
    let u, a, l = e.splitPaths.some((d) => d.basePaths.some((f) => f.label === "Deepbook"));
    if ((!e.byAmountIn || e.splitPaths.length === 1) && !l) {
      let d = [];
      for (let h of e.splitPaths) {
        let m = [], g = [], w2 = [], y = [];
        for (let A = 0; A < h.basePaths.length; A += 1) {
          let C2 = h.basePaths[A];
          m.push(C2.direction), g.push(C2.poolAddress), w2.push(new import_bn20.default(C2.inputAmount.toString())), A === 0 ? y.push(C2.fromCoin, C2.toCoin) : y.push(C2.toCoin);
        }
        let p = { amountIn: new import_bn20.default(h.inputAmount.toString()), amountOut: new import_bn20.default(h.outputAmount.toString()), poolAddress: g, a2b: m, rawAmountLimit: w2, isExceed: false, coinType: y };
        d.push(p);
      }
      let f = { paths: d, partner: i, priceSlippagePoint: r2 }, _ = await this.buildRouterBasePathReturnCoins(o, f, e.byAmountIn, t, n, s);
      u = _.fromCoin, a = _.toCoin, s = _.tx;
    } else {
      let d = Math.round(e.outputAmount * (1 - r2));
      u = t.targetCoin, n.isMintZeroCoin || n.originalSplitedCoin !== void 0 ? a = n.targetCoin : a = T.callMintZeroValueCoin(s, e.toCoin);
      let f = false, _;
      if (l) {
        let [h, m] = bt2.createAccountCap(c, o.sdkOptions, s);
        s = m, _ = h, f = true;
      }
      for (let h = 0; h < e.splitPaths.length; h += 1) {
        let m = e.splitPaths[h], g;
        for (let w2 = 0; w2 < m.basePaths.length; w2 += 1) {
          let y = m.basePaths[w2];
          if (y.label === "Deepbook") if (w2 === 0) if (m.basePaths.length === 1) {
            let p = this.buildDeepbookBasePathTx(o, y, s, _, u, a, false);
            u = p.from, a = p.to;
          } else {
            g = T.callMintZeroValueCoin(s, y.toCoin);
            let p = this.buildDeepbookBasePathTx(o, y, s, _, u, g, false);
            u = p.from, g = p.to;
          }
          else {
            let p = this.buildDeepbookBasePathTx(o, y, s, _, g, a, true);
            g = p.from, a = p.to;
          }
          if (y.label === "Cetus") if (w2 === 0) if (m.basePaths.length === 1) {
            let p = this.buildClmmBasePathTx(o, y, s, e.byAmountIn, u, a, false, i);
            u = p.from, a = p.to;
          } else {
            g = T.callMintZeroValueCoin(s, y.toCoin);
            let p = this.buildClmmBasePathTx(o, y, s, e.byAmountIn, u, g, false, i);
            u = p.from, g = p.to;
          }
          else {
            let p = this.buildClmmBasePathTx(o, y, s, e.byAmountIn, g, a, true, i);
            g = p.from, a = p.to, s.moveCall({ target: `${o.sdkOptions.integrate.published_at}::${pt2}::send_coin`, typeArguments: [y.fromCoin], arguments: [g, s.pure.address(c)] });
          }
        }
      }
      this.checkCoinThreshold(o, e.byAmountIn, s, a, d, e.toCoin), f && (s = bt2.deleteAccountCapByObject(_, o.sdkOptions, s));
    }
    return { fromCoin: u, toCoin: a, tx: s };
  }
  static async buildAggregatorSwapTransaction(o, e, t, n, i, r2) {
    let s = new Transaction(), c = e.byAmountIn ? Math.round(e.outputAmount * (1 - i)) : Math.round(e.inputAmount * (1 + i)), u = T.buildCoinForAmount(s, t, e.byAmountIn ? BigInt(e.inputAmount) : BigInt(c), e.fromCoin, false, true), a = u.originalSplitedCoin != null, l = T.buildCoinForAmount(s, t, /* @__PURE__ */ BigInt("0"), e.toCoin, false), d = await this.buildAggregatorSwapReturnCoins(o, e, u, l, n, i, s, r2), { fromCoin: f, toCoin: _ } = d;
    s = d.tx;
    let h = [];
    if (l.isMintZeroCoin ? h.push({ coinType: e.toCoin, coin: _ }) : l.originalSplitedCoin != null ? s.mergeCoins(l.originalSplitedCoin, [_]) : s.mergeCoins(l.targetCoin, [_]), a) {
      let m = u.originalSplitedCoin;
      s.mergeCoins(m, [f]);
    } else h.push({ coinType: e.fromCoin, coin: f });
    for (let m = 0; m < h.length; m++) this.buildTransferCoin(o, s, h[m].coin, h[m].coinType, r2);
    return s;
  }
  static checkCoinThreshold(o, e, t, n, i, r2) {
    e && t.moveCall({ target: `${o.sdkOptions.integrate.published_at}::${Se}::check_coin_threshold`, typeArguments: [r2], arguments: [n, t.pure.u64(i)] });
  }
  static buildDeepbookBasePathTx(o, e, t, n, i, r2, s) {
    let c = e.direction ? i : r2, u = e.direction ? r2 : i, a = [t.object(e.poolAddress), n, t.pure.u64(e.inputAmount), t.pure.u64(0), t.pure.bool(e.direction), c, u, t.pure.bool(s), t.object(J2)], l = e.direction ? [e.fromCoin, e.toCoin] : [e.toCoin, e.fromCoin], d = t.moveCall({ target: `${o.sdkOptions.deepbook_endpoint_v2.published_at}::endpoints_v2::swap`, typeArguments: l, arguments: a });
    return i = e.direction ? d[0] : d[1], r2 = e.direction ? d[1] : d[0], { from: i, to: r2, tx: t };
  }
  static buildClmmBasePathTx(o, e, t, n, i, r2, s, c) {
    let { clmm_pool: u, integrate: a } = o.sdkOptions, l = F2(u).global_config_id, d = e.direction ? i : r2, f = e.direction ? r2 : i, _ = c === "", h = _ ? Se : Me, m = _ ? "swap" : "swap_with_partner", g = n ? e.inputAmount.toString() : e.outputAmount.toString(), w2 = ne2.getDefaultSqrtPriceLimit(e.direction), y = _ ? [t.object(l), t.object(e.poolAddress), d, f, t.pure.bool(e.direction), t.pure.bool(n), t.pure.u64(g), t.pure.u128(w2.toString()), t.pure.bool(s), t.object(J2)] : [t.object(l), t.object(e.poolAddress), t.object(c), d, f, t.pure.bool(e.direction), t.pure.bool(n), t.pure.u64(g), t.pure.u128(w2.toString()), t.pure.bool(s), t.object(J2)], p = e.direction ? [e.fromCoin, e.toCoin] : [e.toCoin, e.fromCoin], A = t.moveCall({ target: `${a.published_at}::${h}::${m}`, typeArguments: p, arguments: y });
    return d = A[0], f = A[1], i = e.direction ? d : f, r2 = e.direction ? f : d, { from: i, to: r2, tx: t };
  }
  static buildCoinTypePair(o, e) {
    let t = [];
    if (o.length === 2) {
      let n = [];
      n.push(o[0], o[1]), t.push(n);
    } else {
      let n = [];
      n.push(o[0], o[o.length - 1]), t.push(n);
      for (let i = 1; i < o.length - 1; i += 1) {
        if (e[i - 1] === 0) continue;
        let r2 = [];
        r2.push(o[0], o[i], o[o.length - 1]), t.push(r2);
      }
    }
    return t;
  }
  static buildTransferCoinToSender(o, e, t, n) {
    e.moveCall({ target: `${o.sdkOptions.integrate.published_at}::${pt2}::transfer_coin_to_sender`, typeArguments: [n], arguments: [t] });
  }
  static buildTransferCoin(o, e, t, n, i) {
    i != null ? e.transferObjects([t], e.pure.address(i)) : T.buildTransferCoinToSender(o, e, t, n);
  }
};
var oe = T;
dn2(oe, "callMintZeroValueCoin", (o, e) => o.moveCall({ target: "0x2::coin::zero", typeArguments: [e] }));
var pe2 = new import_bn21.default(1e9);
var bt2 = class {
  static createAccountCap(o, e, t, n = false) {
    if (o.length === 0) throw Error("this config sdk senderAddress is empty");
    let { deepbook: i } = e, [r2] = t.moveCall({ target: `${i.published_at}::${_n}::create_account`, typeArguments: [], arguments: [] });
    return n && t.transferObjects([r2], t.pure.address(o)), [r2, t];
  }
  static deleteAccountCap(o, e, t) {
    let { deepbook: n } = e, i = [t.object(o)];
    return t.moveCall({ target: `${n.published_at}::${$e2}::delete_account_cap`, typeArguments: [], arguments: i }), t;
  }
  static deleteAccountCapByObject(o, e, t) {
    let { deepbook: n } = e, i = [o];
    return t.moveCall({ target: `${n.published_at}::${$e2}::delete_account_cap`, typeArguments: [], arguments: i }), t;
  }
  static async getAccountCap(o, e = true) {
    let t = await o.fullClient.getOwnedObjectsByPage(o.senderAddress, { options: { showType: true, showContent: true, showDisplay: e, showOwner: true }, filter: { MoveModule: { package: o.sdkOptions.deepbook.package_id, module: $e2 } } });
    return t.data.length === 0 ? "" : t.data[0].data.objectId;
  }
  static async getPools(o) {
    let e = o.sdkOptions.deepbook.package_id, t = [];
    try {
      (await o.fullClient.queryEventsByPage({ MoveEventType: `${e}::clob_v2::PoolCreated` })).data.forEach((i) => {
        let r2 = i.parsedJson;
        r2 && t.push({ poolID: r2.pool_id, tickSize: Number(r2.tick_size), lotSize: Number(r2.lot_size), takerFeeRate: Number(r2.taker_fee_rate), makerRebateRate: Number(r2.maker_rebate_rate), baseAsset: r2.base_asset.name, quoteAsset: r2.quote_asset.name });
      });
    } catch (n) {
      console.log("getPoolImmutables", n);
    }
    return t;
  }
  static async getPoolAsks(o, e, t, n) {
    var _a7;
    let { simulationAccount: i } = o.sdkOptions, { deepbook_endpoint_v2: r2 } = o.sdkOptions, s = new Transaction(), c = [], u = [t, n], a = [s.object(e), s.pure.u64("0"), s.pure.u64("999999999999"), s.object(J2)];
    s.moveCall({ target: `${r2.published_at}::endpoints_v2::get_level2_book_status_ask_side`, arguments: a, typeArguments: u });
    let d = (_a7 = (await o.fullClient.devInspectTransactionBlock({ transactionBlock: s, sender: i.address })).events) == null ? void 0 : _a7.filter((f) => P3(f.type).name === "BookStatus");
    if (d.length === 0) return c;
    for (let f = 0; f < d[0].parsedJson.depths.length; f++) {
      let _ = d[0].parsedJson.price[f], h = d[0].parsedJson.depths[f], m = { price: parseInt(_, 10), quantity: parseInt(h, 10) };
      c.push(m);
    }
    return c;
  }
  static async getPoolBids(o, e, t, n) {
    var _a7;
    let { simulationAccount: i } = o.sdkOptions, { deepbook_endpoint_v2: r2 } = o.sdkOptions, s = new Transaction(), c = [], u = [t, n], a = [s.object(e), s.pure.u64("0"), s.pure.u64("999999999999"), s.object(J2)];
    s.moveCall({ target: `${r2.published_at}::endpoints_v2::get_level2_book_status_bid_side`, arguments: a, typeArguments: u });
    let d = (_a7 = (await o.fullClient.devInspectTransactionBlock({ transactionBlock: s, sender: i.address })).events) == null ? void 0 : _a7.filter((f) => P3(f.type).name === "BookStatus");
    if (d.length === 0) return c;
    for (let f = 0; f < d[0].parsedJson.depths.length; f++) {
      let _ = d[0].parsedJson.price[f], h = d[0].parsedJson.depths[f], m = { price: parseInt(_, 10), quantity: parseInt(h, 10) };
      c.push(m);
    }
    return c;
  }
  static async preSwap(o, e, t, n) {
    let i = false, r2 = E, s = new import_bn21.default(n), c = E, u = new import_bn21.default(n);
    if (t) {
      let a = await this.getPoolBids(o, e.poolID, e.baseAsset, e.quoteAsset);
      a === null && (i = true), a = a.sort((l, d) => d.price - l.price);
      for (let l = 0; l < a.length; l += 1) {
        let d = new import_bn21.default(a[l].quantity), f = new import_bn21.default(a[l].price), _ = d.mul(new import_bn21.default(f)).mul(new import_bn21.default(e.takerFeeRate)).div(pe2).div(pe2);
        if (s.gt(d)) s = s.sub(d), r2 = r2.add(d.mul(f).div(pe2).sub(_)), c = c.add(_);
        else {
          let h = s.mul(new import_bn21.default(a[l].price)).div(pe2), m = h.mul(new import_bn21.default(e.takerFeeRate)).div(pe2);
          r2 = r2.add(h.sub(m)), s = s.sub(s), c = c.add(m);
        }
        if (s.eq(E)) break;
      }
    } else {
      let a = await this.getPoolAsks(o, e.poolID, e.baseAsset, e.quoteAsset);
      a === null && (i = true);
      for (let l = 0; l < a.length; l += 1) {
        let d = new import_bn21.default(a[l].price).mul(new import_bn21.default(a[l].quantity)).div(new import_bn21.default(1e9)), f = d.mul(new import_bn21.default(e.takerFeeRate)).div(pe2), _ = d.add(f);
        if (s.gt(d)) r2 = r2.add(new import_bn21.default(a[l].quantity)), s = s.sub(_), c = c.add(f);
        else {
          let h = new import_bn21.default(a[l].quantity).div(new import_bn21.default(e.lotSize)), m = _.div(h), g = s.div(m);
          r2 = r2.add(g.muln(e.lotSize)), s = s.sub(g.mul(m)), c = c.add(g.div(h).mul(f));
        }
        if (s.eq(E)) break;
      }
    }
    return { poolAddress: e.poolID, estimatedAmountIn: u.sub(s).toNumber(), estimatedAmountOut: r2.toNumber(), estimatedFeeAmount: c, isExceed: i, amount: Number(n), aToB: t, byAmountIn: true };
  }
  static async simulateSwap(o, e, t, n, i, r2) {
    var _a7, _b3, _c;
    let { deepbook_endpoint_v2: s } = o.sdkOptions, c = new Transaction(), u = await this.getAccountCap(o), a;
    if (u === "") {
      let C2 = this.createAccountCap(o.senderAddress, o.sdkOptions, c), v = C2[0];
      c = C2[1], a = v;
    } else a = c.object(u);
    let l = await o.getOwnerCoinAssets(o.senderAddress), f = (_a7 = oe.buildCoinForAmount(c, l, BigInt(r2), t, false)) == null ? void 0 : _a7.targetCoin, h = (_b3 = oe.buildCoinForAmount(c, l, BigInt(r2), n, false)) == null ? void 0 : _b3.targetCoin, m = [t, n], g = [c.object(e), a, c.pure.u64(r2), c.pure.u64(0), c.pure.bool(i), f, h, c.object(J2)];
    c.moveCall({ target: `${s.published_at}::${hn2}::swap`, arguments: g, typeArguments: m });
    let { simulationAccount: w2 } = o.sdkOptions, p = (_c = (await o.fullClient.devInspectTransactionBlock({ transactionBlock: c, sender: w2.address })).events) == null ? void 0 : _c.filter((C2) => P3(C2.type).name === "DeepbookSwapEvent");
    if (p.length === 0) return null;
    let A = p[0].parsedJson;
    return { poolAddress: A.pool, estimatedAmountIn: A.amount_in, estimatedAmountOut: A.amount_out, aToB: A.atob };
  }
};
var wt2 = { clmmConfig: { pools_id: "0xf699e7f2276f5c9a75944b37a0c5b5d9ddfd2471bf6242483b03ab2887d198d0", global_config_id: "0xdaa46292632c3c4d8f31f23ea0f9b36a28ff3677e9684980e4438403a67a3d8f", global_vault_id: "0xce7bceef26d3ad1f6d9b6f13a953f053e6ed3ca77907516481ce99ae8e588f2b", admin_cap_id: "0x89c1a321291d15ddae5a086c9abc533dff697fde3d89e0ca836c41af73e36a75" }, cetusConfig: { coin_list_id: "0x8cbc11d9e10140db3d230f50b4d30e9b721201c0083615441707ffec1ef77b23", launchpad_pools_id: "0x1098fac992eab3a0ab7acf15bb654fc1cf29b5a6142c4ef1058e6c408dd15115", clmm_pools_id: "0x15b6a27dd9ae03eb455aba03b39e29aad74abd3757b8e18c0755651b2ae5b71e", admin_cap_id: "0x39d78781750e193ce35c45ff32c6c0c3f2941fa3ddaf8595c90c555589ddb113", global_config_id: "0x0408fa4e4a4c03cc0de8f23d0c2bbfe8913d178713c9a271ed4080973fe42d8f", coin_list_handle: "0x49136005e90e28c4695419ed4194cc240603f1ea8eb84e62275eaff088a71063", launchpad_pools_handle: "0x5e194a8efcf653830daf85a85b52e3ae8f65dc39481d54b2382acda25068375c", clmm_pools_handle: "0x37f60eb2d9d227949b95da8fea810db3c32d1e1fa8ed87434fc51664f87d83cb" } };
var Xi2 = { fullRpcUrl: getFullnodeUrl("mainnet"), simulationAccount: { address: "0x0000000000000000000000000000000000000000000000000000000000000000" }, cetus_config: { package_id: "0x95b8d278b876cae22206131fb9724f701c9444515813042f54f0a426c9a3bc2f", published_at: "0x95b8d278b876cae22206131fb9724f701c9444515813042f54f0a426c9a3bc2f", config: wt2.cetusConfig }, clmm_pool: { package_id: "0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb", published_at: "0xc6faf3703b0e8ba9ed06b7851134bbbe7565eb35ff823fd78432baa4cbeaa12e", config: wt2.clmmConfig }, integrate: { package_id: "0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3", published_at: "0x2d8c2e0fc6dd25b0214b3fa747e0fd27fd54608142cd2e4f64c1cd350cc4add4" }, deepbook: { package_id: "0x000000000000000000000000000000000000000000000000000000000000dee9", published_at: "0x000000000000000000000000000000000000000000000000000000000000dee9" }, deepbook_endpoint_v2: { package_id: "0xac95e8a5e873cfa2544916c16fe1461b6a45542d9e65504c1794ae390b3345a7", published_at: "0xac95e8a5e873cfa2544916c16fe1461b6a45542d9e65504c1794ae390b3345a7" }, aggregatorUrl: "https://api-sui.cetus.zone/router", swapCountUrl: "https://api-sui.cetus.zone/v2/sui/swap/count", statsPoolsUrl: "https://api-sui.cetus.zone/v2/sui/stats_pools" };
var yt = { clmmConfig: { pools_id: "0x50eb61dd5928cec5ea04711a2e9b72e5237e79e9fbcd2ce3d5469dc8708e0ee2", global_config_id: "0x9774e359588ead122af1c7e7f64e14ade261cfeecdb5d0eb4a5b3b4c8ab8bd3e", global_vault_id: "0xf78d2ee3c312f298882cb680695e5e8c81b1d441a646caccc058006c2851ddea", admin_cap_id: "0xa456f86a53fc31e1243f065738ff1fc93f5a62cc080ff894a0fb3747556a799b" }, cetusConfig: { coin_list_id: "0x257eb2ba592a5480bba0a97d05338fab17cc3283f8df6998a0e12e4ab9b84478", launchpad_pools_id: "0xdc3a7bd66a6dcff73c77c866e87d73826e446e9171f34e1c1b656377314f94da", clmm_pools_id: "0x26c85500f5dd2983bf35123918a144de24e18936d0b234ef2b49fbb2d3d6307d", admin_cap_id: "0x1a496f6c67668eb2c27c99e07e1d61754715c1acf86dac45020c886ac601edb8", global_config_id: "0xe1f3db327e75f7ec30585fa52241edf66f7e359ef550b533f89aa1528dd1be52", coin_list_handle: "0x3204350fc603609c91675e07b8f9ac0999b9607d83845086321fca7f469de235", launchpad_pools_handle: "0xae67ff87c34aceea4d28107f9c6c62e297a111e9f8e70b9abbc2f4c9f5ec20fd", clmm_pools_handle: "0xd28736923703342b4752f5ed8c2f2a5c0cb2336c30e1fed42b387234ce8408ec" } };
var zi = { fullRpcUrl: getFullnodeUrl("testnet"), simulationAccount: { address: "0x0000000000000000000000000000000000000000000000000000000000000000" }, faucet: { package_id: "0x26b3bc67befc214058ca78ea9a2690298d731a2d4309485ec3d40198063c4abc", published_at: "0x26b3bc67befc214058ca78ea9a2690298d731a2d4309485ec3d40198063c4abc" }, cetus_config: { package_id: "0xf5ff7d5ba73b581bca6b4b9fa0049cd320360abd154b809f8700a8fd3cfaf7ca", published_at: "0xf5ff7d5ba73b581bca6b4b9fa0049cd320360abd154b809f8700a8fd3cfaf7ca", config: yt.cetusConfig }, clmm_pool: { package_id: "0x0c7ae833c220aa73a3643a0d508afa4ac5d50d97312ea4584e35f9eb21b9df12", published_at: "0x85e61285a10efc6602ab00df70a0c06357c384ef4c5633ecf73016df1500c704", config: yt.clmmConfig }, integrate: { package_id: "0x2918cf39850de6d5d94d8196dc878c8c722cd79db659318e00bff57fbb4e2ede", published_at: "0x19dd42e05fa6c9988a60d30686ee3feb776672b5547e328d6dab16563da65293" }, deepbook: { package_id: "0x000000000000000000000000000000000000000000000000000000000000dee9", published_at: "0x000000000000000000000000000000000000000000000000000000000000dee9" }, deepbook_endpoint_v2: { package_id: "0x56d90d0c055edb534b11e7548270bb458fd47c69b77bf40c14d5eb00e6e6cf64", published_at: "0x56d90d0c055edb534b11e7548270bb458fd47c69b77bf40c14d5eb00e6e6cf64" }, aggregatorUrl: "https://api-sui.devcetus.com/router", swapCountUrl: "https://api-sui.devcetus.com/v2/sui/swap/count", statsPoolsUrl: "https://api-sui.devcetus.com/v2/sui/stats_pools" };
var Ot2 = "router";
var Xe2 = "vaults";
var xt2 = 1e4;
var Bt = ((t) => (t.STATUS_RUNNING = "STATUS_RUNNING", t.STATUS_REBALANCING = "STATUS_REBALANCING", t))(Bt || {});
var $n2 = ((n) => (n.Haedal = "Haedal", n.Volo = "Volo", n.Aftermath = "aftermath", n))($n2 || {});
var Rt2 = ((i) => (i.Cetus = "Cetus", i.Haedal = "Haedal", i.Volo = "Volo", i.Aftermath = "aftermath", i))(Rt2 || {});
var jt2 = ((t) => (t.Both = "both", t.OneSide = "oneSide", t))(jt2 || {});
var Q = class extends Error {
  constructor(e, t) {
    super(e);
    __publicField(this, "message");
    __publicField(this, "errorCode");
    this.message = e, this.errorCode = t;
  }
  static isClmmpoolsErrorCode(e, t) {
    return e instanceof Q && e.errorCode === t;
  }
};
var we2 = "0x0000000000000000000000000000000000000000000000000000000000000006";
var Je = "router";
function U2(o) {
  if (o.config === void 0) throw new Q(`package: ${o.package_id}  not config in sdk SdkOptions`, "InvalidConfig");
  return o.config;
}
var R = class {
  static generateNextTickRange(e, t, n) {
    let i = e - t / 2, r2 = e + t / 2;
    return { new_tick_lower: R.getValidTickIndex(i, n), new_tick_upper: R.getValidTickIndex(r2, n) };
  }
  static calculateDepositRatio(e, t, n) {
    let i = O.sqrtPriceX64ToTickIndex(n);
    if (i < e) return { ratioA: new decimal_default(1), ratioB: new decimal_default(0) };
    if (i > t) return { ratioA: new decimal_default(0), ratioB: new decimal_default(1) };
    let r2 = new import_bn28.default(1e8), { coinAmountB: s } = V.estLiquidityAndcoinAmountFromOneAmounts(e, t, r2, true, true, 0, n), c = O.sqrtPriceX64ToPrice(n, 0, 0), u = b(r2.toString()).mul(c), a = u.add(s.toString()), l = u.div(a), d = b(s.toString()).div(a);
    return { ratioA: l, ratioB: d };
  }
  static getValidTickIndex(e, t) {
    if (e % t === 0) return e;
    let n;
    if (e > 0 ? n = e - e % t + t : e < 0 ? n = e + Math.abs(e) % t - t : n = e, n % t !== 0) throw new Error("Assertion failed: res % tickSpacing == 0");
    if (Math.abs(n) < Math.abs(e)) throw new Error("Assertion failed: res.abs() >= tickIndex");
    return n;
  }
  static get_lp_amount_by_liquidity(e, t) {
    return e.total_supply === "0" ? "0" : b(e.total_supply).mul(t).div(e.liquidity).toFixed(0, decimal_default.ROUND_DOWN).toString();
  }
  static get_share_liquidity_by_amount(e, t) {
    return e.total_supply === "0" ? "0" : b(t).mul(e.liquidity).div(e.total_supply).toFixed(0, decimal_default.ROUND_DOWN).toString();
  }
  static get_protocol_fee_amount(e, t) {
    return b(t).mul(e.protocol_fee_rate).div(xt2).toFixed(0, decimal_default.ROUND_CEIL);
  }
  static buildFramsPositionNFT(e) {
    let t = e.clmm_postion.fields;
    return { id: e.id.id, url: t.url, pool_id: e.pool_id, coinTypeA: P3(t.coin_type_a.fields.name).full_address, coinTypeB: P3(t.coin_type_b.fields.name).full_address, description: t.description, name: t.name, liquidity: t.liquidity, clmm_position_id: t.id.id, clmm_pool_id: t.pool, tick_lower_index: re2(BigInt(t.tick_lower_index.fields.bits)), tick_upper_index: re2(BigInt(t.tick_upper_index.fields.bits)), rewards: [] };
  }
  static buildPool(e) {
    let t = ae2(e), n = It(e), { positions: i } = t;
    if (t && i.length > 0) {
      let r2 = R.buildFramsPositionNFT(i[0].fields);
      return { id: t.id.id, pool_id: t.pool, protocol_fee_rate: t.protocol_fee_rate, is_pause: t.is_pause, harvest_assets: { harvest_assets_handle: t.harvest_assets.fields.id.id, size: Number(t.harvest_assets.fields.size) }, lp_token_type: P3(n).type_arguments[0], total_supply: t.lp_token_treasury.fields.total_supply.fields.value, liquidity: t.liquidity, max_quota: t.max_quota, status: t.status === 1 ? "STATUS_RUNNING" : "STATUS_REBALANCING", quota_based_type: t.quota_based_type.fields.name, position: r2 };
    }
  }
  static async getSuiCoin(e, t, n) {
    let i = await e.getOwnerCoinAssets(e.getVerifySenderAddress(), be2);
    n = n || new Transaction();
    let r2;
    if (t > 95e10) {
      let [s, ...c] = i;
      c.length > 0 && n.mergeCoins(n.object(s.coinObjectId), c.map((u) => n.object(u.coinObjectId))), r2 = n.splitCoins(n.object(s.coinObjectId), [t]);
    } else r2 = oe.buildCoinForAmount(n, i, BigInt(t), be2, false, true).targetCoin;
    return r2;
  }
  static buildCoinWithBalance(e, t, n) {
    return e === BigInt(0) && I.isSuiCoin(t) ? n.add(coinWithBalance({ balance: e, useGasCoin: false })) : n.add(coinWithBalance({ balance: e, type: t }));
  }
};
var ye2 = class {
  static async getExchangeRateForStake(e, t, n) {
    let { vaults: i } = e.sdkOptions, { haedal: r2 } = F2(i);
    if (r2 === void 0) throw Error("the haedal config is undefined");
    let { simulationAccount: s } = e.sdkOptions, { staking_id: c } = F2(r2);
    try {
      let u = new Transaction();
      t ? await this.requestStake(e, n || 1e9, u) : u.moveCall({ target: `${r2.published_at}::staking::get_exchange_rate`, typeArguments: [], arguments: [u.object(c)] });
      let a = await e.fullClient.devInspectTransactionBlock({ transactionBlock: u, sender: t ? e.senderAddress : s.address });
      if (t) {
        let f = a.events.find((g) => g.type.includes("UserStaked")), { sui_amount: _, st_amount: h } = f.parsedJson;
        return b(_).div(h).toString();
      }
      let l = a.results[0].returnValues[0][0];
      return b(suiBcs.u64().parse(Uint8Array.from(l))).div(1e6).toString();
    } catch (u) {
      console.log("getExchangeRateForHaedal", u);
    }
    return "0";
  }
  static async requestStake(e, t, n) {
    var _a7, _b3;
    let { vaults: i } = e.sdkOptions;
    n = n || new Transaction();
    let r2 = await R.getSuiCoin(e, t, n);
    return n.moveCall({ target: `${(_b3 = (_a7 = i.config) == null ? void 0 : _a7.haedal) == null ? void 0 : _b3.published_at}::interface::request_stake`, typeArguments: [], arguments: [n.object(normalizeSuiObjectId("0x5")), n.object(i.config.haedal.config.staking_id), r2, n.pure.address(normalizeSuiObjectId("0x0"))] }), n;
  }
  static requestStakeCoin(e, t, n) {
    let { haedal: i } = e.sdkOptions.vaults.config;
    return t.moveCall({ target: `${i.published_at}::staking::request_stake_coin`, typeArguments: [], arguments: [t.object(normalizeSuiObjectId("0x5")), t.object(i.config.staking_id), n, t.pure.address(normalizeSuiObjectId("0x0"))] });
  }
};
var Ae = class {
  static async getExchangeRateForStake(e, t, n) {
    let { vaults: i } = e.sdkOptions, { volo: r2 } = F2(i);
    if (r2 === void 0) throw Error("the volo config is undefined");
    let { simulationAccount: s } = e.sdkOptions, { native_pool: c, vsui_metadata: u } = F2(r2);
    try {
      let a = new Transaction();
      t ? await this.requestStake(e, n || 1e9, a) : a.moveCall({ target: `${r2.published_at}::native_pool::get_ratio`, typeArguments: [], arguments: [a.object(c), a.object(u)] });
      let l = await e.fullClient.devInspectTransactionBlock({ transactionBlock: a, sender: t ? e.senderAddress : s.address });
      if (t) {
        let _ = l.events.find((g) => g.type.includes("StakedEvent")), { cert_amount: h, sui_amount: m } = _.parsedJson;
        return b(m).div(h).toString();
      }
      let d = l.results[0].returnValues[0][0], f = b(suiBcs.u256().parse(Uint8Array.from(d))).div("1000000000000000000").toNumber();
      return b(1).div(f).toString();
    } catch (a) {
      console.log("getExchangeRateForHaedal", a);
    }
    return "0";
  }
  static async requestStake(e, t, n) {
    let { vaults: i } = e.sdkOptions, { volo: r2 } = F2(i);
    if (r2 === void 0) throw Error("the volo config is undefined");
    n = n || new Transaction();
    let { native_pool: s, vsui_metadata: c } = F2(r2), u = await R.getSuiCoin(e, t, n);
    return n.moveCall({ target: `${r2.published_at}::native_pool::stake`, typeArguments: [], arguments: [n.object(s), n.object(c), n.object(normalizeSuiObjectId("0x5")), u] }), n;
  }
  static requestStakeCoin(e, t, n) {
    let { vaults: i } = e.sdkOptions, { volo: r2 } = F2(i);
    if (r2 === void 0) throw Error("the volo config is undefined");
    t = t || new Transaction();
    let { native_pool: s, vsui_metadata: c } = F2(r2);
    return t.moveCall({ target: `${r2.published_at}::native_pool::stake_non_entry`, typeArguments: [], arguments: [t.object(s), t.object(c), t.object(normalizeSuiObjectId("0x5")), n] });
  }
};
var ve2 = class {
  static async getExchangeRateForStake(e, t, n) {
    let { vaults: i } = e.sdkOptions, { aftermath: r2 } = F2(i);
    if (r2 === void 0) throw Error("the aftermath config is undefined");
    let { simulationAccount: s } = e.sdkOptions, { staked_sui_vault: c, safe: u } = F2(r2);
    try {
      let a = new Transaction();
      t ? await this.requestStake(e, n || 1e9, a) : a.moveCall({ target: `${r2.published_at}::staked_sui_vault::afsui_to_sui_exchange_rate`, typeArguments: [], arguments: [a.object(c), a.object(u)] });
      let l = await e.fullClient.devInspectTransactionBlock({ transactionBlock: a, sender: t ? e.senderAddress : s.address });
      if (t) {
        let _ = l.events.find((g) => g.type.includes("StakedEvent")), { afsui_amount: h, sui_amount: m } = _.parsedJson;
        return b(m).div(h).toString();
      }
      let d = l.results[0].returnValues[0][0];
      return b(suiBcs.u128().parse(Uint8Array.from(d))).div(1e18).toString();
    } catch (a) {
      console.log("getExchangeRateForHaedal", a);
    }
    return "0";
  }
  static async requestStake(e, t, n) {
    let { vaults: i } = e.sdkOptions, { aftermath: r2 } = F2(i);
    if (r2 === void 0) throw Error("the aftermath config is undefined");
    n = n || new Transaction();
    let { staked_sui_vault: s, referral_vault: c, safe: u, validator_address: a } = F2(r2), l = await R.getSuiCoin(e, t, n);
    return n.moveCall({ target: `${r2.published_at}::staked_sui_vault::request_stake_and_keep`, typeArguments: [], arguments: [n.object(s), n.object(u), n.object(normalizeSuiObjectId("0x5")), n.object(c), l, n.pure.address(normalizeSuiObjectId(a))] }), n;
  }
  static requestStakeCoin(e, t, n) {
    let { vaults: i } = e.sdkOptions, { aftermath: r2 } = F2(i);
    if (r2 === void 0) throw Error("the aftermath config is undefined");
    t = t || new Transaction();
    let { staked_sui_vault: s, referral_vault: c, safe: u, validator_address: a } = F2(r2);
    return t.moveCall({ target: `${r2.published_at}::staked_sui_vault::request_stake`, typeArguments: [], arguments: [t.object(s), t.object(u), t.object(normalizeSuiObjectId("0x5")), t.object(c), n, t.pure.address(normalizeSuiObjectId(a))] });
  }
};
var qe = class {
  constructor(e) {
    __publicField(this, "_sdk");
    __publicField(this, "_cache", {});
    __publicField(this, "getOwnerVaultsBalance", async (e) => {
      let { data: t } = await this.getVaultList(), n = [];
      for (let i = 0; i < t.length; i++) {
        let r2 = t[i], s = await this._sdk.fullClient.getBalance({ owner: e, coinType: r2.lp_token_type }), c = await this._sdk.Pool.getPool(r2.pool_id, true), u = R.get_share_liquidity_by_amount(r2, s.totalBalance), { tick_lower_index: a, tick_upper_index: l, coinTypeA: d, coinTypeB: f } = r2.position, _ = O.tickIndexToSqrtPriceX64(a), h = O.tickIndexToSqrtPriceX64(l), m = V.getCoinAmountFromLiquidity(new import_bn27.BN(u), new import_bn27.BN(c.current_sqrt_price), _, h, true);
        n.push({ vault_id: t[i].id, clmm_pool_id: r2.pool_id, owner: e, lp_token_type: r2.lp_token_type, lp_token_balance: s.totalBalance, liquidity: u, tick_lower_index: a, tick_upper_index: l, amount_a: m.coinA.toString(), amount_b: m.coinB.toString(), coin_type_a: d, coin_type_b: f });
      }
      return n;
    });
    this._sdk = e;
  }
  get sdk() {
    return this._sdk;
  }
  async calculateDepositAmount(e, t = true, n = false) {
    return e.side === "both" ? await this.calculateAmountFromBoth(e, true) : await this.calculateDepositAmountFromOneSide(e, t, n);
  }
  async calculateWithdrawAmount(e) {
    if (e.side === "both") {
      if (e.is_ft_input) return __spreadProps(__spreadValues({}, await this.estLiquidityAmountFromFtAmount(__spreadProps(__spreadValues({}, e), { input_ft_amount: e.input_amount }))), { request_id: e.input_amount, burn_ft_amount: e.input_amount, side: e.side });
      let i = await this.calculateAmountFromBoth(e, false);
      return __spreadProps(__spreadValues({}, i), { request_id: e.input_amount, burn_ft_amount: i.ft_amount, side: e.side });
    }
    let { vault: t } = await this.getVaultAndPool(e.vault_id), n = R.get_share_liquidity_by_amount(t, e.max_ft_amount);
    return await this.calculateWithdrawAmountFromOneSide({ fix_amount_a: e.fix_amount_a, vault_id: e.vault_id, receive_amount: e.is_ft_input ? "0" : e.input_amount, slippage: e.slippage, maxLiquidity: n, removeLiquidity: e.is_ft_input ? R.get_share_liquidity_by_amount(t, e.input_amount) : void 0 }, true);
  }
  async calculateWithdrawAmountFromOneSide(e, t, n) {
    try {
      let { vault_id: i, removeLiquidity: r2, maxLiquidity: s } = e, { vault: c, pool: u } = await this.getVaultAndPool(i), { position: a } = c, l = a.tick_lower_index, d = a.tick_upper_index, f = r2 === s, _ = R.calculateDepositRatio(l, d, new import_bn27.BN(u.current_sqrt_price)), h = e.fix_amount_a ? _.ratioA : _.ratioB, m = b(e.receive_amount).mul(h), g, w2;
      if (r2) {
        let N = O.tickIndexToSqrtPriceX64(l), Y = O.tickIndexToSqrtPriceX64(d), K2 = V.getCoinAmountFromLiquidity(new import_bn27.BN(r2), new import_bn27.BN(u.current_sqrt_price), N, Y, false);
        w2 = r2, g = e.fix_amount_a ? K2.coinB.toString() : K2.coinA.toString(), m = e.fix_amount_a ? b(K2.coinA.toString()) : b(K2.coinB.toString());
      } else {
        let N = V.estLiquidityAndcoinAmountFromOneAmounts(l, d, new import_bn27.BN(m.toFixed(0)), e.fix_amount_a, false, e.slippage, new import_bn27.BN(u.current_sqrt_price));
        w2 = N.liquidityAmount.toString(), g = e.fix_amount_a ? N.coinAmountB.toString() : N.coinAmountA.toString();
      }
      let y = !e.fix_amount_a, p = await this.findRouters(u.poolAddress, u.current_sqrt_price.toString(), e.fix_amount_a ? u.coinTypeB : u.coinTypeA, e.fix_amount_a ? u.coinTypeA : u.coinTypeB, b(g), true, [u.poolAddress], { poolID: u.poolAddress, ticklower: l, tickUpper: d, deltaLiquidity: Number(w2) }), A = m.add(p.amount_out), C2 = b(e.receive_amount), v = C2.sub(A);
      if (!f && (!e.removeLiquidity || e.removeLiquidity && n) && v.abs().greaterThan(C2.mul(0.01))) {
        let N = A.lessThan(C2), Y, K2;
        n ? N ? (Y = b(w2), K2 = n.right) : (Y = n.left, K2 = b(w2)) : (Y = N ? b(w2) : b(0), K2 = N ? b(e.maxLiquidity) : b(w2));
        let Ee2 = b(Y).add(K2).div(2).toFixed(0);
        if (!n || n && n.count < 15 && Y < K2) return await this.calculateWithdrawAmountFromOneSide(__spreadProps(__spreadValues({}, e), { removeLiquidity: Ee2 }), t, { left: Y, right: K2, count: n ? n.count + 1 : 0 });
      }
      let B2 = p.amount_in && p.fee_amount ? new import_bn27.BN(p.amount_in).add(new import_bn27.BN(p.fee_amount)).toString() : p.amount_in, j2 = p.amount_out, { is_exceed: D } = p, G = R.get_lp_amount_by_liquidity(c, w2.toString()), L = await this.estLiquidityAmountFromFtAmount({ vault_id: i, input_ft_amount: G, slippage: e.slippage });
      return __spreadProps(__spreadValues({ side: "oneSide" }, L), { burn_ft_amount: G, request_id: e.receive_amount, swap_result: { swap_in_amount: B2, swap_out_amount: j2, a2b: y, is_exceed: D, sui_stake_protocol: "Cetus", route_obj: p.route_obj } });
    } catch (i) {
      if (t && (String(i) === "Error: route unavailable" || String(i) === "Error: router timeout")) return await this.calculateWithdrawAmountFromOneSide(e, false);
      throw i;
    }
  }
  async calculateDepositAmountFromOneSide(e, t, n = false, i = true, r2 = 5, s = 0.02) {
    try {
      let { vault_id: c, input_amount: u, fix_amount_a: a, slippage: l } = e, { vault: d, pool: f } = await this.getVaultAndPool(c), { position: _ } = d, h = _.tick_lower_index, m = _.tick_upper_index, g = O.sqrtPriceX64ToTickIndex(new import_bn27.BN(f.current_sqrt_price)), { ratioA: w2, ratioB: y } = R.calculateDepositRatio(h, m, new import_bn27.BN(f.current_sqrt_price)), p = b(u).mul(a ? w2 : y), A = b(u).sub(p), C2 = a;
      if (A.toFixed(0) === "0") return await this.calculateAmountFromBoth(e, true);
      let v, B2, j2, D, G, L, z, N = this.findSuiStakeProtocol(_.coinTypeA, _.coinTypeB, a);
      if (N !== "Cetus") v = await this.calculateStakeDepositFixSui({ inputSuiAmount: b(e.input_amount), swapSuiAmount: A, lowerTick: h, upperTick: m, curSqrtPrice: f.current_sqrt_price.toString(), remainRate: 0.01, fixCoinA: e.fix_amount_a, rebalanceCount: 0, shouldRequestStake: t, leftSuiAmount: C2 ? new decimal_default(A.toFixed(0)) : new decimal_default(0), rightSuiAmount: C2 ? new decimal_default(e.input_amount) : new decimal_default(A.toFixed(0)), slippage: l, stakeProtocol: N }), j2 = f.current_sqrt_price.toString(), D = v.fixAmountA, G = v.swapInAmount, L = v.swapOutAmount, z = v.swapOutAmountLimit;
      else {
        v = await this.findRouters(f.poolAddress, f.current_sqrt_price.toString(), C2 ? f.coinTypeA : f.coinTypeB, C2 ? f.coinTypeB : f.coinTypeA, A, true, [f.poolAddress]), B2 = this.paresSwapData(v, e.input_amount, e.fix_amount_a, C2, h, m, w2, y, l), z = B2.swapOutAmountLimit;
        let Ut2 = b(e.input_amount).mul(s);
        if (b(e.input_amount).sub(B2.preAmountTotal).gt(Ut2)) {
          let Gt2 = { clmm_pool: f.poolAddress, curSqrtPrice: f.current_sqrt_price.toString(), a2b: C2, amount_a: C2 ? b(u) : b(0), amount_b: C2 ? b(0) : b(e.input_amount), amount_left: C2 ? b(A.toFixed(0)) : b(0), amount_right: C2 ? b(u) : b(A.toFixed(0)), lowerTick: h, upperTick: m, tick_spacing: 2, coinTypeA: _.coinTypeA, coinTypeB: _.coinTypeB, remainRate: 0.02, priceSplitPoint: l, useRoute: i, maxLoopLimit: r2 };
          v = n && g <= m ? await this.calculateRebalance(Gt2) : await this.findRouters(f.poolAddress, f.current_sqrt_price.toString(), C2 ? f.coinTypeA : f.coinTypeB, C2 ? f.coinTypeB : f.coinTypeA, A, true, [f.poolAddress]);
        }
        j2 = v.after_sqrt_price, B2 = this.paresSwapData(v, e.input_amount, e.fix_amount_a, C2, h, m, w2, y, l), z = B2.swapOutAmountLimit, D = B2.fixAmountA, G = B2.swapInAmount, L = B2.swapOutAmount, j2 = B2.afterSqrtPrice;
      }
      let Y = D === a ? b(u).sub(G).toFixed(0) : N === "Cetus" ? z : L, K2 = V.estLiquidityAndcoinAmountFromOneAmounts(h, m, new import_bn27.BN(Y), D, true, l, new import_bn27.BN(j2)), Ee2 = K2.coinAmountA.toString(), ot = K2.coinAmountB.toString(), Vt = R.get_lp_amount_by_liquidity(d, K2.liquidityAmount.toString());
      return { request_id: e.input_amount, side: "oneSide", amount_a: Ee2, amount_b: ot, amount_limit_a: K2.tokenMaxA.toString(), amount_limit_b: K2.tokenMaxB.toString(), ft_amount: Vt, original_input_amount: e.input_amount, fix_amount_a: D, swap_result: { swap_in_amount: G, swap_out_amount: L, a2b: a, sui_stake_protocol: N, route_obj: v.route_obj, is_exceed: v.is_exceed, afterSqrtPrice: j2 } };
    } catch (c) {
      if (i && (String(c) === "Error: route unavailable" || String(c) === "Error: router timeout")) return await this.calculateDepositAmountFromOneSide(e, t, false);
      throw c;
    }
  }
  paresSwapData(e, t, n, i, r2, s, c, u, a) {
    let l = e.after_sqrt_price, d = O.sqrtPriceX64ToTickIndex(new import_bn27.BN(l)), { ratioA: f, ratioB: _ } = R.calculateDepositRatio(r2, s, new import_bn27.BN(l)), h = _.div(f).sub(u.div(c)).greaterThan("0"), m = e.amount_in && e.fee_amount ? new import_bn27.BN(e.amount_in).add(new import_bn27.BN(e.fee_amount)).toString() : e.amount_in, g = e.amount_out, w2 = b(e.amount_out).mul(1 - a).toFixed(0), y = h === i ? new import_bn27.BN(b(t).sub(m).toString()) : new import_bn27.BN(w2), p = b(t);
    if (d < r2) h = true;
    else if (d > s) h = false;
    else {
      let A = V.estLiquidityAndcoinAmountFromOneAmounts(r2, s, y, h, true, 0, new import_bn27.BN(l)), C2 = A.coinAmountA, v = A.coinAmountB;
      p = b(n ? C2.toString() : v.toString()).add(m), p.greaterThanOrEqualTo(t) && (h = !h);
    }
    return { preAmountTotal: p, fixAmountA: h, swapInAmount: m, swapOutAmount: g, swapOutAmountLimit: w2, afterSqrtPrice: l };
  }
  async calculateStakeDepositFixSui(e) {
    let t = e.inputSuiAmount.mul(e.remainRate), n = e.inputSuiAmount.sub(e.swapSuiAmount), i;
    e.shouldRequestStake ? i = await this.getExchangeRateForStake(e.stakeProtocol, e.shouldRequestStake, Number(e.swapSuiAmount.toFixed(0))) : i = e.exchangeRate ? e.exchangeRate : await this.getExchangeRateForStake(e.stakeProtocol, e.shouldRequestStake, Number(e.swapSuiAmount.toFixed(0)));
    let r2 = e.swapSuiAmount.div(i).toFixed(0, decimal_default.ROUND_DOWN), s = V.estLiquidityAndcoinAmountFromOneAmounts(e.lowerTick, e.upperTick, new import_bn27.BN(r2.toString()), !e.fixCoinA, true, 0, new import_bn27.BN(e.curSqrtPrice)), c = e.fixCoinA ? s.coinAmountA.toString() : s.coinAmountB.toString(), u = b(n).sub(c);
    return u.greaterThanOrEqualTo(0) && u.lessThanOrEqualTo(t) || e.rebalanceCount > 12 || e.leftSuiAmount.greaterThanOrEqualTo(e.rightSuiAmount) ? { swapInAmount: e.swapSuiAmount.toFixed(0), swapOutAmount: r2, swapOutAmountLimit: b(r2).mul(1 - e.slippage).toFixed(0), afterSqrtPrice: e.curSqrtPrice, fixAmountA: !e.fixCoinA, is_exceed: true, request_id: "", stake_protocol: e.stakeProtocol } : u.lessThan(0) ? await this.calculateStakeDepositFixSui(__spreadProps(__spreadValues({}, e), { rightSuiAmount: e.swapSuiAmount, swapSuiAmount: e.swapSuiAmount.add(e.leftSuiAmount).div(2), exchangeRate: i, rebalanceCount: e.rebalanceCount + 1 })) : u.greaterThan(t) ? await this.calculateStakeDepositFixSui(__spreadProps(__spreadValues({}, e), { leftSuiAmount: e.swapSuiAmount, swapSuiAmount: e.swapSuiAmount.add(e.rightSuiAmount).div(2), exchangeRate: i, rebalanceCount: e.rebalanceCount + 1 })) : null;
  }
  async getExchangeRateForStake(e, t, n) {
    return e === "Haedal" ? await ye2.getExchangeRateForStake(this._sdk, t, n) : e === "Volo" ? await Ae.getExchangeRateForStake(this._sdk, t, n) : e === "aftermath" ? await ve2.getExchangeRateForStake(this._sdk, t, n) : "0";
  }
  async findRouters(e, t, n, i, r2, s, c, u, a = false) {
    var _a7, _b3;
    let { aggregator: l } = this._sdk.sdkOptions, d = `${l.walletAddress}_getAggregatorClient`, f = this.getCache(d, a), _;
    if (f !== void 0) _ = f;
    else {
      let h = new SuiClient({ url: this.sdk.sdkOptions.fullRpcUrl });
      _ = new AggregatorClient23({ endpoint: l.endPoint, signer: l.walletAddress, client: h, env: l.env, pythUrls: l.pythUrls });
    }
    try {
      let h = { from: n, target: i, amount: new import_bn27.BN(r2.toFixed(0).toString()), byAmountIn: s, depth: 3, providers: l.providers };
      u && u.poolID && (h.liquidityChanges = [u]);
      let m = await _.findRouters(h);
      if (((_a7 = m == null ? void 0 : m.error) == null ? void 0 : _a7.code) === 10001) return __spreadProps(__spreadValues({}, m), { is_exceed: m.insufficientLiquidity });
      if (m == null ? void 0 : m.insufficientLiquidity) return __spreadProps(__spreadValues({}, m), { is_exceed: m.insufficientLiquidity });
      if (!(m == null ? void 0 : m.routes) || ((_b3 = m == null ? void 0 : m.routes) == null ? void 0 : _b3.length) === 0) throw Error("Aggregator no router");
      let g = t;
      return m.routes.forEach((w2) => {
        let y = w2.path.find((p) => p.id.toLowerCase() === e.toLowerCase());
        y && y.extendedDetails && y.extendedDetails.afterSqrtPrice && (g = String(y.extendedDetails.afterSqrtPrice));
      }), { amount_in: m.amountIn.toString(), amount_out: m.amountOut.toString(), is_exceed: m.insufficientLiquidity, after_sqrt_price: g, route_obj: m, byAmountIn: true, liquidity: u == null ? void 0 : u.deltaLiquidity, originRes: m };
    } catch (e2) {
      try {
        if (c) {
          let m = await _.swapInPools({ from: n, target: i, amount: new import_bn27.BN(r2.toFixed(0).toString()), byAmountIn: s, pools: c });
          if (m) {
            let g = t;
            return m.routeData.routes.forEach((w2) => {
              let y = w2.path.find((p) => p.id.toLowerCase() === e.toLowerCase());
              y && (g = String(y.extendedDetails.afterSqrtPrice));
            }), { amount_in: m.routeData.amountIn.toString(), amount_out: m.routeData.amountOut.toString(), is_exceed: m.isExceed, after_sqrt_price: g, route_obj: m.routeData, byAmountIn: true, liquidity: u == null ? void 0 : u.deltaLiquidity, originRes: m };
          }
          return null;
        }
        return null;
      } catch (e3) {
        return null;
      }
    }
  }
  async calculateRebalance(e) {
    let { clmm_pool: t, a2b: n, curSqrtPrice: i, amount_a: r2, amount_b: s, lowerTick: c, upperTick: u, amount_left: a, amount_right: l, coinTypeA: d, coinTypeB: f, useRoute: _, priceSplitPoint: h, remainRate: m, maxLoopLimit: g = 5 } = e, w2 = async (y, p, A) => {
      let C2 = y.plus(p).div(2), v = await this.findRouters(t, i, d, f, C2, n, [t]);
      if (v.amount_out === "0") return v;
      if (v.after_sqrt_price || (v.after_sqrt_price = e.curSqrtPrice), v.is_exceed) return p = C2, w2(y, p, A + 1);
      let B2 = n ? r2.sub(v.amount_in) : r2.add(v.amount_out), j2 = n ? s.add(v.amount_out) : s.sub(v.amount_in), D = V.estLiquidityAndcoinAmountFromOneAmounts(c, u, new import_bn27.BN(B2.toString()), true, true, 1, new import_bn27.BN(v.after_sqrt_price)), G = new decimal_default(D.coinAmountA.toString()), L = new decimal_default(D.coinAmountB.toString());
      if (G.toString() !== B2.toString()) throw new Error("usedA does not match afterA");
      if (j2.lessThan(L)) n ? y = C2 : p = C2;
      else {
        n ? p = C2 : y = C2;
        let z = j2.sub(L);
        if (j2.mul(m).sub(z).greaterThanOrEqualTo(0) || A >= g) return __spreadProps(__spreadValues({}, v), { remainingB: z });
      }
      return y.greaterThan(p) || p.sub(y).lessThan(10) ? v : w2(y, p, A + 1);
    };
    return a.greaterThanOrEqualTo(l) ? w2(new decimal_default(0), a, 0) : w2(a, l, 0);
  }
  async calculateAmountFromBoth(e, t) {
    let { vault_id: n, input_amount: i, fix_amount_a: r2, slippage: s } = e, { vault: c, pool: u } = await this.getVaultAndPool(n), { position: a } = c, l = a.tick_lower_index, d = a.tick_upper_index, f = V.estLiquidityAndcoinAmountFromOneAmounts(l, d, new import_bn27.BN(i), r2, t, s, new import_bn27.BN(u.current_sqrt_price)), _ = R.get_lp_amount_by_liquidity(c, f.liquidityAmount.toString());
    return { request_id: e.input_amount, amount_a: f.coinAmountA.toString(), amount_b: f.coinAmountB.toString(), amount_limit_a: f.tokenMaxA.toString(), amount_limit_b: f.tokenMaxB.toString(), original_input_amount: e.input_amount, ft_amount: _, fix_amount_a: r2, side: "both" };
  }
  async estLiquidityAmountFromFtAmount(e) {
    let { vault_id: t, input_ft_amount: n, slippage: i } = e, { vault: r2, pool: s } = await this.getVaultAndPool(t), { position: c } = r2, u = c.tick_lower_index, a = c.tick_upper_index, l = O.tickIndexToSqrtPriceX64(u), d = O.tickIndexToSqrtPriceX64(a), f = new import_bn27.BN(n), _ = R.get_share_liquidity_by_amount(r2, f.toString()), h = new import_bn27.BN(s.current_sqrt_price), m = V.getCoinAmountFromLiquidity(new import_bn27.BN(_), h, l, d, false), g = b(m.coinA.toString()).mul(b(1 - i)), w2 = b(m.coinB.toString()).mul(b(1 - i));
    return { amount_a: m.coinA.toString(), amount_b: m.coinB.toString(), amount_limit_a: g.toFixed(0), amount_limit_b: w2.toFixed(0) };
  }
  async deposit(e, t) {
    let { vault_id: n, slippage: i, coin_object_a: r2, coin_object_b: s, return_lp_token: c, deposit_result: u } = e, { swap_result: a, amount_a: l, amount_b: d, fix_amount_a: f, partner: _, side: h, original_input_amount: m } = u, { vault: g, pool: w2 } = await this.getVaultAndPool(n, false), y, p, A;
    if (h === "oneSide" && a) {
      A = (a.a2b ? r2 : s) || t.add(coinWithBalance({ balance: BigInt(m), type: a.a2b ? w2.coinTypeA : w2.coinTypeB }));
      let D = [a.swap_in_amount, b(m).sub(b(a.swap_in_amount)).toFixed(0, decimal_default.ROUND_DOWN)], [G, L] = t.splitCoins(A, D);
      console.log("spitCoins spitAmounts:", D);
      let { swap_out_coin: z } = await this.handleDepositSwap({ coinTypeA: w2.coinTypeA, coinTypeB: w2.coinTypeB, slippage: i, clmm_pool_address: w2.poolAddress, partner: _, swap_in_amount: a.swap_in_amount, swap_in_coin: G, a2b: a.a2b, sui_stake_protocol: a.sui_stake_protocol, route_obj: a.route_obj }, t);
      a.a2b ? (y = L, p = z) : (y = z, p = L);
    }
    let C2 = b(l).mul(b(1).add(i)).toFixed(0, decimal_default.ROUND_DOWN).toString(), v = b(d).mul(b(1).add(i)).toFixed(0, decimal_default.ROUND_DOWN).toString(), B2 = f ? l : d;
    h === "oneSide" && a ? (C2 = "18446744073709551615", v = "18446744073709551615", a.a2b ? (B2 = b(B2).mul(b(1).sub(1e-3)).toFixed(0, decimal_default.ROUND_DOWN).toString(), y = y || R.buildCoinWithBalance(BigInt(f ? l : u.amount_limit_a), w2.coinTypeA, t)) : p = p || R.buildCoinWithBalance(BigInt(f ? u.amount_limit_b : u.amount_b), w2.coinTypeB, t)) : (y = r2 || R.buildCoinWithBalance(BigInt(f ? l : C2), w2.coinTypeA, t), p = s || R.buildCoinWithBalance(BigInt(f ? v : d), w2.coinTypeB, t));
    let j2 = await this.depositInternal({ coinTypeA: w2.coinTypeA, coinTypeB: w2.coinTypeB, lp_token_type: g.lp_token_type, farming_pool: g.position.pool_id, clmm_pool: w2.poolAddress, primaryCoinAInputs: y, primaryCoinBInputs: p, vault_id: n, slippage: e.slippage, amount_a: f ? B2 : C2, amount_b: f ? v : B2, fix_amount_a: f, return_lp_token: c }, t);
    if (a && A && t.transferObjects([A], t.pure.address(this._sdk.getVerifySenderAddress())), c) return j2;
  }
  async handleDepositSwap(e, t) {
    let { partner: n, coinTypeA: i, coinTypeB: r2, slippage: s, clmm_pool_address: c, swap_in_amount: u, a2b: a, sui_stake_protocol: l, route_obj: d, swap_in_coin: f } = e, { clmm_pool: _, integrate: h } = this._sdk.sdkOptions, m = f;
    if (l !== "Cetus") return { swap_out_coin: this.requestStakeCoin(l, t, m) };
    if (d) {
      let C2 = { routers: d, inputCoin: m, slippage: s, txb: t, partner: n }, { aggregator: v } = this._sdk.sdkOptions, B2 = `${v.walletAddress}_getAggregatorClient`, j2 = this.getCache(B2, false), D;
      if (j2 !== void 0) D = j2;
      else {
        let L = new SuiClient({ url: this.sdk.sdkOptions.fullRpcUrl });
        D = new AggregatorClient23({ endpoint: v.endPoint, signer: v.walletAddress, client: L, env: v.env, pythUrls: v.pythUrls });
      }
      return { swap_out_coin: await D.fixableRouterSwap(C2) };
    }
    let g = R.buildCoinWithBalance(BigInt(0), a ? e.coinTypeB : e.coinTypeA, t), w2 = ne2.getDefaultSqrtPriceLimit(a).toString(), y = t.moveCall({ target: `${h.published_at}::${Je}::swap`, typeArguments: [i, r2], arguments: [t.object(U2(_).global_config_id), t.object(c), a ? m : g, a ? g : m, t.pure.bool(a), t.pure.bool(true), t.pure.u64(u), t.pure.u128(w2), t.pure.bool(false), t.object(we2)] }), p = a ? y[1] : y[0], A = a ? y[0] : y[1];
    return t.transferObjects([A], t.pure.address(this._sdk.getVerifySenderAddress())), { swap_out_coin: p };
  }
  requestStakeCoin(e, t, n) {
    if (e === "Haedal") return ye2.requestStakeCoin(this._sdk, t, n);
    if (e === "Volo") return Ae.requestStakeCoin(this._sdk, t, n);
    if (e === "aftermath") return ve2.requestStakeCoin(this._sdk, t, n);
  }
  async depositInternal(e, t) {
    var _a7, _b3;
    let { vaults: n, frams: i, clmm_pool: r2 } = this._sdk.sdkOptions, s = U2(n), c = U2(i), u = U2(r2), { primaryCoinAInputs: a, primaryCoinBInputs: l } = e;
    if (a === void 0 || l === void 0) {
      let _ = await this._sdk.getOwnerCoinAssets(this._sdk.senderAddress);
      a = (_a7 = oe.buildAddLiquidityFixTokenCoinInput(t, !e.fix_amount_a, e.amount_a, e.slippage, e.coinTypeA, _, false)) == null ? void 0 : _a7.targetCoin, l = (_b3 = oe.buildAddLiquidityFixTokenCoinInput(t, e.fix_amount_a, e.amount_b, e.slippage, e.coinTypeB, _, false)) == null ? void 0 : _b3.targetCoin;
    }
    let d = [t.object(s.vaults_manager_id), t.object(e.vault_id), t.object(c.rewarder_manager_id), t.object(c.global_config_id), t.object(e.farming_pool), t.object(u.global_config_id), t.object(e.clmm_pool), a, l, t.pure.u64(e.amount_a), t.pure.u64(e.amount_b), t.pure.bool(e.fix_amount_a), t.object(we2)], f = [e.coinTypeA, e.coinTypeB, e.lp_token_type];
    if (e.return_lp_token) return t.moveCall({ target: `${n.published_at}::${Xe2}::deposit`, typeArguments: f, arguments: d });
    t.moveCall({ target: `${n.published_at}::${Ot2}::deposit`, typeArguments: f, arguments: d });
  }
  async withdraw(e, t) {
    var _a7;
    let n = "is_ft_input" in e, { vault: i, pool: r2 } = await this.getVaultAndPool(e.vault_id, true), s = (_a7 = e.return_coin) != null ? _a7 : false, c, u, a, l;
    if (n) l = await this._sdk.Vaults.calculateWithdrawAmount(__spreadProps(__spreadValues({}, e), { side: "oneSide" })), u = l.amount_limit_a, a = l.amount_limit_b, c = e.is_ft_input ? e.input_amount : l.burn_ft_amount;
    else {
      let { vault_id: _, ft_amount: h, slippage: m } = e;
      c = h;
      let g = await this.estLiquidityAmountFromFtAmount({ vault_id: _, input_ft_amount: h, slippage: m });
      u = g.amount_limit_a, a = g.amount_limit_b;
    }
    let { reciveCoinA: d, reciveCoinB: f } = await this.withdrawInternal({ coinTypeA: r2.coinTypeA, coinTypeB: r2.coinTypeB, lp_token_type: i.lp_token_type, farming_pool: i.position.pool_id, clmm_pool: r2.poolAddress, min_amount_a: u, min_amount_b: a, vault_id: e.vault_id, ft_amount: c }, t);
    if (n && l) {
      let { a2b: _, swap_in_amount: h, route_obj: m } = l.swap_result;
      if (m) {
        let g = { targetCoin: _ ? d : f, remainCoins: [], isMintZeroCoin: false, tragetCoinAmount: "" }, w2 = { routers: m, inputCoin: g.targetCoin, slippage: e.slippage, txb: t, partner: e.partner }, { aggregator: y } = this._sdk.sdkOptions, p = `${y.walletAddress}_getAggregatorClient`, A = this.getCache(p, false), C2;
        if (A !== void 0) C2 = A;
        else {
          let j2 = new SuiClient({ url: this.sdk.sdkOptions.fullRpcUrl });
          C2 = new AggregatorClient23({ endpoint: y.endPoint, signer: y.walletAddress, client: j2, env: y.env, pythUrls: y.pythUrls });
        }
        let v = await C2.fixableRouterSwap(w2), B2 = _ ? [g.targetCoin, v] : [v, g.targetCoin];
        if (_ ? t.mergeCoins(B2[1], [f]) : t.mergeCoins(B2[0], [d]), s) return { return_coin_a: _ ? void 0 : v, return_coin_b: _ ? v : void 0 };
        t.transferObjects([v], t.pure.address(this._sdk.getVerifySenderAddress()));
      } else {
        let { clmm_pool: g, integrate: w2 } = this._sdk.sdkOptions, y = ne2.getDefaultSqrtPriceLimit(_).toString(), p = t.moveCall({ target: `${w2.published_at}::${Je}::swap`, typeArguments: [r2.coinTypeA, r2.coinTypeB], arguments: [t.object(U2(g).global_config_id), t.object(r2.poolAddress), d, f, t.pure.bool(_), t.pure.bool(true), t.pure.u64(h), t.pure.u128(y), t.pure.bool(true), t.object(we2)] });
        if (s) return { return_coin_a: p[0], return_coin_b: p[1] };
        t.transferObjects([p[0], p[1]], t.pure.address(this._sdk.senderAddress));
      }
    } else {
      if (s) return { return_coin_a: d, return_coin_b: f };
      t.transferObjects([d, f], t.pure.address(this._sdk.senderAddress));
    }
    return {};
  }
  async withdrawInternal(e, t) {
    let { vaults: n, frams: i, clmm_pool: r2 } = this._sdk.sdkOptions, s = U2(n), c = U2(i), u = U2(r2), { primaryCoinInputs: a } = e;
    if (a === void 0) {
      let f = await this._sdk.getOwnerCoinAssets(this._sdk.senderAddress, e.lp_token_type);
      a = oe.buildCoinForAmount(t, f, BigInt(e.ft_amount), e.lp_token_type, false, true).targetCoin;
    }
    let l = [e.coinTypeA, e.coinTypeB, e.lp_token_type], d = t.moveCall({ target: `${n.published_at}::${Xe2}::remove`, typeArguments: l, arguments: [t.object(s.vaults_manager_id), t.object(e.vault_id), t.object(c.rewarder_manager_id), t.object(c.global_config_id), t.object(e.farming_pool), t.object(u.global_config_id), t.object(e.clmm_pool), a, t.pure.u64(e.ft_amount), t.pure.u64(e.min_amount_a), t.pure.u64(e.min_amount_b), t.object(we2)] });
    return t.transferObjects([a], t.pure.address(this._sdk.senderAddress)), { reciveCoinA: d[0], reciveCoinB: d[1] };
  }
  async getVaultAndPool(e, t = false) {
    let n = await this.sdk.Vaults.getVault(e);
    if (n === void 0) throw new Error("please check config and vault id");
    let i = await this._sdk.Pool.getPool(n.pool_id, t);
    return { vault: n, pool: i };
  }
  async getVaultList(e = "all") {
    let { vaults_pool_handle: t } = U2(this._sdk.sdkOptions.vaults), n = await this._sdk.fullClient.getDynamicFields({ parentId: t }), i = n.data.map((c) => c.name.value), r2 = await this._sdk.fullClient.batchGetObjects(i, { showType: true, showContent: true, showDisplay: true, showOwner: true }), s = [];
    return r2.forEach((c) => {
      let u = R.buildPool(c);
      u && (u.stake_protocol = this.findStakeProtocol(u.position.coinTypeA, u.position.coinTypeB), this.savePoolToCache(u), s.push(u));
    }), n.data = s, n;
  }
  findStakeProtocol(e, t) {
    let { haedal: n, volo: i, aftermath: r2 } = U2(this._sdk.sdkOptions.vaults), s = P3(e).full_address, c = P3(t).full_address;
    if (I.isSuiCoin(s) || I.isSuiCoin(c)) {
      if (n) {
        let u = P3(U2(n).coin_type).full_address;
        if (s === u || c === u) return "Haedal";
      }
      if (i) {
        let u = P3(U2(i).coin_type).full_address;
        if (s === u || c === u) return "Volo";
      }
      if (r2) {
        let u = P3(U2(r2).coin_type).full_address;
        if (s === u || c === u) return "aftermath";
      }
    }
  }
  async getVault(e, t = false) {
    let n = this.readPoolFromCache(e, t);
    if (n) return n;
    try {
      let i = await this._sdk.fullClient.getObject({ id: e, options: { showType: true, showContent: true, showDisplay: true, showOwner: true } }), r2 = R.buildPool(i);
      if (r2) return this.savePoolToCache(r2), r2;
    } catch (i) {
      console.log(i);
    }
  }
  savePoolToCache(e) {
    let t = `${e.id}_mirrorPool`;
    this.updateCache(t, e, te);
  }
  readPoolFromCache(e, t = false) {
    let n = `${e}_mirrorPool`;
    return this.getCache(n, t);
  }
  findSuiStakeProtocol(e, t, n) {
    let { haedal: i, volo: r2, aftermath: s } = U2(this._sdk.sdkOptions.vaults), c = P3(e).full_address, u = P3(t).full_address;
    if (I.isSuiCoin(c) && n || I.isSuiCoin(u) && !n) {
      if (i) {
        let a = P3(U2(i).coin_type).full_address;
        if (c === a || u === a) return "Haedal";
      }
      if (r2) {
        let a = P3(U2(r2).coin_type).full_address;
        if (c === a || u === a) return "Volo";
      }
      if (s) {
        let a = P3(U2(s).coin_type).full_address;
        if (c === a || u === a) return "aftermath";
      }
    }
    return "Cetus";
  }
  buildCoinInput(e, t, n, i, r2) {
    let { selectedCoins: s, remainingCoins: c } = I.selectCoinAssetGreaterThanOrEqual(t, BigInt(i)), u = I.calculateTotalBalance(s);
    if (u < BigInt(i)) throw new Error(`The amount(${u}) is Insufficient balance for ${n} , expect ${i} `);
    let a = u - BigInt(i), l;
    if (I.isSuiCoin(n)) l = e.splitCoins(e.gas, [e.pure.u64(i)]);
    else {
      let [d, ...f] = s.map((_) => _.coinObjectId);
      l = e.object(d), f.length > 0 ? r2 ? e.mergeCoins(l, [...f.map((_) => e.object(_)), r2]) : e.mergeCoins(l, [...f.map((_) => e.object(_))]) : r2 && e.mergeCoins(l, [r2]);
    }
    return { selectedUnusedAmount: a, coinInput: l, remainingCoins: c };
  }
  async getVaultsConfigs(e = false) {
    let { package_id: t } = this._sdk.sdkOptions.vaults, n = `${t}_getMirrorPoolConfigs`, i = this.getCache(n, e);
    if (i !== void 0) return i;
    let r2 = (await this._sdk.fullClient.queryEventsByPage({ MoveEventType: `${t}::vaults::InitEvent` })).data, s = { admin_cap_id: "", vaults_manager_id: "", vaults_pool_handle: "" };
    if (r2.length > 0) {
      for (let c of r2) {
        let u = c.parsedJson;
        s.admin_cap_id = u.admin_cap_id, s.vaults_manager_id = u.manager_id;
        let a = await this._sdk.fullClient.getObject({ id: s.vaults_manager_id, options: { showContent: true } }), l = ae2(a);
        s.vaults_pool_handle = l.vault_to_pool_maps.fields.id.id;
        break;
      }
      this.updateCache(n, s, te);
    }
    return s;
  }
  updateCache(e, t, n = te) {
    let i = this._cache[e];
    i ? (i.overdueTime = ie2(n), i.value = t) : i = new me(t, ie2(n)), this._cache[e] = i;
  }
  getCache(e, t = false) {
    let n = this._cache[e];
    if (!t && (n == null ? void 0 : n.isValid())) return n.value;
    delete this._cache[e];
  }
};
var De2 = class {
  constructor(e) {
    __publicField(this, "_sdk");
    __publicField(this, "_cache", {});
    this._sdk = e;
  }
  get sdk() {
    return this._sdk;
  }
  async getPoolImmutables(e = [], t = 0, n = 100, i = false) {
    let { package_id: r2 } = this._sdk.sdkOptions.clmm_pool, s = `${r2}_getInitPoolEvent`, c = this.getCache(s, i), u = [], a = [];
    if (c !== void 0 && u.push(...c), u.length === 0) try {
      (await this._sdk.fullClient.queryEventsByPage({ MoveEventType: `${r2}::factory::CreatePoolEvent` })).data.forEach((f) => {
        let _ = f.parsedJson;
        _ && u.push({ poolAddress: _.pool_id, tickSpacing: _.tick_spacing, coinTypeA: P3(_.coin_type_a).full_address, coinTypeB: P3(_.coin_type_b).full_address });
      }), this.updateCache(s, u, te);
    } catch (d) {
      console.log("getPoolImmutables", d);
    }
    let l = e.length > 0;
    for (let d = 0; d < u.length; d += 1) {
      let f = u[d];
      l && !e.includes(f.poolAddress) || !l && (d < t || d >= t + n) || a.push(f);
    }
    return a;
  }
  async getPools(e = [], t = 0, n = 100) {
    var _a7, _b3, _c, _d;
    let i = [], r2 = [];
    e.length > 0 ? r2 = [...e] : (await this.getPoolImmutables([], t, n, false)).forEach((u) => r2.push(u.poolAddress));
    let s = await this._sdk.fullClient.batchGetObjects(r2, { showContent: true, showType: true });
    for (let c of s) {
      if (c.error != null || ((_b3 = (_a7 = c.data) == null ? void 0 : _a7.content) == null ? void 0 : _b3.dataType) !== "moveObject") throw new Q(`getPools error code: ${(_d = (_c = c.error) == null ? void 0 : _c.code) != null ? _d : "unknown error"}, please check config and object ids`, "InvalidPoolObject");
      let u = We2(c);
      i.push(u);
      let a = `${u.poolAddress}_getPoolObject`;
      this.updateCache(a, u, te);
    }
    return i;
  }
  async getPool(e, t = true) {
    var _a7, _b3, _c, _d;
    let n = `${e}_getPoolObject`, i = this.getCache(n, t);
    if (i !== void 0) return i;
    let r2 = await this._sdk.fullClient.getObject({ id: e, options: { showType: true, showContent: true } });
    if (r2.error != null || ((_b3 = (_a7 = r2.data) == null ? void 0 : _a7.content) == null ? void 0 : _b3.dataType) !== "moveObject") throw new Q(`getPool error code: ${(_d = (_c = r2.error) == null ? void 0 : _c.code) != null ? _d : "unknown error"}, please check config and object id`, "InvalidPoolObject");
    let s = We2(r2);
    return this.updateCache(n, s), s;
  }
  async getSuiTransactionResponse(e, t = false) {
    let n = `${e}_getSuiTransactionResponse`, i = this.getCache(n, t);
    if (i !== void 0) return i;
    let r2;
    try {
      r2 = await this._sdk.fullClient.getTransactionBlock({ digest: e, options: { showEvents: true, showEffects: true, showBalanceChanges: true, showInput: true, showObjectChanges: true } });
    } catch (e2) {
      r2 = await this._sdk.fullClient.getTransactionBlock({ digest: e, options: { showEvents: true, showEffects: true } });
    }
    return this.updateCache(n, r2, te), r2;
  }
  updateCache(e, t, n = At2) {
    let i = this._cache[e];
    i ? (i.overdueTime = ie2(n), i.value = t) : i = new me(t, ie2(n)), this._cache[e] = i;
  }
  getCache(e, t = false) {
    let n = this._cache[e], i = n == null ? void 0 : n.isValid();
    if (!t && i) return n.value;
    i || delete this._cache[e];
  }
};
var Fe2 = class extends SuiClient {
  async queryEventsByPage(e, t = "all") {
    let n = [], i = true, r2 = t === "all", s = r2 ? null : t.cursor;
    do {
      let c = await this.queryEvents({ query: e, cursor: s, limit: r2 ? null : t.limit });
      c.data ? (n = [...n, ...c.data], i = c.hasNextPage, s = c.nextCursor) : i = false;
    } while (r2 && i);
    return { data: n, nextCursor: s, hasNextPage: i };
  }
  async getOwnedObjectsByPage(e, t, n = "all") {
    let i = [], r2 = true, s = n === "all", c = s ? null : n.cursor;
    do {
      let u = await this.getOwnedObjects(__spreadProps(__spreadValues({ owner: e }, t), { cursor: c, limit: s ? null : n.limit }));
      u.data ? (i = [...i, ...u.data], r2 = u.hasNextPage, c = u.nextCursor) : r2 = false;
    } while (s && r2);
    return { data: i, nextCursor: c, hasNextPage: r2 };
  }
  async getDynamicFieldsByPage(e, t = "all") {
    let n = [], i = true, r2 = t === "all", s = r2 ? null : t.cursor;
    do {
      let c = await this.getDynamicFields({ parentId: e, cursor: s, limit: r2 ? null : t.limit });
      c.data ? (n = [...n, ...c.data], i = c.hasNextPage, s = c.nextCursor) : i = false;
    } while (r2 && i);
    return { data: n, nextCursor: s, hasNextPage: i };
  }
  async batchGetObjects(e, t, n = 50) {
    let i = [];
    try {
      for (let r2 = 0; r2 < Math.ceil(e.length / n); r2++) {
        let s = await this.multiGetObjects({ ids: e.slice(r2 * n, n * (r2 + 1)), options: t });
        i = [...i, ...s];
      }
    } catch (r2) {
      console.log(r2);
    }
    return i;
  }
  async calculationTxGas(e) {
    let { sender: t } = e.blockData;
    if (t === void 0) throw Error("sdk sender is empty");
    let n = await this.devInspectTransactionBlock({ transactionBlock: e, sender: t }), { gasUsed: i } = n.effects;
    return Number(i.computationCost) + Number(i.storageCost) - Number(i.storageRebate);
  }
  async sendTransaction(e, t) {
    try {
      return await this.signAndExecuteTransaction({ transaction: t, signer: e, options: { showEffects: true, showEvents: true } });
    } catch (n) {
      console.log("error: ", n);
    }
  }
  async sendSimulationTransaction(e, t, n = true) {
    try {
      if (n) return await this.devInspectTransactionBlock({ transactionBlock: e, sender: t });
    } catch (i) {
      console.log("devInspectTransactionBlock error", i);
    }
  }
};
var ce = class {
  constructor(e) {
    __publicField(this, "_cache", {});
    __publicField(this, "_rpcModule");
    __publicField(this, "_vaults");
    __publicField(this, "_sdkOptions");
    __publicField(this, "_senderAddress", "");
    __publicField(this, "_pool");
    this._sdkOptions = e, this._rpcModule = new Fe2({ url: e.fullRpcUrl }), this._vaults = new qe(this), this._pool = new De2(this), Ke(this._sdkOptions);
  }
  get senderAddress() {
    return this._senderAddress;
  }
  set senderAddress(e) {
    this._senderAddress = e;
  }
  get fullClient() {
    return this._rpcModule;
  }
  get sdkOptions() {
    return this._sdkOptions;
  }
  get Vaults() {
    return this._vaults;
  }
  get Pool() {
    return this._pool;
  }
  getVerifySenderAddress() {
    if (this.senderAddress.length === 0 || !isValidSuiAddress(this.senderAddress)) throw Error("this clmm config sdk senderAdders is illegal");
    return this.senderAddress;
  }
  async getOwnerCoinAssets(e, t, n = true) {
    let i = [], r2 = null, s = `${this.sdkOptions.fullRpcUrl}_${e}_${t}_getOwnerCoinAssets`, c = this.getCache(s, n);
    if (c) return c;
    for (; ; ) {
      let u = await (t ? this.fullClient.getCoins({ owner: e, coinType: t, cursor: r2 }) : this.fullClient.getAllCoins({ owner: e, cursor: r2 }));
      if (u.data.forEach((a) => {
        BigInt(a.balance) > 0 && i.push({ coinAddress: P3(a.coinType).source_address, coinObjectId: a.coinObjectId, balance: BigInt(a.balance) });
      }), r2 = u.nextCursor, !u.hasNextPage) break;
    }
    return this.updateCache(s, i, 30 * 1e3), i;
  }
  async getOwnerCoinBalances(e, t) {
    let n = [];
    return t ? n = [await this.fullClient.getBalance({ owner: e, coinType: t })] : n = [...await this.fullClient.getAllBalances({ owner: e })], n;
  }
  updateCache(e, t, n = te) {
    let i = this._cache[e];
    i ? (i.overdueTime = ie2(n), i.value = t) : i = new me(t, ie2(n)), this._cache[e] = i;
  }
  getCache(e, t = false) {
    let n = this._cache[e], i = n == null ? void 0 : n.isValid();
    if (!t && i) return n.value;
    i || delete this._cache[e];
  }
};
var Ye2 = { clmmConfig: { pools_id: "0xf699e7f2276f5c9a75944b37a0c5b5d9ddfd2471bf6242483b03ab2887d198d0", admin_cap_id: "0x89c1a321291d15ddae5a086c9abc533dff697fde3d89e0ca836c41af73e36a75", global_config_id: "0xdaa46292632c3c4d8f31f23ea0f9b36a28ff3677e9684980e4438403a67a3d8f", global_vault_id: "0xce7bceef26d3ad1f6d9b6f13a953f053e6ed3ca77907516481ce99ae8e588f2b" }, framsConfig: { global_config_id: "0x21215f2f6de04b57dd87d9be7bb4e15499aec935e36078e2488f36436d64996e", rewarder_manager_id: "0xe0e155a88c77025056da08db5b1701a91b79edb6167462f768e387c3ed6614d5", rewarder_manager_handle: "0xb32e312cbb3367d6f3d2b4e57c9225e903d29b7b9f612dae2ddf75bdeb26a5aa", admin_cap_id: "0xf10fbf1fea5b7aeaa524b87769461a28c5c977613046360093673991f26d886c" }, vaultConfig: { admin_cap_id: "0x78a42978709c4032fab7b33b782b5bcef64c1c6603250bf23644650b72144375", vaults_manager_id: "0x25b82dd2f5ee486ed1c8af144b89a8931cd9c29dee3a86a1bfe194fdea9d04a6", vaults_pool_handle: "0x9036bcc5aa7fd2cceec1659a6a1082871f45bc400c743f50063363457d1738bd", haedal: { package_id: "0xbde4ba4c2e274a60ce15c1cfff9e5c42e41654ac8b6d906a57efa4bd3c29f47d", published_at: "0xaabf0856070391df81fad9240049d69c5a51c3d376cc0885eeedd516526cc79b", version: 1, config: { staking_id: "0x47b224762220393057ebf4f70501b6e657c3e56684737568439a04f80849b2ca", coin_type: "0xbde4ba4c2e274a60ce15c1cfff9e5c42e41654ac8b6d906a57efa4bd3c29f47d::hasui::HASUI" } }, volo: { package_id: "0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55", published_at: "0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55", version: 1, config: { native_pool: "0x7fa2faa111b8c65bea48a23049bfd81ca8f971a262d981dcd9a17c3825cb5baf", vsui_metadata: "0x680cd26af32b2bde8d3361e804c53ec1d1cfe24c7f039eb7f549e8dfde389a60", coin_type: "0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55::cert::CERT" } }, aftermath: { package_id: "0x7f6ce7ade63857c4fd16ef7783fed2dfc4d7fb7e40615abdb653030b76aef0c6", published_at: "0x7f6ce7ade63857c4fd16ef7783fed2dfc4d7fb7e40615abdb653030b76aef0c6", version: 1, config: { staked_sui_vault: "0x2f8f6d5da7f13ea37daa397724280483ed062769813b6f31e9788e59cc88994d", referral_vault: "0x4ce9a19b594599536c53edb25d22532f82f18038dc8ef618afd00fbbfb9845ef", safe: "0xeb685899830dd5837b47007809c76d91a098d52aabbf61e8ac467c59e5cc4610", validator_address: "0xd30018ec3f5ff1a3c75656abf927a87d7f0529e6dc89c7ddd1bd27ecb05e3db2", coin_type: "0xf325ce1300e8dac124071d3152c5c5ee6174914f8bc2161e88329cf579246efc::afsui::AFSUI" } } } };
var et2 = { fullRpcUrl: getFullnodeUrl("mainnet"), simulationAccount: { address: "0x0000000000000000000000000000000000000000000000000000000000000000" }, clmm_pool: { package_id: "0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb", published_at: "0x70968826ad1b4ba895753f634b0aea68d0672908ca1075a2abdf0fc9e0b2fc6a", version: 4, config: Ye2.clmmConfig }, integrate: { package_id: "0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3", published_at: "0x2d8c2e0fc6dd25b0214b3fa747e0fd27fd54608142cd2e4f64c1cd350cc4add4", version: 2 }, vaults: { package_id: "0xd3453d9be7e35efe222f78a810bb3af1859fd1600926afced8b4936d825c9a05", published_at: "0x1ed1fef522ccea98a4fbd954543d5019238ec89282fbdea9a753e0a17e96fc28", version: 1, config: Ye2.vaultConfig }, frams: { package_id: "0x11ea791d82b5742cc8cab0bf7946035c97d9001d7c3803a93f119753da66f526", published_at: "0x11ea791d82b5742cc8cab0bf7946035c97d9001d7c3803a93f119753da66f526", version: 1, config: Ye2.framsConfig }, aggregator: { endPoint: "https://api-sui-cloudfront.cetus.zone/router_v2/find_routes", fullNodeurl: "https://fullnode.mainnet.sui.io:443", walletAddress: "0xfba94aa36e93ccc7d84a6a57040fc51983223f1b522a8d0be3c3bf2c98977ebb", env: Env.Mainnet, providers: ["CETUS", "DEEPBOOK", "KRIYA", "KRIYAV3", "FLOWX", "FLOWXV3", "AFTERMATH", "HAEDAL", "VOLO", "AFSUI"], pythUrls: [] } };
function Lt2(o, e) {
  return o && (et2.fullRpcUrl = o), e && (et2.simulationAccount.address = e), new ce(et2);
}
var Mt = ce;
var tt = { clmmConfig: { pools_id: "0x50eb61dd5928cec5ea04711a2e9b72e5237e79e9fbcd2ce3d5469dc8708e0ee2", global_config_id: "0x9774e359588ead122af1c7e7f64e14ade261cfeecdb5d0eb4a5b3b4c8ab8bd3e", global_vault_id: "0xf78d2ee3c312f298882cb680695e5e8c81b1d441a646caccc058006c2851ddea", admin_cap_id: "0xd0accadc3d0b27f0cfaebe8e546968ac7874b9a9f5964669b4c9a7e1dcf80a28" }, vaultConfig: { admin_cap_id: "0x78a42978709c4032fab7b33b782b5bcef64c1c6603250bf23644650b72144375", vaults_manager_id: "0x25b82dd2f5ee486ed1c8af144b89a8931cd9c29dee3a86a1bfe194fdea9d04a6", vaults_pool_handle: "0x9036bcc5aa7fd2cceec1659a6a1082871f45bc400c743f50063363457d1738bd", haedal: { package_id: "0xac2afb455cbcdc2ff1a2e9bbb8aa4ccb4506a544b08c740886892a5cdf92f472", published_at: "0x9dac9c5770e5f930d2223ff68782958701acfaee9337e8d8363978ce7670dffb", version: 1, config: { staking_id: "0x6e384d2da5b040b27f973155e25bbe4beb0ad5ca8ee0a36e20dff356094c9fc0", coin_type: "0xac2afb455cbcdc2ff1a2e9bbb8aa4ccb4506a544b08c740886892a5cdf92f472::hasui::HASUI" } }, aftermath: { package_id: "0x5e8c0fc2b3d8aa1b06eec36c08d9d835c73c0626a1efaebc0fb03aa52f1a3ff4", published_at: "0x5e8c0fc2b3d8aa1b06eec36c08d9d835c73c0626a1efaebc0fb03aa52f1a3ff4", version: 1, config: { staked_sui_vault: "0xe498a8c07ec62200c519a0092eda233abdab879e8f332c11bdc1819eb7b12fbb", referral_vault: "0x8d357115058f22976cd01c5415116d9aca806d1ded37eecd75d87978f404e927", safe: "0x38710a6e0bd885c158e52ec7a42c8a9a1826c6696b626b4a5e2d1dcb15cfd9b7", validator_address: "0x9336c4c9d891e263cfac99adc397853a7392e5cf84cbd5df92207a57c7fbdadc", coin_type: "0x5e8c0fc2b3d8aa1b06eec36c08d9d835c73c0626a1efaebc0fb03aa52f1a3ff4::afsui::AFSUI" } } }, framsConfig: { global_config_id: "0x499132a4baf342a0fe9528a3666a77b2aece3be129f4a3ada469fef4b9c34fb4", rewarder_manager_id: "0x960c7800e301fd1e47b79037927b426db57b643bd2934f7069d81c2dae092230", rewarder_manager_handle: "0x1274149371876b60742cd02071a09f2aa72ffee75b76fdfc45724d98f18ea5b5", admin_cap_id: "0x110175e641c1ea8f9287f4fd59cb6a1fb97a3f3ec595aa30d0e6ed93ac4caa0c" } };
var nt = { fullRpcUrl: getFullnodeUrl("testnet"), simulationAccount: { address: "0x0000000000000000000000000000000000000000000000000000000000000000" }, clmm_pool: { package_id: "0x0c7ae833c220aa73a3643a0d508afa4ac5d50d97312ea4584e35f9eb21b9df12", published_at: "0x0c7ae833c220aa73a3643a0d508afa4ac5d50d97312ea4584e35f9eb21b9df12", version: 6, config: tt.clmmConfig }, integrate: { package_id: "0x2918cf39850de6d5d94d8196dc878c8c722cd79db659318e00bff57fbb4e2ede", published_at: "0x2918cf39850de6d5d94d8196dc878c8c722cd79db659318e00bff57fbb4e2ede", version: 6 }, vaults: { package_id: "0x325b7d67276ff809df6b3fa17a2a6fbff6aaa20e467c3cf74d1a1d09b8890bbd", published_at: "0x325b7d67276ff809df6b3fa17a2a6fbff6aaa20e467c3cf74d1a1d09b8890bbd", version: 1, config: tt.vaultConfig }, frams: { package_id: "0xcc38686ca84d1dca949b6966dcdb66b698b58a4bba247d8db4d6a3a1dbeca26e", published_at: "0xcc38686ca84d1dca949b6966dcdb66b698b58a4bba247d8db4d6a3a1dbeca26e", version: 1, config: tt.framsConfig }, aggregator: { endPoint: "https://api-sui-cloudfront.cetus.zone/router_v2/find_routes", fullNodeurl: "https://fullnode.mainnet.sui.io:443", walletAddress: "0xfba94aa36e93ccc7d84a6a57040fc51983223f1b522a8d0be3c3bf2c98977ebb", env: Env.Mainnet, providers: ["CETUS", "DEEPBOOK", "KRIYA", "KRIYAV3", "FLOWX", "FLOWXV3", "AFTERMATH", "TURBOS", "HAEDAL", "VOLO", "AFSUI"], pythUrls: [] } };
function $t2(o, e) {
  return o && (nt.fullRpcUrl = o), e && (nt.simulationAccount.address = e), new Mt(nt);
}
function Ma2(o) {
  let { network: e, fullNodeUrl: t, simulationAccount: n } = o;
  return e === "mainnet" ? Lt2(t, n) : $t2(t, n);
}

// src/lib/txHelper/coin.ts
var getCoinValue = (tx, coin, coinType, debug = false) => {
  const moveCallInfo = {
    target: `0x2::coin::value`,
    arguments: [{ name: "coin", value: coin }],
    typeArguments: [coinType]
  };
  const coinValue = tx.moveCall({
    target: moveCallInfo.target,
    arguments: [coin],
    typeArguments: moveCallInfo.typeArguments
  });
  return debug ? [coinValue, moveCallInfo] : coinValue;
};
var burnSCoin = async ({
  tx,
  sCoin,
  amount,
  address,
  vaultId,
  slippage,
  coinConfig,
  debug = false
}) => {
  var _a7, _b3;
  const moveCallInfos = [];
  let underlyingCoin;
  switch (coinConfig.underlyingProtocol) {
    case "Scallop": {
      const treasury = getTreasury(coinConfig.coinType);
      const burnSCoinMoveCall = {
        target: `0x80ca577876dec91ae6d22090e56c39bc60dce9086ab0729930c6900bc4162b4c::s_coin_converter::burn_s_coin`,
        arguments: [
          { name: "treasury", value: treasury },
          { name: "s_coin", value: "sCoin" }
        ],
        typeArguments: [coinConfig.coinType, coinConfig.underlyingCoinType]
      };
      moveCallInfos.push(burnSCoinMoveCall);
      const [marketCoin] = tx.moveCall({
        target: burnSCoinMoveCall.target,
        arguments: [tx.object(treasury), sCoin],
        typeArguments: burnSCoinMoveCall.typeArguments
      });
      const redeemMoveCall = {
        target: `0x83bbe0b3985c5e3857803e2678899b03f3c4a31be75006ab03faf268c014ce41::redeem::redeem`,
        arguments: [
          { name: "version", value: SCALLOP.VERSION_OBJECT },
          { name: "market", value: SCALLOP.MARKET_OBJECT },
          { name: "market_coin", value: "marketCoin" },
          { name: "clock", value: "0x6" }
        ],
        typeArguments: [coinConfig.underlyingCoinType]
      };
      moveCallInfos.push(redeemMoveCall);
      const [coin] = tx.moveCall({
        target: redeemMoveCall.target,
        arguments: [
          tx.object(SCALLOP.VERSION_OBJECT),
          tx.object(SCALLOP.MARKET_OBJECT),
          marketCoin,
          tx.object("0x6")
        ],
        typeArguments: redeemMoveCall.typeArguments
      });
      underlyingCoin = coin;
      break;
    }
    case "Haedal": {
      if (coinConfig.coinType === "0x8b4d553839b219c3fd47608a0cc3d5fcc572cb25d41b7df3833208586a8d2470::hawal::HAWAL") {
        throw new Error("Underlying protocol error, try to withdraw to HAWAL.");
      } else {
        const unstakeMoveCall = {
          target: `0x3f45767c1aa95b25422f675800f02d8a813ec793a00b60667d071a77ba7178a2::staking::request_unstake_instant_coin`,
          arguments: [
            { name: "sui_system_state", value: "0x5" },
            { name: "staking", value: HAEDAL.HAEDAL_STAKING_ID },
            { name: "s_coin", value: "sCoin" }
          ],
          typeArguments: []
        };
        moveCallInfos.push(unstakeMoveCall);
        const [coin] = tx.moveCall({
          target: unstakeMoveCall.target,
          arguments: [
            tx.object("0x5"),
            tx.object(HAEDAL.HAEDAL_STAKING_ID),
            sCoin
          ],
          typeArguments: unstakeMoveCall.typeArguments
        });
        underlyingCoin = coin;
      }
      break;
    }
    case "Strater": {
      const toBalanceMoveCall = {
        target: `0x2::coin::into_balance`,
        arguments: [{ name: "coin", value: "sCoin" }],
        typeArguments: [coinConfig.coinType]
      };
      moveCallInfos.push(toBalanceMoveCall);
      const [sbsBalance] = tx.moveCall({
        target: toBalanceMoveCall.target,
        arguments: [sCoin],
        typeArguments: toBalanceMoveCall.typeArguments
      });
      const withdrawMoveCall = {
        target: `0x2a721777dc1fcf7cda19492ad7c2272ee284214652bde3e9740e2f49c3bff457::vault::withdraw`,
        arguments: [
          {
            name: "bucket_vault",
            value: "0xe83e455a9e99884c086c8c79c13367e7a865de1f953e75bcf3e529cdf03c6224"
          },
          {
            name: "balance",
            value: "sbsBalance"
          },
          { name: "clock", value: "0x6" }
        ],
        typeArguments: [coinConfig.underlyingCoinType, coinConfig.coinType]
      };
      moveCallInfos.push(withdrawMoveCall);
      const [withdrawTicket] = tx.moveCall({
        target: withdrawMoveCall.target,
        arguments: [
          tx.object(
            "0xe83e455a9e99884c086c8c79c13367e7a865de1f953e75bcf3e529cdf03c6224"
          ),
          sbsBalance,
          tx.object("0x6")
        ],
        typeArguments: withdrawMoveCall.typeArguments
      });
      const redeemTicketMoveCall = {
        target: `0x2a721777dc1fcf7cda19492ad7c2272ee284214652bde3e9740e2f49c3bff457::vault::redeem_withdraw_ticket`,
        arguments: [
          {
            name: "bucket_vault",
            value: "0xe83e455a9e99884c086c8c79c13367e7a865de1f953e75bcf3e529cdf03c6224"
          },
          {
            name: "withdraw_ticket",
            value: "withdrawTicket"
          }
        ],
        typeArguments: [coinConfig.underlyingCoinType, coinConfig.coinType]
      };
      moveCallInfos.push(redeemTicketMoveCall);
      const [underlyingBalance] = tx.moveCall({
        target: redeemTicketMoveCall.target,
        arguments: [
          tx.object(
            "0xe83e455a9e99884c086c8c79c13367e7a865de1f953e75bcf3e529cdf03c6224"
          ),
          withdrawTicket
        ],
        typeArguments: redeemTicketMoveCall.typeArguments
      });
      const fromBalanceMoveCall = {
        target: `0x2::coin::from_balance`,
        arguments: [{ name: "balance", value: "underlyingBalance" }],
        typeArguments: [coinConfig.underlyingCoinType]
      };
      moveCallInfos.push(fromBalanceMoveCall);
      const [coin] = tx.moveCall({
        target: fromBalanceMoveCall.target,
        arguments: [underlyingBalance],
        typeArguments: fromBalanceMoveCall.typeArguments
      });
      underlyingCoin = coin;
      break;
    }
    case "AlphaFi": {
      const redeemMoveCall = {
        target: `${ALPAHFI.PACKAGE_ID}::liquid_staking::redeem`,
        arguments: [
          { name: "liquid_staking_info", value: ALPAHFI.LIQUID_STAKING_INFO },
          { name: "coin", value: "sCoin" },
          { name: "sui_system_state", value: "0x5" }
        ],
        typeArguments: [coinConfig.coinType]
      };
      moveCallInfos.push(redeemMoveCall);
      const [coin] = tx.moveCall({
        target: redeemMoveCall.target,
        arguments: [
          tx.object(ALPAHFI.LIQUID_STAKING_INFO),
          sCoin,
          tx.object("0x5")
        ],
        typeArguments: redeemMoveCall.typeArguments
      });
      underlyingCoin = coin;
      break;
    }
    case "Aftermath": {
      const burnMoveCall = {
        target: `0x7f6ce7ade63857c4fd16ef7783fed2dfc4d7fb7e40615abdb653030b76aef0c6::staked_sui_vault::request_unstake_atomic`,
        arguments: [
          { name: "staked_sui_vault", value: AFTERMATH.STAKED_SUI_VAULT },
          { name: "safe", value: AFTERMATH.SAFE },
          { name: "referral_vault", value: AFTERMATH.REFERRAL_VAULT },
          { name: "treasury", value: AFTERMATH.TREASURY },
          { name: "s_coin", value: "sCoin" }
        ],
        typeArguments: []
      };
      moveCallInfos.push(burnMoveCall);
      const [coin] = tx.moveCall({
        target: burnMoveCall.target,
        arguments: [
          tx.object(AFTERMATH.STAKED_SUI_VAULT),
          tx.object(AFTERMATH.SAFE),
          tx.object(AFTERMATH.REFERRAL_VAULT),
          tx.object(AFTERMATH.TREASURY),
          sCoin
        ],
        typeArguments: burnMoveCall.typeArguments
      });
      underlyingCoin = coin;
      break;
    }
    case "Volo": {
      const mintTicketMoveCall = {
        target: `0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55::native_pool::mint_ticket_non_entry`,
        arguments: [
          { name: "native_pool", value: VOLO.NATIVE_POOL },
          { name: "metadata", value: VOLO.METADATA },
          { name: "cert_coin", value: "sCoin" }
        ],
        typeArguments: []
      };
      moveCallInfos.push(mintTicketMoveCall);
      const [unstakeTicket] = tx.moveCall({
        target: mintTicketMoveCall.target,
        arguments: [
          tx.object(VOLO.NATIVE_POOL),
          tx.object(VOLO.METADATA),
          sCoin
        ],
        typeArguments: mintTicketMoveCall.typeArguments
      });
      const burnTicketMoveCall = {
        target: `0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55::native_pool::burn_ticket_non_entry`,
        arguments: [
          { name: "native_pool", value: VOLO.NATIVE_POOL },
          { name: "sui_system_state", value: "0x5" },
          { name: "unstake_ticket", value: "unstakeTicket" }
        ],
        typeArguments: []
      };
      moveCallInfos.push(burnTicketMoveCall);
      const [coin] = tx.moveCall({
        target: burnTicketMoveCall.target,
        arguments: [
          tx.object(VOLO.NATIVE_POOL),
          tx.object("0x5"),
          unstakeTicket
        ],
        typeArguments: burnTicketMoveCall.typeArguments
      });
      underlyingCoin = coin;
      break;
    }
    case "Mstable": {
      const createWithdrawCapMoveCall = {
        target: `0x8e9aa615cd18d263cfea43d68e2519a2de2d39075756a05f67ae6cee2794ff06::exchange_rate::create_withdraw_cap`,
        arguments: [
          {
            name: "meta_vault_sui_integration",
            value: "0x408618719d06c44a12e9c6f7fdf614a9c2fb79f262932c6f2da7621c68c7bcfa"
          },
          {
            name: "vault",
            value: "0x3062285974a5e517c88cf3395923aac788dce74f3640029a01e25d76c4e76f5d"
          },
          {
            name: "registry",
            value: "0x5ff2396592a20f7bf6ff291963948d6fc2abec279e11f50ee74d193c4cf0bba8"
          }
        ],
        typeArguments: [coinConfig.coinType]
      };
      moveCallInfos.push(createWithdrawCapMoveCall);
      const [withdrawCap] = tx.moveCall({
        target: createWithdrawCapMoveCall.target,
        arguments: [
          tx.object(
            "0x408618719d06c44a12e9c6f7fdf614a9c2fb79f262932c6f2da7621c68c7bcfa"
          ),
          tx.object(
            "0x3062285974a5e517c88cf3395923aac788dce74f3640029a01e25d76c4e76f5d"
          ),
          tx.object(
            "0x5ff2396592a20f7bf6ff291963948d6fc2abec279e11f50ee74d193c4cf0bba8"
          )
        ],
        typeArguments: createWithdrawCapMoveCall.typeArguments
      });
      const withdrawMoveCall = {
        target: `0x74ecdeabc36974da37a3e2052592b2bc2c83e878bbd74690e00816e91f93a505::vault::withdraw`,
        arguments: [
          {
            name: "vault",
            value: "0x3062285974a5e517c88cf3395923aac788dce74f3640029a01e25d76c4e76f5d"
          },
          {
            name: "version",
            value: "0x4696559327b35ff2ab26904e7426a1646312e9c836d5c6cff6709a5ccc30915c"
          },
          { name: "withdraw_cap", value: "withdrawCap" },
          { name: "coin", value: "sCoin" },
          { name: "amount_limit", value: "0" }
        ],
        typeArguments: [coinConfig.coinType, coinConfig.underlyingCoinType]
      };
      moveCallInfos.push(withdrawMoveCall);
      const [coin] = tx.moveCall({
        target: withdrawMoveCall.target,
        arguments: [
          tx.object(
            "0x3062285974a5e517c88cf3395923aac788dce74f3640029a01e25d76c4e76f5d"
          ),
          tx.object(
            "0x4696559327b35ff2ab26904e7426a1646312e9c836d5c6cff6709a5ccc30915c"
          ),
          withdrawCap,
          sCoin,
          tx.pure.u64("0")
        ],
        typeArguments: withdrawMoveCall.typeArguments
      });
      underlyingCoin = coin;
      break;
    }
    case "Winter": {
      if (coinConfig.provider === "Winter") {
        throw new Error("Underlying protocol error, try to withdraw to wWAL.");
      }
      const [coinValue, getCoinValueMoveCall] = getCoinValue(
        tx,
        sCoin,
        coinConfig.coinType,
        true
      );
      moveCallInfos.push(getCoinValueMoveCall);
      const blizzardStaking = (_a7 = Winter_Blizzard_Staking_List.find(
        (item) => item.coinType === coinConfig.coinType
      )) == null ? void 0 : _a7.value;
      if (!blizzardStaking) {
        throw new Error("Winter blizzard staking not found");
      }
      const fcfsMoveCall = {
        target: `0x10a7c91b25090b81a4de1e3a3912c994feb446529a308b7aa549eea259b11842::blizzard_hooks::fcfs`,
        arguments: [
          {
            name: "blizzard_staking",
            value: blizzardStaking
          },
          {
            name: "walrus_staking",
            value: WINTER.WALRUS_STAKING
          },
          {
            name: "amount",
            value: coinValue
          }
        ],
        typeArguments: [coinConfig.coinType]
      };
      moveCallInfos.push(fcfsMoveCall);
      const [, ixVector] = tx.moveCall({
        target: fcfsMoveCall.target,
        arguments: [
          tx.object(blizzardStaking),
          tx.object(WINTER.WALRUS_STAKING),
          coinValue
        ],
        typeArguments: fcfsMoveCall.typeArguments
      });
      const getAllowedVersionsMoveCall = {
        target: `0x29ba7f7bc53e776f27a6d1289555ded2f407b4b1a799224f06b26addbcd1c33d::blizzard_allowed_versions::get_allowed_versions`,
        arguments: [
          {
            name: "blizzard_av",
            value: "0x4199e3c5349075a98ec0b6100c7f1785242d97ba1f9311ce7a3a021a696f9e4a"
          }
        ],
        typeArguments: []
      };
      moveCallInfos.push(getAllowedVersionsMoveCall);
      const allowedVersions = tx.moveCall({
        target: getAllowedVersionsMoveCall.target,
        arguments: [
          tx.object(
            "0x4199e3c5349075a98ec0b6100c7f1785242d97ba1f9311ce7a3a021a696f9e4a"
          )
        ],
        typeArguments: getAllowedVersionsMoveCall.typeArguments
      });
      const burnLstMoveCall = {
        target: `0x29ba7f7bc53e776f27a6d1289555ded2f407b4b1a799224f06b26addbcd1c33d::blizzard_protocol::burn_lst`,
        arguments: [
          {
            name: "blizzard_staking",
            value: blizzardStaking
          },
          {
            name: "staking",
            value: WINTER.WALRUS_STAKING
          },
          {
            name: "s_coin",
            value: sCoin
          },
          {
            name: "ix_vector",
            value: ixVector
          },
          {
            name: "allowed_versions",
            value: allowedVersions
          }
        ],
        typeArguments: [coinConfig.coinType]
      };
      moveCallInfos.push(burnLstMoveCall);
      const [coin, stakedWals] = tx.moveCall({
        target: burnLstMoveCall.target,
        arguments: [
          tx.object(blizzardStaking),
          tx.object(WINTER.WALRUS_STAKING),
          sCoin,
          ixVector,
          allowedVersions
        ],
        typeArguments: burnLstMoveCall.typeArguments
      });
      const vectorTransferStakedWalMoveCall = {
        target: `0x3e12a9b6dbe7997b441b5fd6cf5e953cf2f3521a8f353f33e7f297cf7dac0ecc::blizzard_utils::vector_transfer_staked_wal`,
        arguments: [
          {
            name: "walrus_staking",
            value: WINTER.WALRUS_STAKING
          },
          {
            name: "StakedWalVector",
            value: stakedWals
          },
          {
            name: "address",
            value: address
          }
        ],
        typeArguments: []
      };
      tx.moveCall({
        target: vectorTransferStakedWalMoveCall.target,
        arguments: [
          tx.object(WINTER.WALRUS_STAKING),
          stakedWals,
          tx.pure.address(address)
        ],
        typeArguments: vectorTransferStakedWalMoveCall.typeArguments
      });
      moveCallInfos.push(vectorTransferStakedWalMoveCall);
      underlyingCoin = coin;
      break;
    }
    case "Cetus": {
      if (!amount) {
        throw new Error("Amount is required for Cetus");
      }
      if (!vaultId) {
        throw new Error("Vault ID is required for Cetus");
      }
      const sdk = Ma2({
        network: "mainnet"
      });
      sdk.senderAddress = address;
      const withdrawResult = await sdk.Vaults.calculateWithdrawAmount({
        vault_id: vaultId,
        fix_amount_a: false,
        input_amount: amount,
        slippage: Number(slippage),
        side: jt2.OneSide,
        is_ft_input: false,
        max_ft_amount: ""
      });
      const coin = await sdk.Vaults.withdraw(
        {
          vault_id: vaultId,
          return_coin: true,
          slippage: Number(slippage),
          ft_amount: withdrawResult.burn_ft_amount
        },
        tx
      );
      return debug ? [coin, moveCallInfos] : coin;
    }
    case "SpringSui": {
      const lstInfo = (_b3 = SPRING_SUI_STAKING_INFO_LIST.find(
        (item) => item.coinType === coinConfig.coinType
      )) == null ? void 0 : _b3.value;
      if (!lstInfo) {
        throw new Error(
          `SpringSui: lstInfo not found for ${coinConfig.coinType}`
        );
      }
      const redeemMoveCall = {
        target: `0x82e6f4f75441eae97d2d5850f41a09d28c7b64a05b067d37748d471f43aaf3f7::liquid_staking::redeem`,
        arguments: [
          {
            name: "liquid_staking_info",
            value: lstInfo
          },
          { name: "coin", value: sCoin },
          { name: "sui_system_state", value: "0x5" }
        ],
        typeArguments: [coinConfig.coinType]
      };
      moveCallInfos.push(redeemMoveCall);
      const [coin] = tx.moveCall({
        target: redeemMoveCall.target,
        arguments: [tx.object(lstInfo), sCoin, tx.object("0x5")],
        typeArguments: redeemMoveCall.typeArguments
      });
      underlyingCoin = coin;
      break;
    }
    default:
      console.error(
        "burnSCoin Unsupported underlying protocol: " + coinConfig.underlyingProtocol
      );
      underlyingCoin = sCoin;
  }
  return debug ? [underlyingCoin, moveCallInfos] : underlyingCoin;
};

// src/hooks/dryRun/useBurnSCoinDryRun.ts
function useBurnSCoinDryRun(outerCoinConfig, debug = false) {
  const client = rf();
  const { address } = Ft();
  const { mutateAsync: fetchLpPositionAsync } = useFetchLpPosition(outerCoinConfig);
  const { mutateAsync: fetchPyPositionAsync } = useFetchPyPosition_default(outerCoinConfig);
  return useMutation({
    mutationFn: async ({ lpAmount }, innerConfig) => {
      var _a7, _b3, _c, _d, _e3, _f, _g, _h;
      if (!address) {
        throw new Error("Please connect wallet first");
      }
      const coinConfig = innerConfig || outerCoinConfig;
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const marketPositions = await fetchLpPositionAsync();
      const [pyPositions] = await fetchPyPositionAsync();
      if (!(marketPositions == null ? void 0 : marketPositions.length)) {
        throw new Error("No LP market position found");
      }
      const tx = new Transaction();
      tx.setSender(address);
      const { pyPosition, created } = initPyPosition({
        tx,
        coinConfig,
        pyPositions
      });
      const mergedPosition = mergeLpPositions(
        tx,
        coinConfig,
        marketPositions,
        lpAmount
      );
      const moveCallInfos = [];
      const burnLpmoveCallInfo = {
        target: `${coinConfig.nemoContractId}::market::burn_lp`,
        arguments: [
          { name: "version", value: coinConfig.version },
          { name: "lp_amount", value: lpAmount },
          {
            name: "py_position",
            value: created ? "pyPosition" : pyPositions[0].id
          },
          { name: "market_state", value: coinConfig.marketStateId },
          { name: "market_position", value: marketPositions[0].id.id },
          { name: "clock", value: "0x6" }
        ],
        typeArguments: [coinConfig.syCoinType]
      };
      moveCallInfos.push(burnLpmoveCallInfo);
      const syCoin = tx.moveCall({
        target: burnLpmoveCallInfo.target,
        arguments: [
          tx.object(coinConfig.version),
          tx.pure.u64(lpAmount),
          pyPosition,
          tx.object(coinConfig.marketStateId),
          mergedPosition,
          tx.object("0x6")
        ],
        typeArguments: burnLpmoveCallInfo.typeArguments
      });
      const yieldToken = redeemSyCoin(tx, coinConfig, syCoin);
      const [, getCoinValueMoveCallInfo] = getCoinValue(
        tx,
        yieldToken,
        coinConfig.coinType,
        true
      );
      moveCallInfos.push(getCoinValueMoveCallInfo);
      const result = await client.devInspectTransactionBlock({
        sender: address,
        transactionBlock: await tx.build({
          client,
          onlyTransactionKind: true
        })
      });
      const debugInfo = {
        moveCall: moveCallInfos,
        rawResult: result
      };
      if (result == null ? void 0 : result.error) {
        throw new ContractError(result.error, debugInfo);
      }
      if (((_d = (_c = (_b3 = (_a7 = result == null ? void 0 : result.results) == null ? void 0 : _a7[result.results.length - 1]) == null ? void 0 : _b3.returnValues) == null ? void 0 : _c[0]) == null ? void 0 : _d[1]) !== "u64") {
        const message = "Failed to get coin amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      const returnValue = (_h = (_g = (_f = (_e3 = result == null ? void 0 : result.results) == null ? void 0 : _e3[result.results.length - 1]) == null ? void 0 : _f.returnValues) == null ? void 0 : _g[0]) == null ? void 0 : _h[0];
      if (!returnValue) {
        const message = "Failed to get coin amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      const coinAmount = suiBcs.U64.parse(new Uint8Array(returnValue));
      const decimal = Number(coinConfig.decimal);
      const coinValue = new decimal_default(coinAmount).div(10 ** decimal).toFixed(decimal);
      debugInfo.parsedOutput = coinValue;
      const resultObj = {
        coinValue,
        coinAmount
      };
      return debug ? [resultObj, debugInfo] : resultObj;
    }
  });
}

// src/hooks/dryRun/useBurnLpDryRun.ts
function useBurnLpDryRun(outerCoinConfig, debug = false) {
  const client = rf();
  const { address } = Ft();
  const { mutateAsync: fetchLpPositionAsync } = useFetchLpPosition(outerCoinConfig);
  const { mutateAsync: fetchPyPositionAsync } = useFetchPyPosition_default(outerCoinConfig);
  const { mutateAsync: burnSCoinDryRun } = useBurnSCoinDryRun(outerCoinConfig);
  return useMutation({
    mutationFn: async ({ lpAmount, receivingType, slippage, vaultId }, innerConfig) => {
      var _a7, _b3, _c, _d, _e3, _f, _g, _h, _i2, _j, _k;
      if (!address) {
        throw new Error("Please connect wallet first");
      }
      const coinConfig = innerConfig || outerCoinConfig;
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const marketPositions = await fetchLpPositionAsync();
      const [pyPositions] = await fetchPyPositionAsync();
      if (!(marketPositions == null ? void 0 : marketPositions.length)) {
        throw new Error("No LP market position found");
      }
      const tx = new Transaction();
      tx.setSender(address);
      const { pyPosition } = initPyPosition({
        tx,
        coinConfig,
        pyPositions
      });
      const decimal = Number(coinConfig == null ? void 0 : coinConfig.decimal);
      const mergedPosition = mergeLpPositions(
        tx,
        coinConfig,
        marketPositions,
        lpAmount
      );
      const moveCallInfos = [];
      const burnLpmoveCallInfo = {
        target: `${coinConfig.nemoContractId}::market::burn_lp`,
        arguments: [
          { name: "version", value: coinConfig.version },
          { name: "lp_amount", value: lpAmount },
          {
            name: "py_position",
            value: pyPosition
          },
          { name: "market_state", value: coinConfig.marketStateId },
          { name: "market_position", value: marketPositions[0].id.id },
          { name: "clock", value: "0x6" }
        ],
        typeArguments: [coinConfig.syCoinType]
      };
      moveCallInfos.push(burnLpmoveCallInfo);
      const syCoin = tx.moveCall({
        target: burnLpmoveCallInfo.target,
        arguments: [
          tx.object(coinConfig.version),
          tx.pure.u64(lpAmount),
          pyPosition,
          tx.object(coinConfig.marketStateId),
          mergedPosition,
          tx.object("0x6")
        ],
        typeArguments: burnLpmoveCallInfo.typeArguments
      });
      const yieldToken = redeemSyCoin(tx, coinConfig, syCoin);
      if (coinConfig.coinType === "0xb1b0650a8862e30e3f604fd6c5838bc25464b8d3d827fbd58af7cb9685b832bf::wwal::WWAL" && receivingType === "underlying") {
        throw new Error("Underlying protocol error, try to withdraw to wWAL.");
      }
      if (coinConfig.provider === "Cetus" && receivingType === "underlying") {
        throw new Error(
          `Underlying protocol error, try to withdraw to ${coinConfig.coinName}.`
        );
      }
      const minValue = ((_a7 = NEED_MIN_VALUE_LIST.find(
        (item) => item.provider === coinConfig.provider || item.coinType === (coinConfig == null ? void 0 : coinConfig.coinType)
      )) == null ? void 0 : _a7.minValue) || 0;
      if (receivingType === "underlying" && !UNSUPPORTED_UNDERLYING_COINS.includes(coinConfig == null ? void 0 : coinConfig.coinType)) {
        const { coinValue, coinAmount: amount } = await burnSCoinDryRun({
          lpAmount
        });
        if (new decimal_default(coinValue).lt(minValue)) {
          const lpValue = new decimal_default(lpAmount).div(decimal_default.pow(10, decimal));
          throw new Error(
            `Please at least enter ${formatDecimalValue(
              new decimal_default(lpValue).mul(minValue).div(coinValue),
              decimal
            )} LP ${coinConfig.coinName} or try to withdraw to ${coinConfig.coinName}
            .`
          );
        }
        const [underlyingCoin, burnMoveCallInfo] = await burnSCoin({
          tx,
          amount,
          address,
          vaultId,
          slippage,
          coinConfig,
          debug: true,
          sCoin: yieldToken
        });
        moveCallInfos.push(...burnMoveCallInfo);
        const [, getCoinValueMoveCallInfo] = getCoinValue(
          tx,
          underlyingCoin,
          coinConfig.underlyingCoinType,
          true
        );
        moveCallInfos.push(getCoinValueMoveCallInfo);
      } else {
        const [, getCoinValueMoveCallInfo] = getCoinValue(
          tx,
          yieldToken,
          coinConfig.coinType,
          true
        );
        moveCallInfos.push(getCoinValueMoveCallInfo);
      }
      const result = await client.devInspectTransactionBlock({
        sender: address,
        transactionBlock: await tx.build({
          client,
          onlyTransactionKind: true
        })
      });
      const debugInfo = {
        moveCall: moveCallInfos,
        rawResult: result
      };
      if (result.error) {
        throw new ContractError(result.error, debugInfo);
      }
      if (((_e3 = (_d = (_c = (_b3 = result == null ? void 0 : result.results) == null ? void 0 : _b3[result.results.length - 1]) == null ? void 0 : _c.returnValues) == null ? void 0 : _d[0]) == null ? void 0 : _e3[1]) !== "u64") {
        const message = "useBurnLpDryRun Failed to get output amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      if (!((_g = (_f = result == null ? void 0 : result.events) == null ? void 0 : _f[0]) == null ? void 0 : _g.parsedJson)) {
        const message = "useBurnLpDryRun Failed to get pt amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      const outputArray = (_k = (_j = (_i2 = (_h = result == null ? void 0 : result.results) == null ? void 0 : _h[result.results.length - 1]) == null ? void 0 : _i2.returnValues) == null ? void 0 : _j[0]) == null ? void 0 : _k[0];
      if (!outputArray) {
        const message = "useBurnLpDryRun Failed to get output amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      const outputAmount = suiBcs.U64.parse(new Uint8Array(outputArray));
      const outputValue = new decimal_default(outputAmount).div(10 ** decimal).toFixed(decimal);
      const syAmount = result.events[0].parsedJson.sy_amount;
      const syValue = new decimal_default(syAmount).div(10 ** decimal).toFixed(decimal);
      const ptAmount = result.events[0].parsedJson.pt_amount;
      const ptValue = new decimal_default(ptAmount).div(10 ** decimal).toFixed(decimal);
      debugInfo.parsedOutput = JSON.stringify({
        syAmount,
        ptAmount,
        outputAmount,
        outputValue,
        syValue,
        ptValue
      });
      const returnValue = {
        syAmount,
        ptAmount,
        outputAmount,
        outputValue,
        syValue,
        ptValue
      };
      return debug ? [returnValue, debugInfo] : [returnValue];
    }
  });
}

// src/hooks/useQueryButton.ts
var QUERY_CONFIGS = {
  PT_OUT_BY_SY_IN: {
    target: "get_pt_out_for_exact_sy_in_with_price_voucher",
    hook: useQueryPtOutBySyIn
  },
  YT_OUT_BY_SY_IN: {
    target: "get_yt_out_for_exact_sy_in_with_price_voucher",
    hook: useQueryYtOutBySyInWithVoucher
  },
  SY_OUT_BY_YT_IN: {
    target: "get_sy_amount_out_for_exact_yt_in_with_price_voucher",
    hook: useQuerySyOutByYtInDryRun
  },
  SY_OUT_BY_PT_IN: {
    target: "get_sy_amount_out_for_exact_pt_in_with_price_voucher",
    hook: useQuerySyOutFromPtInWithVoucher
  },
  PRICE_VOUCHER: {
    target: "get_price_voucher",
    hook: useQueryPriceVoucher
  },
  SY_OUT_FROM_BURN_LP: {
    target: "burn_lp",
    hook: useBurnLpDryRun
  },
  LP_MARKET_POSITION: {
    target: "get_lp_market_position",
    hook: useFetchLpPosition
  },
  PY_POSITION: {
    target: "get_py_position",
    hook: useFetchPyPosition_default
  },
  BURN_LP_DRY_RUN: {
    target: "burn_lp_dry_run",
    hook: useBurnLpDryRun
  }
};

// ../../node_modules/.pnpm/zustand@5.0.4_@types+react@18.3.21_react@19.1.0_use-sync-external-store@1.5.0_react@19.1.0_/node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// ../../node_modules/.pnpm/zustand@5.0.4_@types+react@18.3.21_react@19.1.0_use-sync-external-store@1.5.0_react@19.1.0_/node_modules/zustand/esm/react.mjs
var import_react20 = __toESM(require_react(), 1);
var identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = import_react20.default.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState())
  );
  import_react20.default.useDebugValue(slice);
  return slice;
}
var createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// src/hooks/usePortfolio.ts
decimal_default.set({ precision: 20, rounding: decimal_default.ROUND_DOWN });
var usePortfolioStore = create((set) => ({
  portfolios: [],
  updatePortfolio: (key, balance, reward) => set((state) => {
    const portfolioExists = state.portfolios.some(
      (portfolio) => portfolio.key === key
    );
    const safeBalance = isNaN(balance) ? "0" : balance.toString();
    const safeReward = isNaN(reward) ? "0" : reward.toString();
    if (portfolioExists) {
      return {
        portfolios: state.portfolios.map(
          (portfolio) => portfolio.key === key ? {
            key,
            balance: new decimal_default(safeBalance).toNumber(),
            reward: new decimal_default(safeReward).toNumber()
          } : portfolio
        )
      };
    } else {
      return {
        portfolios: [...state.portfolios, {
          key,
          balance: new decimal_default(safeBalance).toNumber(),
          reward: new decimal_default(safeReward).toNumber()
        }]
      };
    }
  }),
  clearPortfolios: () => set({ portfolios: [] })
}));

// src/hooks/actions/yt/useQueryYtOutBySyIn.ts
var import_react21 = __toESM(require_react());

// src/hooks/dryRun/yt/useQueryYtOutBySyIn.ts
function useQueryYtOutBySyInn({ outerCoinConfig, debug } = {
  debug: false
}) {
  const client = rf();
  const address = DEFAULT_Address;
  return useMutation({
    mutationFn: async ({
      syAmount,
      innerCoinConfig
    }) => {
      var _a7, _b3, _c;
      const coinConfig = outerCoinConfig || innerCoinConfig;
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const tx = new Transaction();
      tx.setSender(address);
      const [priceVoucher, priceVoucherInfo] = getPriceVoucher(tx, coinConfig);
      const moveCallInfo = {
        target: `${coinConfig.nemoContractId}::router::get_yt_out_for_exact_sy_in_with_price_voucher`,
        arguments: [
          { name: "net_sy_in", value: syAmount },
          { name: "min_yt_out", value: "0" },
          { name: "price_voucher", value: "priceVoucher" },
          { name: "py_state_id", value: coinConfig.pyStateId },
          { name: "market_state_id", value: coinConfig.marketStateId },
          { name: "clock", value: "0x6" }
        ],
        typeArguments: [coinConfig.syCoinType]
      };
      tx.moveCall({
        target: moveCallInfo.target,
        arguments: [
          tx.pure.u64(syAmount),
          tx.pure.u64("0"),
          priceVoucher,
          tx.object(coinConfig.pyStateId),
          tx.object(coinConfig.marketFactoryConfigId),
          tx.object(coinConfig.marketStateId),
          tx.object("0x6")
        ],
        typeArguments: moveCallInfo.typeArguments
      });
      const result = await client.devInspectTransactionBlock({
        sender: address,
        transactionBlock: await tx.build({
          client,
          onlyTransactionKind: true
        })
      });
      const debugInfo = {
        moveCall: [priceVoucherInfo, moveCallInfo],
        rawResult: result
      };
      if (result == null ? void 0 : result.error) {
        throw new ContractError(result.error, debugInfo);
      }
      if (!((_c = (_b3 = (_a7 = result == null ? void 0 : result.results) == null ? void 0 : _a7[1]) == null ? void 0 : _b3.returnValues) == null ? void 0 : _c[0])) {
        const message = "Failed to get YT amount";
        debugInfo.rawResult.error = message;
        throw new ContractError(message, debugInfo);
      }
      const decimal = Number(coinConfig.decimal);
      const ytAmount = suiBcs.U64.parse(
        new Uint8Array(result.results[1].returnValues[0][0])
      );
      const ytValue = formatDecimalValue(
        new decimal_default(ytAmount).div(10 ** decimal),
        decimal
      );
      const feeAmount = suiBcs.U128.parse(
        new Uint8Array(result.results[1].returnValues[1][0])
      );
      const feeValue = formatDecimalValue(
        new decimal_default(feeAmount).div(2 ** 64).div(10 ** decimal),
        decimal
      );
      const resultObj = { ytValue, feeValue, ytAmount: ytAmount.toString() };
      debugInfo.parsedOutput = `${ytValue},${feeValue}`;
      return debug ? [resultObj, debugInfo] : resultObj;
    }
  });
}

// src/hooks/actions/yt/useQueryYtOutBySyIn.ts
function useQueryYtOutBySyIn() {
  const lastSuccessIndexRef = (0, import_react21.useRef)(0);
  const { mutateAsync: queryYtOutBySyInDryRun } = useQueryYtOutBySyInn({
    debug: false
  });
  return useMutation({
    mutationFn: async (coinConfig) => {
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const syAmounts = ["1000000", "10000", "1000", "100", "10"];
      const fetchYtOut = async (index = lastSuccessIndexRef.current) => {
        if (index >= syAmounts.length) {
          throw new Error("All attempts failed, unable to get ytOut value");
        }
        const syAmount = syAmounts[index];
        try {
          const { ytAmount } = await queryYtOutBySyInDryRun({
            syAmount,
            innerCoinConfig: coinConfig
          });
          if (!isValidAmount(ytAmount)) {
            throw new Error("Invalid ytAmount");
          }
          lastSuccessIndexRef.current = index;
          return {
            syIn: syAmount,
            ytOut: ytAmount
          };
        } catch (error) {
          console.log(`Failed to use syIn=${syAmount}, trying next value...`);
          return fetchYtOut(index + 1);
        }
      };
      return fetchYtOut();
    }
  });
}

// src/hooks/actions/sy/useQueryPtOutBySyIn.ts
var import_react22 = __toESM(require_react());
function useQueryPtOutBySyIn2() {
  const lastSuccessIndexRef = (0, import_react22.useRef)(0);
  const { mutateAsync: queryPtOutBySyInDryRun } = useQueryPtOutBySyIn({
    debug: false
  });
  return useMutation({
    mutationFn: async (coinConfig) => {
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const syAmounts = ["1000", "100", "10", "1"];
      const fetchPtOut = async (index = lastSuccessIndexRef.current) => {
        if (index >= syAmounts.length) {
          throw new Error("All attempts failed, unable to get ptOut value");
        }
        const syAmount = syAmounts[index];
        try {
          const { ptAmount } = await queryPtOutBySyInDryRun({
            syAmount,
            innerCoinConfig: coinConfig
          });
          lastSuccessIndexRef.current = index;
          return {
            syIn: syAmount,
            ptOut: ptAmount
          };
        } catch (error) {
          console.log(`Failed to use syIn=${syAmount}, trying next value...`);
          return fetchPtOut(index + 1);
        }
      };
      return fetchPtOut();
    }
  });
}

// src/hooks/dryRun/useGetConversionRateDryRun.ts
function useGetConversionRateDryRun(debug = false) {
  const client = rf();
  const address = DEFAULT_Address;
  return useMutation({
    mutationFn: async (coinConfig) => {
      var _a7, _b3, _c, _d, _e3, _f, _g;
      if (!coinConfig) {
        throw new Error("Please select a pool");
      }
      const tx = new Transaction();
      tx.setSender(address);
      const [priceVoucher, priceVoucherMoveCallInfo] = getPriceVoucher(
        tx,
        coinConfig
      );
      const moveCallInfo = {
        target: `${coinConfig.oracleVoucherPackageId}::oracle_voucher::get_price`,
        arguments: [{ name: "price_voucher", value: "priceVoucher" }],
        typeArguments: [coinConfig.syCoinType]
      };
      tx.moveCall({
        target: moveCallInfo.target,
        arguments: [priceVoucher],
        typeArguments: moveCallInfo.typeArguments
      });
      const debugInfo = {
        moveCall: [priceVoucherMoveCallInfo, moveCallInfo],
        rawResult: {}
      };
      try {
        const result = await client.devInspectTransactionBlock({
          sender: address,
          transactionBlock: await tx.build({
            client,
            onlyTransactionKind: true
          })
        });
        debugInfo.rawResult = result;
        if (result == null ? void 0 : result.error) {
          throw new ContractError(result.error, debugInfo);
        }
        if (!((_c = (_b3 = (_a7 = result == null ? void 0 : result.results) == null ? void 0 : _a7[result.results.length - 1]) == null ? void 0 : _b3.returnValues) == null ? void 0 : _c[0])) {
          const message = "Failed to get conversion rate";
          debugInfo.rawResult = {
            error: message
          };
          throw new ContractError(message, debugInfo);
        }
        const returnValue = (_g = (_f = (_e3 = (_d = result == null ? void 0 : result.results) == null ? void 0 : _d[result.results.length - 1]) == null ? void 0 : _e3.returnValues) == null ? void 0 : _f[0]) == null ? void 0 : _g[0];
        if (!returnValue) {
          const message = "Failed to get conversion rate";
          debugInfo.rawResult = {
            error: message
          };
          throw new ContractError(message, debugInfo);
        }
        const conversionRate = suiBcs.U128.parse(new Uint8Array(returnValue));
        const formattedConversionRate = new decimal_default(conversionRate).div(new decimal_default(2).pow(64)).toFixed();
        if (new decimal_default(formattedConversionRate).lt(1) && (coinConfig == null ? void 0 : coinConfig.provider) !== "Cetus" && (coinConfig == null ? void 0 : coinConfig.underlyingProtocol) !== "Cetus") {
          throw new ContractError(
            `${coinConfig.coinType} conversion rate (${formatDecimalValue(
              formattedConversionRate,
              6
            )}) cannot be less than 1`,
            debugInfo
          );
        }
        debugInfo.parsedOutput = formattedConversionRate;
        debugInfo.result = formattedConversionRate;
        return debug ? [formattedConversionRate, debugInfo] : formattedConversionRate;
      } catch (error) {
        throw new ContractError(error.message, debugInfo);
      }
    }
  });
}

// src/hooks/actions/usePoolMetrics.ts
function calculatePtAPY(coinPrice, ptPrice, daysToExpiry) {
  if (daysToExpiry <= 0) {
    return new decimal_default(0);
  }
  const ratio = safeDivide(coinPrice, ptPrice, "decimal");
  const exponent = new decimal_default(365).div(daysToExpiry);
  return ratio.pow(exponent).minus(1).mul(100);
}
function calculateYtAPY(underlyingInterestApy, ytPriceInAsset, yearsToExpiry) {
  if (yearsToExpiry <= 0) {
    return new decimal_default(0);
  }
  const underlyingInterestApyDecimal = new decimal_default(underlyingInterestApy);
  const yearsToExpiryDecimal = new decimal_default(yearsToExpiry);
  const interestReturns = underlyingInterestApyDecimal.plus(1).pow(yearsToExpiryDecimal).minus(1);
  const rewardsReturns = new decimal_default(0);
  const ytReturns = interestReturns.plus(rewardsReturns);
  const ytReturnsAfterFee = ytReturns.mul(0.95);
  return safeDivide(ytReturnsAfterFee, ytPriceInAsset, "decimal").minus(1).mul(100);
}
function usePoolMetrics() {
  const { mutateAsync: queryYtOutBySyIn } = useQueryYtOutBySyIn();
  const { mutateAsync: queryPtOutBySyIn } = useQueryPtOutBySyIn2();
  const { mutateAsync: getConversionRate } = useGetConversionRateDryRun();
  return useMutation({
    mutationFn: async ({
      coinInfo,
      marketState
    }) => {
      if (!isValidAmount(marketState.lpSupply)) {
        const zeroResult = {
          ptPrice: "0",
          ytPrice: "0",
          ptApy: "0",
          ytApy: "0",
          scaledUnderlyingApy: "0",
          scaledPtApy: "0",
          tvl: "0",
          poolApy: "0",
          incentiveApy: "0",
          ptTvl: "0",
          syTvl: "0",
          swapFeeApy: "0",
          lpPrice: "0",
          marketState,
          incentives: []
        };
        return zeroResult;
      }
      const conversionRate = await getConversionRate(coinInfo);
      const underlyingPrice = safeDivide(
        coinInfo.coinPrice,
        conversionRate,
        "decimal"
      );
      let ptPrice;
      let ytPrice;
      try {
        const { syIn, ytOut } = await queryYtOutBySyIn(coinInfo);
        ytPrice = safeDivide(
          new decimal_default(coinInfo.coinPrice).mul(Number(syIn)),
          Number(ytOut),
          "decimal"
        );
        ptPrice = underlyingPrice.sub(ytPrice);
      } catch (error) {
        try {
          const { syIn, ptOut } = await queryPtOutBySyIn(coinInfo);
          ptPrice = safeDivide(
            new decimal_default(coinInfo.coinPrice).mul(Number(syIn)),
            Number(ptOut),
            "decimal"
          );
          ytPrice = underlyingPrice.sub(ptPrice);
        } catch (syError) {
          throw new Error("All price calculation methods failed");
        }
      }
      let poolApy = new decimal_default(0);
      let tvl = new decimal_default(0);
      let ptTvl = new decimal_default(0);
      let syTvl = new decimal_default(0);
      let swapFeeApy = new decimal_default(0);
      const daysToExpiry = new decimal_default(
        (Number(coinInfo.maturity) - Date.now()) / 1e3
      ).div(86400).toNumber();
      const ptApy = calculatePtAPY(
        Number(underlyingPrice),
        Number(ptPrice),
        daysToExpiry
      );
      const yearsToExpiry = new decimal_default(
        (Number(coinInfo.maturity) - Date.now()) / 1e3
      ).div(31536e3).toNumber();
      const ytApy = calculateYtAPY(
        Number(coinInfo.underlyingApy),
        safeDivide(ytPrice, coinInfo.underlyingPrice, "number"),
        yearsToExpiry
      );
      let scaledUnderlyingApy = new decimal_default(0);
      let scaledPtApy = new decimal_default(0);
      const totalPt = new decimal_default(marketState.totalPt);
      const totalSy = new decimal_default(marketState.totalSy);
      ptTvl = totalPt.mul(ptPrice).div(new decimal_default(10).pow(coinInfo.decimal));
      syTvl = totalSy.mul(coinInfo.coinPrice).div(new decimal_default(10).pow(coinInfo.decimal));
      tvl = syTvl.add(ptTvl);
      const rSy = totalSy.div(totalSy.add(totalPt));
      const rPt = totalPt.div(totalSy.add(totalPt));
      scaledUnderlyingApy = rSy.mul(coinInfo.underlyingApy).mul(100);
      scaledPtApy = rPt.mul(ptApy);
      const apyIncentive = new decimal_default(0);
      const swapFeeRateForLpHolder = safeDivide(
        new decimal_default(coinInfo.swapFeeForLpHolder).mul(coinInfo.coinPrice),
        tvl,
        "decimal"
      );
      const expiryRate = safeDivide(new decimal_default(365), daysToExpiry, "decimal");
      swapFeeApy = swapFeeRateForLpHolder.add(1).pow(expiryRate).minus(1).mul(100);
      const incentives = (marketState == null ? void 0 : marketState.rewardMetrics) ? marketState.rewardMetrics.map(
        ({ tokenPrice, tokenType, dailyEmission, tokenLogo }) => ({
          tokenLogo,
          tokenType,
          tokenPrice,
          apy: safeDivide(
            new decimal_default(tokenPrice).mul(dailyEmission),
            tvl,
            "decimal"
          ).plus(1).pow(365).minus(1).mul(100).toString()
        })
      ) : [];
      const incentiveApy = (incentives == null ? void 0 : incentives.reduce(
        (sum3, incentive) => sum3.plus(incentive.apy),
        new decimal_default(0)
      )) || new decimal_default(0);
      poolApy = scaledUnderlyingApy.add(scaledPtApy).add(apyIncentive).add(swapFeeApy).add(incentiveApy);
      const result = {
        ptApy: ptApy.toString(),
        ytApy: ytApy.toString(),
        scaledUnderlyingApy: scaledUnderlyingApy.toString(),
        scaledPtApy: scaledPtApy.toString(),
        incentiveApy: incentiveApy.toString(),
        tvl: tvl.toString(),
        ptTvl: ptTvl.toString(),
        syTvl: syTvl.toString(),
        ptPrice: ptPrice.toString(),
        ytPrice: ytPrice.toString(),
        poolApy: poolApy.toString(),
        swapFeeApy: swapFeeApy.toString(),
        lpPrice: tvl.div(marketState.lpSupply).mul(10 ** Number(coinInfo.decimal)).toString(),
        marketState,
        incentives
      };
      return result;
    }
  });
}

// src/hooks/usePtYtRatio.ts
function useCalculatePtYt(coinInfo, marketState) {
  const { mutateAsync: calculateMetrics } = usePoolMetrics();
  return useQuery({
    queryKey: ["useCalculatePtYt", coinInfo == null ? void 0 : coinInfo.marketStateId],
    queryFn: async () => {
      if (!coinInfo) {
        throw new Error("Please select a pool");
      }
      if (!marketState) {
        throw new Error("Failed get market state");
      }
      const coinInfoWithMetrics = coinInfo;
      if (!isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.ptApy) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.ytApy) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.scaledUnderlyingApy) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.scaledPtApy) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.incentiveApy) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.tvl) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.ptTvl) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.syTvl) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.ptPrice) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.ytPrice) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.poolApy) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.swapFeeApy) || !isValidAmount(coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.lpPrice)) {
        return calculateMetrics({
          coinInfo,
          marketState
        });
      }
      return {
        ptApy: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.ptApy,
        ytApy: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.ytApy,
        scaledUnderlyingApy: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.scaledUnderlyingApy,
        scaledPtApy: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.scaledPtApy,
        incentiveApy: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.incentiveApy,
        tvl: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.tvl,
        ptTvl: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.ptTvl,
        syTvl: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.syTvl,
        ptPrice: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.ptPrice,
        ytPrice: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.ytPrice,
        poolApy: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.poolApy,
        swapFeeApy: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.swapFeeApy,
        lpPrice: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.lpPrice,
        marketState,
        incentives: coinInfoWithMetrics == null ? void 0 : coinInfoWithMetrics.incentives
      };
    },
    enabled: !!(coinInfo == null ? void 0 : coinInfo.decimal) && !!marketState
  });
}

// src/hooks/useInputLoadingState.ts
var import_react23 = __toESM(require_react());

// src/lib/errorMapping.ts
var errorMapping = {
  257: "Sy zero deposit",
  // 0x0000101
  258: "Sy insufficient sharesOut",
  // 0x0000102
  259: "Sy zero redeem",
  // 0x0000103
  260: "Sy insufficient amountOut",
  // 0x0000104
  513: "Interest fee rate too high",
  // 0x0000201
  514: "Reward fee rate too high",
  // 0x0000202
  515: "Factory zero expiry divisor",
  // 0x0000203
  516: "Factory invalid expiry",
  // 0x0000204
  517: "Factory invalid yt amount",
  // 0x0000205
  518: "Py contract exists",
  // 0x0000206
  519: "Mismatch yt pt tokens",
  // 0x0000207
  520: "Factory yc expired",
  // 0x0000208
  521: "Factory yc not expired",
  // 0x0000209
  528: "Invalid py state",
  // 0x0000210
  769: "Market scalar root below zero",
  // 0x0000301
  770: "Market pt expired",
  // 0x0000302
  771: "Market ln fee rate too high",
  // 0x0000303
  772: "Market initial anchor too low",
  // 0x0000304
  773: "Market factory reserve fee too high",
  // 0x0000305
  774: "Market exists",
  // 0x0000306
  775: "Market scalar root is zero",
  // 0x0000307
  776: "Market pt amount is zero",
  // 0x0000308
  777: "Market sy amount is zero",
  // 0x0000309
  784: "Market expired",
  // 0x0000310
  785: "Market liquidity too low",
  // 0x0000311
  786: "Market exchange rate negative",
  // 0x0000312
  787: "Market proportion too high",
  // 0x0000313
  788: "Market proportion cannot be one",
  // 0x0000314
  789: "Market exchange rate cannot be one",
  // 0x0000315
  790: "Market exchange rate below one",
  // 0x0000316
  791: "Market burn sy amount is zero",
  // 0x0000317
  792: "Market burn pt amount is zero",
  // 0x0000318
  793: "Market insufficient pt for swap",
  // 0x0000319
  800: "Market rate scalar negative",
  // 0x0000320
  801: "Market insufficient sy for swap",
  // 0x0000321
  802: "Repay sy in exceeds expected sy in",
  // 0x0000322
  803: "Market insufficient sy in for swap yt",
  // 0x0000323
  804: "Swapped sy borrowed amount not equal",
  // 0x0000324
  805: "Market cap exceeded",
  // 0x0000325
  806: "Invalid repay",
  // 0x0000326
  807: "Register sy invalid sender",
  // 0x0000327
  808: "Sy not supported",
  // 0x0000328
  809: "Register sy type already registered",
  // 0x0000329
  816: "Register sy type not registered",
  // 0x0000330
  817: "Sy insufficient repay",
  // 0x0000331
  818: "Factory invalid py",
  // 0x0000332
  819: "Invalid py amount",
  // 0x0000333
  820: "Market insufficient pt.",
  // 0x0000334
  821: "Market invalid py state",
  // 0x0000335
  822: "Market invalid market position",
  // 0x0000336
  823: "Market lp amount is zero",
  // 0x0000337
  824: "Market insufficient lp for burn",
  // 0x0000338
  825: "Market insufficient yt balance swap",
  // 0x0000339
  832: "Invalid flash loan position",
  // 0x0000340
  833: "Create market invalid sender",
  // 0x0000341
  834: "Invalid epoch",
  // 0x0000342
  835: "Swap exact yt amount mismatch",
  // 0x0000343
  836: "Insufficient lp output",
  // 0x0000344
  837: "Price fluctuation too large",
  // 0x0000345
  1025: "Acl invalid permission",
  // 0x0000401
  1026: "Acl role already exists",
  // 0x0000402
  1027: "Acl role not exists",
  // 0x0000403
  1028: "Version mismatch error",
  // 0x0000404
  1029: "Update config invalid sender",
  // 0x0000405
  1030: "Withdraw from treasury invalid sender",
  // 0x0000406
  1031: "Invalid yt approx out",
  // 0x0000407
  1032: "Invalid sy approx out",
  // 0x0000408
  1033: "Wrong slippage tolerance",
  // 0x0000409
  1280: "Invalid reward amount",
  // 0x0000500
  1281: "Invalid reward end time",
  // 0x0000501
  1282: "Emission exceeds total reward",
  // 0x0000502
  1283: "Pool rewarder already active",
  // 0x0000503
  1284: "Reward token type mismatch",
  // 0x0000504
  1285: "Pool rewarder not active",
  // 0x0000505
  1286: "Reward not harvested",
  // 0x0000506
  65537: "Denominator error",
  // 0x10001
  65542: "Abort code on calculation result is negative",
  // 0x10006
  131074: "The quotient value would be too large to be held in a u128",
  // 0x20002
  131075: "The multiplied value would be too large to be held in a u128",
  // 0x20003
  65540: "A division by zero was encountered",
  // 0x10004
  131077: "The computed ratio when converting to a FixedPoint64 would be unrepresentable"
  // 0x20005
};
function getErrorMessage(errorCode, errorString) {
  return errorMapping[errorCode] || errorString;
}
var parseErrorMessage = (errorString) => {
  if (errorString.includes("OUT_OF_GAS")) {
    return { error: "Insufficient liquidity in the pool.", detail: "" };
  }
  const errorCodeMatch = errorString.match(/[^\d]*(\d+)\)/);
  const errorCode = errorCodeMatch ? parseInt(
    errorCodeMatch[1] || errorCodeMatch[0],
    errorCodeMatch[1] ? 10 : 16
  ) : null;
  const detail = errorCode && [790, 793].includes(errorCode) ? "To ensure the capital efficiency of the liquidity pool, Nemo's flash swap is utilized when selling YT, which requires higher liquidity. You can try swapping again later or reduce the selling amount." : "";
  if (errorString.includes("math_fixed64_with_sign")) {
    return { error: "Insufficient pool liquidity.", detail: "" };
  }
  if (errorString.includes(
    'address: ca653d2fac70a49549c7ff8792027fa4fa418fd6619954ea0f45d6fd0d081b8e, name: Identifier("vault")'
  )) {
    return {
      error: "Underlying protocol error, try to withdraw to superSUI.",
      detail: ""
    };
  }
  if (errorString.includes(
    'address: 29ba7f7bc53e776f27a6d1289555ded2f407b4b1a799224f06b26addbcd1c33d, name: Identifier("blizzard_inner_protocol")'
  )) {
    return {
      error: "Underlying protocol error, try to deposit by wWal.",
      detail: ""
    };
  }
  if (errorString.includes(
    'address: 549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55, name: Identifier("native_pool")'
  )) {
    return {
      error: "Underlying protocol error, try to withdraw to vSUI.",
      detail: ""
    };
  }
  if (errorString.includes(
    'address: 8b4d553839b219c3fd47608a0cc3d5fcc572cb25d41b7df3833208586a8d2470, name: Identifier("walstaking")'
  )) {
    return { error: "Please enter at least 1 WAL.", detail: "" };
  }
  const error = errorCode ? getErrorMessage(errorCode, errorString) : errorString.includes("math_fixed64_with_sign") ? "Insufficient pool liquidity." : errorString;
  return { error, detail };
};
function parseGasErrorMessage(msg) {
  const match = msg.match(
    /Balance of gas object (\d+) is lower than the needed amount: (\d+)/
  );
  if (match) {
    const currentBalance = parseInt(match[1], 10) / 1e9;
    const neededAmount = parseInt(match[2], 10) / 1e9;
    const shortfall = neededAmount - currentBalance;
    return `Insufficient gas fee. Your current balance is ${currentBalance} SUI, but at least ${neededAmount} SUI is required. You are short by ${shortfall} SUI. Please top up your balance and try again.`;
  }
}

// src/lib/coinUtils.ts
async function fetchCoins(client, address, coinType) {
  if (!address || !coinType) {
    throw new Error("Invalid parameters for fetching coins");
  }
  const response = await client.getCoins({
    owner: address,
    coinType
  });
  return response.data.sort(
    (a, b2) => new decimal_default(b2.balance).comparedTo(new decimal_default(a.balance))
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AFTERMATH,
  ALPAHFI,
  CETUS_VAULT_ID_LIST,
  ContractError,
  DEFAULT_Address,
  HAEDAL,
  NEED_MIN_VALUE_LIST,
  QUERY_CONFIGS,
  SCALLOP,
  SPRING_SUI_STAKING_INFO_LIST,
  SSBUCK,
  SUPER_SUI,
  Time,
  UNSUPPORTED_UNDERLYING_COINS,
  VALIDATORS,
  VOLO,
  WINTER,
  WWAL,
  Winter_Blizzard_Staking_List,
  burnLp,
  cn,
  debounce,
  depositSyCoin,
  fetchCoins,
  formatDecimalValue,
  formatLargeNumber,
  formatPortfolioNumber,
  formatTVL,
  formatTimeDiff,
  getPrice,
  getTreasury,
  get_pt_out,
  handleInfinityValues,
  isValidAmount,
  mergeAllCoins,
  mergeAllLpPositions,
  mergeLpPositions,
  mintPY,
  parseErrorMessage,
  parseGasErrorMessage,
  redeemPy,
  redeemSyCoin,
  safeDivide,
  splitCoinHelper,
  splitSyAmount,
  swapExactPtForSy,
  swapExactSyForPt,
  swapExactYtForSy,
  truncateStr,
  useCalculatePtYt,
  useRatioLoadingState
});
/*! Bundled license information:

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.js:
  (**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

cssesc/cssesc.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

axios/dist/node/axios.cjs:
  (*! Axios v1.9.0 Copyright (c) 2025 Matt Zabriskie and contributors *)

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)

@noble/hashes/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)

@nemoprotocol/wallet-kit/dist/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@nemoprotocol/wallet-kit/dist/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

media-query-parser/dist/media-query-parser.esm.js:
  (*! @license MediaQueryParser - MIT License - Tom Golden (github@tbjgolden.com) *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@cetusprotocol/aggregator-sdk/dist/index.mjs:
  (*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  *)

@cetusprotocol/vaults-sdk/dist/index.mjs:
  (*! Bundled license information:
  
  tslib/tslib.es6.js:
    (*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** *)
  
  ss-linked-list/dist/index.esm.js:
    (*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** *)
  
  ss-queue/dist/index.esm.js:
    (*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** *)
  
  ss-stack/dist/index.esm.js:
    (*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** *)
  *)
*/
